Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    comment
    usub
    input
    uadd
    ocurly
    rparen
    string
    lparen
    ccurly

Grammar

Rule 0     S' -> module
Rule 1     module -> stmt
Rule 2     stmt -> statement_list
Rule 3     statement_list -> statement
Rule 4     statement_list -> statement_list statement
Rule 5     statement -> newline statement
Rule 6     statement -> statement newline
Rule 7     statement -> print expression
Rule 8     parameters -> expression
Rule 9     parameters -> parameters comma expression
Rule 10    parameters -> <empty>
Rule 11    statement -> assname equals expression
Rule 12    statement -> expression
Rule 13    statement -> ifstmt
Rule 14    statement -> whilestmt
Rule 15    statement -> compound_stmt
Rule 16    statement -> simple_statement
Rule 17    expression -> expression oparen parameters cparen
Rule 18    expression -> lambda id_list colon expression
Rule 19    simple_statement -> return expression
Rule 20    compound_stmt -> def identifier oparen id_list cparen colon suite
Rule 21    id_list -> <empty>
Rule 22    id_list -> identifier
Rule 23    id_list -> identifier comma id_list
Rule 24    suite -> newline indent statement_list dedent
Rule 25    statement -> name incassign expression
Rule 26    statement -> name decassign expression
Rule 27    statement -> name divassign expression
Rule 28    statement -> name mulassign expression
Rule 29    statement -> name modassign expression
Rule 30    statement -> name lshiftassign expression
Rule 31    statement -> name rshiftassign expression
Rule 32    statement -> name andassign expression
Rule 33    statement -> name orassign expression
Rule 34    statement -> name xorassign expression
Rule 35    statement -> name powerassign expression
Rule 36    statement -> name floorassign expression
Rule 37    expression -> boolean
Rule 38    expression -> minus expression
Rule 39    expression -> plus expression
Rule 40    expression -> invert expression
Rule 41    expression -> expression0
Rule 42    expression -> oparen expression cparen
Rule 43    expression -> not expression
Rule 44    expression -> name
Rule 45    expression -> expression plus expression
Rule 46    expression -> expression minus expression
Rule 47    expression -> expression times expression
Rule 48    expression -> expression div expression
Rule 49    expression -> expression power expression
Rule 50    expression -> expression modulo expression
Rule 51    expression -> expression lshift expression
Rule 52    expression -> expression rshift expression
Rule 53    expression -> expression floordiv expression
Rule 54    expression -> expression and expression
Rule 55    expression -> expression or expression
Rule 56    expression -> expression xor expression
Rule 57    expression -> expression strand expression
Rule 58    expression -> expression stror expression
Rule 59    expression -> expression lt expression
Rule 60    expression -> expression gt expression
Rule 61    expression -> expression lequal expression
Rule 62    expression -> expression gequal expression
Rule 63    expression -> expression isnotequal expression
Rule 64    expression -> expression isequal expression
Rule 65    ifstmt -> if expression colon newline indent statement_list dedent
Rule 66    ifstmt -> if expression colon newline indent statement_list dedent elsestmt
Rule 67    elsestmt -> else colon newline indent statement_list dedent
Rule 68    elsestmt -> elif expression colon newline indent statement_list dedent
Rule 69    elsestmt -> elif expression colon newline indent statement_list dedent elsestmt
Rule 70    whilestmt -> while expression colon newline indent statement_list dedent
Rule 71    expression0 -> num
Rule 72    expression0 -> name
Rule 73    expression0 -> noval
Rule 74    num -> integer
Rule 75    assname -> identifier
Rule 76    name -> identifier
Rule 77    noval -> none
Rule 78    boolean -> true
Rule 79    boolean -> false
Rule 80    list_obj -> <empty>
Rule 81    list_obj -> expression
Rule 82    list_obj -> list_obj comma expression
Rule 83    expression -> list
Rule 84    list -> obracket list_obj cbracket
Rule 85    expression -> identifier obracket integer cbracket

Terminals, with rules where they appear

and                  : 54
andassign            : 32
cbracket             : 84 85
ccurly               : 
colon                : 18 20 65 66 67 68 69 70
comma                : 9 23 82
comment              : 
cparen               : 17 20 42
decassign            : 26
dedent               : 24 65 66 67 68 69 70
def                  : 20
div                  : 48
divassign            : 27
elif                 : 68 69
else                 : 67
equals               : 11
error                : 
false                : 79
floorassign          : 36
floordiv             : 53
gequal               : 62
gt                   : 60
identifier           : 20 22 23 75 76 85
if                   : 65 66
incassign            : 25
indent               : 24 65 66 67 68 69 70
input                : 
integer              : 74 85
invert               : 40
isequal              : 64
isnotequal           : 63
lambda               : 18
lequal               : 61
lparen               : 
lshift               : 51
lshiftassign         : 30
lt                   : 59
minus                : 38 46
modassign            : 29
modulo               : 50
mulassign            : 28
newline              : 5 6 24 65 66 67 68 69 70
none                 : 77
not                  : 43
obracket             : 84 85
ocurly               : 
oparen               : 17 20 42
or                   : 55
orassign             : 33
plus                 : 39 45
power                : 49
powerassign          : 35
print                : 7
return               : 19
rparen               : 
rshift               : 52
rshiftassign         : 31
strand               : 57
string               : 
stror                : 58
times                : 47
true                 : 78
uadd                 : 
usub                 : 
while                : 70
xor                  : 56
xorassign            : 34

Nonterminals, with rules where they appear

assname              : 11
boolean              : 37
compound_stmt        : 15
elsestmt             : 66 69
expression           : 7 8 9 11 12 17 18 19 25 26 27 28 29 30 31 32 33 34 35 36 38 39 40 42 43 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 66 68 69 70 81 82
expression0          : 41
id_list              : 18 20 23
ifstmt               : 13
list                 : 83
list_obj             : 82 84
module               : 0
name                 : 25 26 27 28 29 30 31 32 33 34 35 36 44 72
noval                : 73
num                  : 71
parameters           : 9 17
simple_statement     : 16
statement            : 3 4 5 6
statement_list       : 2 4 24 65 66 67 68 69 70
stmt                 : 1
suite                : 20
whilestmt            : 14

Parsing method: LALR

state 0

    (0) S' -> . module
    (1) module -> . stmt
    (2) stmt -> . statement_list
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    stmt                           shift and go to state 18
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    module                         shift and go to state 3
    statement                      shift and go to state 12
    statement_list                 shift and go to state 29
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 1

    (73) expression0 -> noval .

    oparen          reduce using rule 73 (expression0 -> noval .)
    plus            reduce using rule 73 (expression0 -> noval .)
    minus           reduce using rule 73 (expression0 -> noval .)
    times           reduce using rule 73 (expression0 -> noval .)
    div             reduce using rule 73 (expression0 -> noval .)
    power           reduce using rule 73 (expression0 -> noval .)
    modulo          reduce using rule 73 (expression0 -> noval .)
    lshift          reduce using rule 73 (expression0 -> noval .)
    rshift          reduce using rule 73 (expression0 -> noval .)
    floordiv        reduce using rule 73 (expression0 -> noval .)
    and             reduce using rule 73 (expression0 -> noval .)
    or              reduce using rule 73 (expression0 -> noval .)
    xor             reduce using rule 73 (expression0 -> noval .)
    strand          reduce using rule 73 (expression0 -> noval .)
    stror           reduce using rule 73 (expression0 -> noval .)
    lt              reduce using rule 73 (expression0 -> noval .)
    gt              reduce using rule 73 (expression0 -> noval .)
    lequal          reduce using rule 73 (expression0 -> noval .)
    gequal          reduce using rule 73 (expression0 -> noval .)
    isnotequal      reduce using rule 73 (expression0 -> noval .)
    isequal         reduce using rule 73 (expression0 -> noval .)
    newline         reduce using rule 73 (expression0 -> noval .)
    print           reduce using rule 73 (expression0 -> noval .)
    identifier      reduce using rule 73 (expression0 -> noval .)
    lambda          reduce using rule 73 (expression0 -> noval .)
    invert          reduce using rule 73 (expression0 -> noval .)
    not             reduce using rule 73 (expression0 -> noval .)
    if              reduce using rule 73 (expression0 -> noval .)
    while           reduce using rule 73 (expression0 -> noval .)
    def             reduce using rule 73 (expression0 -> noval .)
    return          reduce using rule 73 (expression0 -> noval .)
    true            reduce using rule 73 (expression0 -> noval .)
    false           reduce using rule 73 (expression0 -> noval .)
    obracket        reduce using rule 73 (expression0 -> noval .)
    integer         reduce using rule 73 (expression0 -> noval .)
    none            reduce using rule 73 (expression0 -> noval .)
    $end            reduce using rule 73 (expression0 -> noval .)
    dedent          reduce using rule 73 (expression0 -> noval .)
    colon           reduce using rule 73 (expression0 -> noval .)
    cparen          reduce using rule 73 (expression0 -> noval .)
    cbracket        reduce using rule 73 (expression0 -> noval .)
    comma           reduce using rule 73 (expression0 -> noval .)


state 2

    (16) statement -> simple_statement .

    newline         reduce using rule 16 (statement -> simple_statement .)
    print           reduce using rule 16 (statement -> simple_statement .)
    identifier      reduce using rule 16 (statement -> simple_statement .)
    lambda          reduce using rule 16 (statement -> simple_statement .)
    minus           reduce using rule 16 (statement -> simple_statement .)
    plus            reduce using rule 16 (statement -> simple_statement .)
    invert          reduce using rule 16 (statement -> simple_statement .)
    oparen          reduce using rule 16 (statement -> simple_statement .)
    not             reduce using rule 16 (statement -> simple_statement .)
    if              reduce using rule 16 (statement -> simple_statement .)
    while           reduce using rule 16 (statement -> simple_statement .)
    def             reduce using rule 16 (statement -> simple_statement .)
    return          reduce using rule 16 (statement -> simple_statement .)
    true            reduce using rule 16 (statement -> simple_statement .)
    false           reduce using rule 16 (statement -> simple_statement .)
    obracket        reduce using rule 16 (statement -> simple_statement .)
    integer         reduce using rule 16 (statement -> simple_statement .)
    none            reduce using rule 16 (statement -> simple_statement .)
    $end            reduce using rule 16 (statement -> simple_statement .)
    dedent          reduce using rule 16 (statement -> simple_statement .)


state 3

    (0) S' -> module .



state 4

    (14) statement -> whilestmt .

    newline         reduce using rule 14 (statement -> whilestmt .)
    print           reduce using rule 14 (statement -> whilestmt .)
    identifier      reduce using rule 14 (statement -> whilestmt .)
    lambda          reduce using rule 14 (statement -> whilestmt .)
    minus           reduce using rule 14 (statement -> whilestmt .)
    plus            reduce using rule 14 (statement -> whilestmt .)
    invert          reduce using rule 14 (statement -> whilestmt .)
    oparen          reduce using rule 14 (statement -> whilestmt .)
    not             reduce using rule 14 (statement -> whilestmt .)
    if              reduce using rule 14 (statement -> whilestmt .)
    while           reduce using rule 14 (statement -> whilestmt .)
    def             reduce using rule 14 (statement -> whilestmt .)
    return          reduce using rule 14 (statement -> whilestmt .)
    true            reduce using rule 14 (statement -> whilestmt .)
    false           reduce using rule 14 (statement -> whilestmt .)
    obracket        reduce using rule 14 (statement -> whilestmt .)
    integer         reduce using rule 14 (statement -> whilestmt .)
    none            reduce using rule 14 (statement -> whilestmt .)
    $end            reduce using rule 14 (statement -> whilestmt .)
    dedent          reduce using rule 14 (statement -> whilestmt .)


state 5

    (37) expression -> boolean .

    oparen          reduce using rule 37 (expression -> boolean .)
    plus            reduce using rule 37 (expression -> boolean .)
    minus           reduce using rule 37 (expression -> boolean .)
    times           reduce using rule 37 (expression -> boolean .)
    div             reduce using rule 37 (expression -> boolean .)
    power           reduce using rule 37 (expression -> boolean .)
    modulo          reduce using rule 37 (expression -> boolean .)
    lshift          reduce using rule 37 (expression -> boolean .)
    rshift          reduce using rule 37 (expression -> boolean .)
    floordiv        reduce using rule 37 (expression -> boolean .)
    and             reduce using rule 37 (expression -> boolean .)
    or              reduce using rule 37 (expression -> boolean .)
    xor             reduce using rule 37 (expression -> boolean .)
    strand          reduce using rule 37 (expression -> boolean .)
    stror           reduce using rule 37 (expression -> boolean .)
    lt              reduce using rule 37 (expression -> boolean .)
    gt              reduce using rule 37 (expression -> boolean .)
    lequal          reduce using rule 37 (expression -> boolean .)
    gequal          reduce using rule 37 (expression -> boolean .)
    isnotequal      reduce using rule 37 (expression -> boolean .)
    isequal         reduce using rule 37 (expression -> boolean .)
    newline         reduce using rule 37 (expression -> boolean .)
    dedent          reduce using rule 37 (expression -> boolean .)
    print           reduce using rule 37 (expression -> boolean .)
    identifier      reduce using rule 37 (expression -> boolean .)
    lambda          reduce using rule 37 (expression -> boolean .)
    invert          reduce using rule 37 (expression -> boolean .)
    not             reduce using rule 37 (expression -> boolean .)
    if              reduce using rule 37 (expression -> boolean .)
    while           reduce using rule 37 (expression -> boolean .)
    def             reduce using rule 37 (expression -> boolean .)
    return          reduce using rule 37 (expression -> boolean .)
    true            reduce using rule 37 (expression -> boolean .)
    false           reduce using rule 37 (expression -> boolean .)
    obracket        reduce using rule 37 (expression -> boolean .)
    integer         reduce using rule 37 (expression -> boolean .)
    none            reduce using rule 37 (expression -> boolean .)
    $end            reduce using rule 37 (expression -> boolean .)
    colon           reduce using rule 37 (expression -> boolean .)
    cparen          reduce using rule 37 (expression -> boolean .)
    cbracket        reduce using rule 37 (expression -> boolean .)
    comma           reduce using rule 37 (expression -> boolean .)


state 6

    (19) simple_statement -> return . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 37

state 7

    (13) statement -> ifstmt .

    newline         reduce using rule 13 (statement -> ifstmt .)
    print           reduce using rule 13 (statement -> ifstmt .)
    identifier      reduce using rule 13 (statement -> ifstmt .)
    lambda          reduce using rule 13 (statement -> ifstmt .)
    minus           reduce using rule 13 (statement -> ifstmt .)
    plus            reduce using rule 13 (statement -> ifstmt .)
    invert          reduce using rule 13 (statement -> ifstmt .)
    oparen          reduce using rule 13 (statement -> ifstmt .)
    not             reduce using rule 13 (statement -> ifstmt .)
    if              reduce using rule 13 (statement -> ifstmt .)
    while           reduce using rule 13 (statement -> ifstmt .)
    def             reduce using rule 13 (statement -> ifstmt .)
    return          reduce using rule 13 (statement -> ifstmt .)
    true            reduce using rule 13 (statement -> ifstmt .)
    false           reduce using rule 13 (statement -> ifstmt .)
    obracket        reduce using rule 13 (statement -> ifstmt .)
    integer         reduce using rule 13 (statement -> ifstmt .)
    none            reduce using rule 13 (statement -> ifstmt .)
    $end            reduce using rule 13 (statement -> ifstmt .)
    dedent          reduce using rule 13 (statement -> ifstmt .)


state 8

    (79) boolean -> false .

    oparen          reduce using rule 79 (boolean -> false .)
    plus            reduce using rule 79 (boolean -> false .)
    minus           reduce using rule 79 (boolean -> false .)
    times           reduce using rule 79 (boolean -> false .)
    div             reduce using rule 79 (boolean -> false .)
    power           reduce using rule 79 (boolean -> false .)
    modulo          reduce using rule 79 (boolean -> false .)
    lshift          reduce using rule 79 (boolean -> false .)
    rshift          reduce using rule 79 (boolean -> false .)
    floordiv        reduce using rule 79 (boolean -> false .)
    and             reduce using rule 79 (boolean -> false .)
    or              reduce using rule 79 (boolean -> false .)
    xor             reduce using rule 79 (boolean -> false .)
    strand          reduce using rule 79 (boolean -> false .)
    stror           reduce using rule 79 (boolean -> false .)
    lt              reduce using rule 79 (boolean -> false .)
    gt              reduce using rule 79 (boolean -> false .)
    lequal          reduce using rule 79 (boolean -> false .)
    gequal          reduce using rule 79 (boolean -> false .)
    isnotequal      reduce using rule 79 (boolean -> false .)
    isequal         reduce using rule 79 (boolean -> false .)
    newline         reduce using rule 79 (boolean -> false .)
    print           reduce using rule 79 (boolean -> false .)
    identifier      reduce using rule 79 (boolean -> false .)
    lambda          reduce using rule 79 (boolean -> false .)
    invert          reduce using rule 79 (boolean -> false .)
    not             reduce using rule 79 (boolean -> false .)
    if              reduce using rule 79 (boolean -> false .)
    while           reduce using rule 79 (boolean -> false .)
    def             reduce using rule 79 (boolean -> false .)
    return          reduce using rule 79 (boolean -> false .)
    true            reduce using rule 79 (boolean -> false .)
    false           reduce using rule 79 (boolean -> false .)
    obracket        reduce using rule 79 (boolean -> false .)
    integer         reduce using rule 79 (boolean -> false .)
    none            reduce using rule 79 (boolean -> false .)
    $end            reduce using rule 79 (boolean -> false .)
    dedent          reduce using rule 79 (boolean -> false .)
    colon           reduce using rule 79 (boolean -> false .)
    cparen          reduce using rule 79 (boolean -> false .)
    cbracket        reduce using rule 79 (boolean -> false .)
    comma           reduce using rule 79 (boolean -> false .)


state 9

    (65) ifstmt -> if . expression colon newline indent statement_list dedent
    (66) ifstmt -> if . expression colon newline indent statement_list dedent elsestmt
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 38

state 10

    (71) expression0 -> num .

    oparen          reduce using rule 71 (expression0 -> num .)
    plus            reduce using rule 71 (expression0 -> num .)
    minus           reduce using rule 71 (expression0 -> num .)
    times           reduce using rule 71 (expression0 -> num .)
    div             reduce using rule 71 (expression0 -> num .)
    power           reduce using rule 71 (expression0 -> num .)
    modulo          reduce using rule 71 (expression0 -> num .)
    lshift          reduce using rule 71 (expression0 -> num .)
    rshift          reduce using rule 71 (expression0 -> num .)
    floordiv        reduce using rule 71 (expression0 -> num .)
    and             reduce using rule 71 (expression0 -> num .)
    or              reduce using rule 71 (expression0 -> num .)
    xor             reduce using rule 71 (expression0 -> num .)
    strand          reduce using rule 71 (expression0 -> num .)
    stror           reduce using rule 71 (expression0 -> num .)
    lt              reduce using rule 71 (expression0 -> num .)
    gt              reduce using rule 71 (expression0 -> num .)
    lequal          reduce using rule 71 (expression0 -> num .)
    gequal          reduce using rule 71 (expression0 -> num .)
    isnotequal      reduce using rule 71 (expression0 -> num .)
    isequal         reduce using rule 71 (expression0 -> num .)
    newline         reduce using rule 71 (expression0 -> num .)
    print           reduce using rule 71 (expression0 -> num .)
    identifier      reduce using rule 71 (expression0 -> num .)
    lambda          reduce using rule 71 (expression0 -> num .)
    invert          reduce using rule 71 (expression0 -> num .)
    not             reduce using rule 71 (expression0 -> num .)
    if              reduce using rule 71 (expression0 -> num .)
    while           reduce using rule 71 (expression0 -> num .)
    def             reduce using rule 71 (expression0 -> num .)
    return          reduce using rule 71 (expression0 -> num .)
    true            reduce using rule 71 (expression0 -> num .)
    false           reduce using rule 71 (expression0 -> num .)
    obracket        reduce using rule 71 (expression0 -> num .)
    integer         reduce using rule 71 (expression0 -> num .)
    none            reduce using rule 71 (expression0 -> num .)
    $end            reduce using rule 71 (expression0 -> num .)
    dedent          reduce using rule 71 (expression0 -> num .)
    colon           reduce using rule 71 (expression0 -> num .)
    cparen          reduce using rule 71 (expression0 -> num .)
    cbracket        reduce using rule 71 (expression0 -> num .)
    comma           reduce using rule 71 (expression0 -> num .)


state 11

    (40) expression -> invert . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 39

state 12

    (3) statement_list -> statement .
    (6) statement -> statement . newline

  ! shift/reduce conflict for newline resolved as shift
    dedent          reduce using rule 3 (statement_list -> statement .)
    print           reduce using rule 3 (statement_list -> statement .)
    identifier      reduce using rule 3 (statement_list -> statement .)
    lambda          reduce using rule 3 (statement_list -> statement .)
    minus           reduce using rule 3 (statement_list -> statement .)
    plus            reduce using rule 3 (statement_list -> statement .)
    invert          reduce using rule 3 (statement_list -> statement .)
    oparen          reduce using rule 3 (statement_list -> statement .)
    not             reduce using rule 3 (statement_list -> statement .)
    if              reduce using rule 3 (statement_list -> statement .)
    while           reduce using rule 3 (statement_list -> statement .)
    def             reduce using rule 3 (statement_list -> statement .)
    return          reduce using rule 3 (statement_list -> statement .)
    true            reduce using rule 3 (statement_list -> statement .)
    false           reduce using rule 3 (statement_list -> statement .)
    obracket        reduce using rule 3 (statement_list -> statement .)
    integer         reduce using rule 3 (statement_list -> statement .)
    none            reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    newline         shift and go to state 40

  ! newline         [ reduce using rule 3 (statement_list -> statement .) ]


state 13

    (42) expression -> oparen . expression cparen
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 41

state 14

    (7) statement -> print . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 42

state 15

    (15) statement -> compound_stmt .

    newline         reduce using rule 15 (statement -> compound_stmt .)
    print           reduce using rule 15 (statement -> compound_stmt .)
    identifier      reduce using rule 15 (statement -> compound_stmt .)
    lambda          reduce using rule 15 (statement -> compound_stmt .)
    minus           reduce using rule 15 (statement -> compound_stmt .)
    plus            reduce using rule 15 (statement -> compound_stmt .)
    invert          reduce using rule 15 (statement -> compound_stmt .)
    oparen          reduce using rule 15 (statement -> compound_stmt .)
    not             reduce using rule 15 (statement -> compound_stmt .)
    if              reduce using rule 15 (statement -> compound_stmt .)
    while           reduce using rule 15 (statement -> compound_stmt .)
    def             reduce using rule 15 (statement -> compound_stmt .)
    return          reduce using rule 15 (statement -> compound_stmt .)
    true            reduce using rule 15 (statement -> compound_stmt .)
    false           reduce using rule 15 (statement -> compound_stmt .)
    obracket        reduce using rule 15 (statement -> compound_stmt .)
    integer         reduce using rule 15 (statement -> compound_stmt .)
    none            reduce using rule 15 (statement -> compound_stmt .)
    $end            reduce using rule 15 (statement -> compound_stmt .)
    dedent          reduce using rule 15 (statement -> compound_stmt .)


state 16

    (74) num -> integer .

    oparen          reduce using rule 74 (num -> integer .)
    plus            reduce using rule 74 (num -> integer .)
    minus           reduce using rule 74 (num -> integer .)
    times           reduce using rule 74 (num -> integer .)
    div             reduce using rule 74 (num -> integer .)
    power           reduce using rule 74 (num -> integer .)
    modulo          reduce using rule 74 (num -> integer .)
    lshift          reduce using rule 74 (num -> integer .)
    rshift          reduce using rule 74 (num -> integer .)
    floordiv        reduce using rule 74 (num -> integer .)
    and             reduce using rule 74 (num -> integer .)
    or              reduce using rule 74 (num -> integer .)
    xor             reduce using rule 74 (num -> integer .)
    strand          reduce using rule 74 (num -> integer .)
    stror           reduce using rule 74 (num -> integer .)
    lt              reduce using rule 74 (num -> integer .)
    gt              reduce using rule 74 (num -> integer .)
    lequal          reduce using rule 74 (num -> integer .)
    gequal          reduce using rule 74 (num -> integer .)
    isnotequal      reduce using rule 74 (num -> integer .)
    isequal         reduce using rule 74 (num -> integer .)
    newline         reduce using rule 74 (num -> integer .)
    print           reduce using rule 74 (num -> integer .)
    identifier      reduce using rule 74 (num -> integer .)
    lambda          reduce using rule 74 (num -> integer .)
    invert          reduce using rule 74 (num -> integer .)
    not             reduce using rule 74 (num -> integer .)
    if              reduce using rule 74 (num -> integer .)
    while           reduce using rule 74 (num -> integer .)
    def             reduce using rule 74 (num -> integer .)
    return          reduce using rule 74 (num -> integer .)
    true            reduce using rule 74 (num -> integer .)
    false           reduce using rule 74 (num -> integer .)
    obracket        reduce using rule 74 (num -> integer .)
    integer         reduce using rule 74 (num -> integer .)
    none            reduce using rule 74 (num -> integer .)
    $end            reduce using rule 74 (num -> integer .)
    dedent          reduce using rule 74 (num -> integer .)
    colon           reduce using rule 74 (num -> integer .)
    cparen          reduce using rule 74 (num -> integer .)
    cbracket        reduce using rule 74 (num -> integer .)
    comma           reduce using rule 74 (num -> integer .)


state 17

    (5) statement -> newline . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 43
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 18

    (1) module -> stmt .

    $end            reduce using rule 1 (module -> stmt .)


state 19

    (11) statement -> assname . equals expression

    equals          shift and go to state 44


state 20

    (43) expression -> not . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 45

state 21

    (41) expression -> expression0 .

    oparen          reduce using rule 41 (expression -> expression0 .)
    plus            reduce using rule 41 (expression -> expression0 .)
    minus           reduce using rule 41 (expression -> expression0 .)
    times           reduce using rule 41 (expression -> expression0 .)
    div             reduce using rule 41 (expression -> expression0 .)
    power           reduce using rule 41 (expression -> expression0 .)
    modulo          reduce using rule 41 (expression -> expression0 .)
    lshift          reduce using rule 41 (expression -> expression0 .)
    rshift          reduce using rule 41 (expression -> expression0 .)
    floordiv        reduce using rule 41 (expression -> expression0 .)
    and             reduce using rule 41 (expression -> expression0 .)
    or              reduce using rule 41 (expression -> expression0 .)
    xor             reduce using rule 41 (expression -> expression0 .)
    strand          reduce using rule 41 (expression -> expression0 .)
    stror           reduce using rule 41 (expression -> expression0 .)
    lt              reduce using rule 41 (expression -> expression0 .)
    gt              reduce using rule 41 (expression -> expression0 .)
    lequal          reduce using rule 41 (expression -> expression0 .)
    gequal          reduce using rule 41 (expression -> expression0 .)
    isnotequal      reduce using rule 41 (expression -> expression0 .)
    isequal         reduce using rule 41 (expression -> expression0 .)
    newline         reduce using rule 41 (expression -> expression0 .)
    dedent          reduce using rule 41 (expression -> expression0 .)
    print           reduce using rule 41 (expression -> expression0 .)
    identifier      reduce using rule 41 (expression -> expression0 .)
    lambda          reduce using rule 41 (expression -> expression0 .)
    invert          reduce using rule 41 (expression -> expression0 .)
    not             reduce using rule 41 (expression -> expression0 .)
    if              reduce using rule 41 (expression -> expression0 .)
    while           reduce using rule 41 (expression -> expression0 .)
    def             reduce using rule 41 (expression -> expression0 .)
    return          reduce using rule 41 (expression -> expression0 .)
    true            reduce using rule 41 (expression -> expression0 .)
    false           reduce using rule 41 (expression -> expression0 .)
    obracket        reduce using rule 41 (expression -> expression0 .)
    integer         reduce using rule 41 (expression -> expression0 .)
    none            reduce using rule 41 (expression -> expression0 .)
    $end            reduce using rule 41 (expression -> expression0 .)
    colon           reduce using rule 41 (expression -> expression0 .)
    cparen          reduce using rule 41 (expression -> expression0 .)
    cbracket        reduce using rule 41 (expression -> expression0 .)
    comma           reduce using rule 41 (expression -> expression0 .)


state 22

    (78) boolean -> true .

    oparen          reduce using rule 78 (boolean -> true .)
    plus            reduce using rule 78 (boolean -> true .)
    minus           reduce using rule 78 (boolean -> true .)
    times           reduce using rule 78 (boolean -> true .)
    div             reduce using rule 78 (boolean -> true .)
    power           reduce using rule 78 (boolean -> true .)
    modulo          reduce using rule 78 (boolean -> true .)
    lshift          reduce using rule 78 (boolean -> true .)
    rshift          reduce using rule 78 (boolean -> true .)
    floordiv        reduce using rule 78 (boolean -> true .)
    and             reduce using rule 78 (boolean -> true .)
    or              reduce using rule 78 (boolean -> true .)
    xor             reduce using rule 78 (boolean -> true .)
    strand          reduce using rule 78 (boolean -> true .)
    stror           reduce using rule 78 (boolean -> true .)
    lt              reduce using rule 78 (boolean -> true .)
    gt              reduce using rule 78 (boolean -> true .)
    lequal          reduce using rule 78 (boolean -> true .)
    gequal          reduce using rule 78 (boolean -> true .)
    isnotequal      reduce using rule 78 (boolean -> true .)
    isequal         reduce using rule 78 (boolean -> true .)
    newline         reduce using rule 78 (boolean -> true .)
    print           reduce using rule 78 (boolean -> true .)
    identifier      reduce using rule 78 (boolean -> true .)
    lambda          reduce using rule 78 (boolean -> true .)
    invert          reduce using rule 78 (boolean -> true .)
    not             reduce using rule 78 (boolean -> true .)
    if              reduce using rule 78 (boolean -> true .)
    while           reduce using rule 78 (boolean -> true .)
    def             reduce using rule 78 (boolean -> true .)
    return          reduce using rule 78 (boolean -> true .)
    true            reduce using rule 78 (boolean -> true .)
    false           reduce using rule 78 (boolean -> true .)
    obracket        reduce using rule 78 (boolean -> true .)
    integer         reduce using rule 78 (boolean -> true .)
    none            reduce using rule 78 (boolean -> true .)
    $end            reduce using rule 78 (boolean -> true .)
    dedent          reduce using rule 78 (boolean -> true .)
    colon           reduce using rule 78 (boolean -> true .)
    cparen          reduce using rule 78 (boolean -> true .)
    cbracket        reduce using rule 78 (boolean -> true .)
    comma           reduce using rule 78 (boolean -> true .)


state 23

    (77) noval -> none .

    oparen          reduce using rule 77 (noval -> none .)
    plus            reduce using rule 77 (noval -> none .)
    minus           reduce using rule 77 (noval -> none .)
    times           reduce using rule 77 (noval -> none .)
    div             reduce using rule 77 (noval -> none .)
    power           reduce using rule 77 (noval -> none .)
    modulo          reduce using rule 77 (noval -> none .)
    lshift          reduce using rule 77 (noval -> none .)
    rshift          reduce using rule 77 (noval -> none .)
    floordiv        reduce using rule 77 (noval -> none .)
    and             reduce using rule 77 (noval -> none .)
    or              reduce using rule 77 (noval -> none .)
    xor             reduce using rule 77 (noval -> none .)
    strand          reduce using rule 77 (noval -> none .)
    stror           reduce using rule 77 (noval -> none .)
    lt              reduce using rule 77 (noval -> none .)
    gt              reduce using rule 77 (noval -> none .)
    lequal          reduce using rule 77 (noval -> none .)
    gequal          reduce using rule 77 (noval -> none .)
    isnotequal      reduce using rule 77 (noval -> none .)
    isequal         reduce using rule 77 (noval -> none .)
    cparen          reduce using rule 77 (noval -> none .)
    comma           reduce using rule 77 (noval -> none .)
    newline         reduce using rule 77 (noval -> none .)
    print           reduce using rule 77 (noval -> none .)
    identifier      reduce using rule 77 (noval -> none .)
    lambda          reduce using rule 77 (noval -> none .)
    invert          reduce using rule 77 (noval -> none .)
    not             reduce using rule 77 (noval -> none .)
    if              reduce using rule 77 (noval -> none .)
    while           reduce using rule 77 (noval -> none .)
    def             reduce using rule 77 (noval -> none .)
    return          reduce using rule 77 (noval -> none .)
    true            reduce using rule 77 (noval -> none .)
    false           reduce using rule 77 (noval -> none .)
    obracket        reduce using rule 77 (noval -> none .)
    integer         reduce using rule 77 (noval -> none .)
    none            reduce using rule 77 (noval -> none .)
    $end            reduce using rule 77 (noval -> none .)
    dedent          reduce using rule 77 (noval -> none .)
    colon           reduce using rule 77 (noval -> none .)
    cbracket        reduce using rule 77 (noval -> none .)


state 24

    (25) statement -> name . incassign expression
    (26) statement -> name . decassign expression
    (27) statement -> name . divassign expression
    (28) statement -> name . mulassign expression
    (29) statement -> name . modassign expression
    (30) statement -> name . lshiftassign expression
    (31) statement -> name . rshiftassign expression
    (32) statement -> name . andassign expression
    (33) statement -> name . orassign expression
    (34) statement -> name . xorassign expression
    (35) statement -> name . powerassign expression
    (36) statement -> name . floorassign expression
    (44) expression -> name .
    (72) expression0 -> name .

  ! reduce/reduce conflict for oparen resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for plus resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for minus resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for times resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for div resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for power resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for modulo resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lshift resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for rshift resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for floordiv resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for and resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for or resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for xor resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for strand resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for stror resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lt resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for gt resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for gequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for isnotequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for isequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for newline resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for dedent resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for print resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for identifier resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lambda resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for invert resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for not resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for if resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for while resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for def resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for return resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for true resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for false resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for obracket resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for integer resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for none resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for $end resolved using rule 44 (expression -> name .)
    incassign       shift and go to state 51
    decassign       shift and go to state 56
    divassign       shift and go to state 52
    mulassign       shift and go to state 53
    modassign       shift and go to state 54
    lshiftassign    shift and go to state 48
    rshiftassign    shift and go to state 49
    andassign       shift and go to state 55
    orassign        shift and go to state 47
    xorassign       shift and go to state 57
    powerassign     shift and go to state 50
    floorassign     shift and go to state 46
    oparen          reduce using rule 44 (expression -> name .)
    plus            reduce using rule 44 (expression -> name .)
    minus           reduce using rule 44 (expression -> name .)
    times           reduce using rule 44 (expression -> name .)
    div             reduce using rule 44 (expression -> name .)
    power           reduce using rule 44 (expression -> name .)
    modulo          reduce using rule 44 (expression -> name .)
    lshift          reduce using rule 44 (expression -> name .)
    rshift          reduce using rule 44 (expression -> name .)
    floordiv        reduce using rule 44 (expression -> name .)
    and             reduce using rule 44 (expression -> name .)
    or              reduce using rule 44 (expression -> name .)
    xor             reduce using rule 44 (expression -> name .)
    strand          reduce using rule 44 (expression -> name .)
    stror           reduce using rule 44 (expression -> name .)
    lt              reduce using rule 44 (expression -> name .)
    gt              reduce using rule 44 (expression -> name .)
    lequal          reduce using rule 44 (expression -> name .)
    gequal          reduce using rule 44 (expression -> name .)
    isnotequal      reduce using rule 44 (expression -> name .)
    isequal         reduce using rule 44 (expression -> name .)
    newline         reduce using rule 44 (expression -> name .)
    dedent          reduce using rule 44 (expression -> name .)
    print           reduce using rule 44 (expression -> name .)
    identifier      reduce using rule 44 (expression -> name .)
    lambda          reduce using rule 44 (expression -> name .)
    invert          reduce using rule 44 (expression -> name .)
    not             reduce using rule 44 (expression -> name .)
    if              reduce using rule 44 (expression -> name .)
    while           reduce using rule 44 (expression -> name .)
    def             reduce using rule 44 (expression -> name .)
    return          reduce using rule 44 (expression -> name .)
    true            reduce using rule 44 (expression -> name .)
    false           reduce using rule 44 (expression -> name .)
    obracket        reduce using rule 44 (expression -> name .)
    integer         reduce using rule 44 (expression -> name .)
    none            reduce using rule 44 (expression -> name .)
    $end            reduce using rule 44 (expression -> name .)

  ! oparen          [ reduce using rule 72 (expression0 -> name .) ]
  ! plus            [ reduce using rule 72 (expression0 -> name .) ]
  ! minus           [ reduce using rule 72 (expression0 -> name .) ]
  ! times           [ reduce using rule 72 (expression0 -> name .) ]
  ! div             [ reduce using rule 72 (expression0 -> name .) ]
  ! power           [ reduce using rule 72 (expression0 -> name .) ]
  ! modulo          [ reduce using rule 72 (expression0 -> name .) ]
  ! lshift          [ reduce using rule 72 (expression0 -> name .) ]
  ! rshift          [ reduce using rule 72 (expression0 -> name .) ]
  ! floordiv        [ reduce using rule 72 (expression0 -> name .) ]
  ! and             [ reduce using rule 72 (expression0 -> name .) ]
  ! or              [ reduce using rule 72 (expression0 -> name .) ]
  ! xor             [ reduce using rule 72 (expression0 -> name .) ]
  ! strand          [ reduce using rule 72 (expression0 -> name .) ]
  ! stror           [ reduce using rule 72 (expression0 -> name .) ]
  ! lt              [ reduce using rule 72 (expression0 -> name .) ]
  ! gt              [ reduce using rule 72 (expression0 -> name .) ]
  ! lequal          [ reduce using rule 72 (expression0 -> name .) ]
  ! gequal          [ reduce using rule 72 (expression0 -> name .) ]
  ! isnotequal      [ reduce using rule 72 (expression0 -> name .) ]
  ! isequal         [ reduce using rule 72 (expression0 -> name .) ]
  ! newline         [ reduce using rule 72 (expression0 -> name .) ]
  ! dedent          [ reduce using rule 72 (expression0 -> name .) ]
  ! print           [ reduce using rule 72 (expression0 -> name .) ]
  ! identifier      [ reduce using rule 72 (expression0 -> name .) ]
  ! lambda          [ reduce using rule 72 (expression0 -> name .) ]
  ! invert          [ reduce using rule 72 (expression0 -> name .) ]
  ! not             [ reduce using rule 72 (expression0 -> name .) ]
  ! if              [ reduce using rule 72 (expression0 -> name .) ]
  ! while           [ reduce using rule 72 (expression0 -> name .) ]
  ! def             [ reduce using rule 72 (expression0 -> name .) ]
  ! return          [ reduce using rule 72 (expression0 -> name .) ]
  ! true            [ reduce using rule 72 (expression0 -> name .) ]
  ! false           [ reduce using rule 72 (expression0 -> name .) ]
  ! obracket        [ reduce using rule 72 (expression0 -> name .) ]
  ! integer         [ reduce using rule 72 (expression0 -> name .) ]
  ! none            [ reduce using rule 72 (expression0 -> name .) ]
  ! $end            [ reduce using rule 72 (expression0 -> name .) ]


state 25

    (84) list -> obracket . list_obj cbracket
    (80) list_obj -> .
    (81) list_obj -> . expression
    (82) list_obj -> . list_obj comma expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    cbracket        reduce using rule 80 (list_obj -> .)
    comma           reduce using rule 80 (list_obj -> .)
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    list_obj                       shift and go to state 58
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 59
    name                           shift and go to state 35

state 26

    (83) expression -> list .

    oparen          reduce using rule 83 (expression -> list .)
    plus            reduce using rule 83 (expression -> list .)
    minus           reduce using rule 83 (expression -> list .)
    times           reduce using rule 83 (expression -> list .)
    div             reduce using rule 83 (expression -> list .)
    power           reduce using rule 83 (expression -> list .)
    modulo          reduce using rule 83 (expression -> list .)
    lshift          reduce using rule 83 (expression -> list .)
    rshift          reduce using rule 83 (expression -> list .)
    floordiv        reduce using rule 83 (expression -> list .)
    and             reduce using rule 83 (expression -> list .)
    or              reduce using rule 83 (expression -> list .)
    xor             reduce using rule 83 (expression -> list .)
    strand          reduce using rule 83 (expression -> list .)
    stror           reduce using rule 83 (expression -> list .)
    lt              reduce using rule 83 (expression -> list .)
    gt              reduce using rule 83 (expression -> list .)
    lequal          reduce using rule 83 (expression -> list .)
    gequal          reduce using rule 83 (expression -> list .)
    isnotequal      reduce using rule 83 (expression -> list .)
    isequal         reduce using rule 83 (expression -> list .)
    newline         reduce using rule 83 (expression -> list .)
    dedent          reduce using rule 83 (expression -> list .)
    print           reduce using rule 83 (expression -> list .)
    identifier      reduce using rule 83 (expression -> list .)
    lambda          reduce using rule 83 (expression -> list .)
    invert          reduce using rule 83 (expression -> list .)
    not             reduce using rule 83 (expression -> list .)
    if              reduce using rule 83 (expression -> list .)
    while           reduce using rule 83 (expression -> list .)
    def             reduce using rule 83 (expression -> list .)
    return          reduce using rule 83 (expression -> list .)
    true            reduce using rule 83 (expression -> list .)
    false           reduce using rule 83 (expression -> list .)
    obracket        reduce using rule 83 (expression -> list .)
    integer         reduce using rule 83 (expression -> list .)
    none            reduce using rule 83 (expression -> list .)
    $end            reduce using rule 83 (expression -> list .)
    colon           reduce using rule 83 (expression -> list .)
    cparen          reduce using rule 83 (expression -> list .)
    cbracket        reduce using rule 83 (expression -> list .)
    comma           reduce using rule 83 (expression -> list .)


state 27

    (70) whilestmt -> while . expression colon newline indent statement_list dedent
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 60

state 28

    (39) expression -> plus . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 61

state 29

    (2) stmt -> statement_list .
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    $end            reduce using rule 2 (stmt -> statement_list .)
    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 62
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 30

    (75) assname -> identifier .
    (85) expression -> identifier . obracket integer cbracket
    (76) name -> identifier .

  ! shift/reduce conflict for obracket resolved as shift
    equals          reduce using rule 75 (assname -> identifier .)
    obracket        shift and go to state 63
    incassign       reduce using rule 76 (name -> identifier .)
    decassign       reduce using rule 76 (name -> identifier .)
    divassign       reduce using rule 76 (name -> identifier .)
    mulassign       reduce using rule 76 (name -> identifier .)
    modassign       reduce using rule 76 (name -> identifier .)
    lshiftassign    reduce using rule 76 (name -> identifier .)
    rshiftassign    reduce using rule 76 (name -> identifier .)
    andassign       reduce using rule 76 (name -> identifier .)
    orassign        reduce using rule 76 (name -> identifier .)
    xorassign       reduce using rule 76 (name -> identifier .)
    powerassign     reduce using rule 76 (name -> identifier .)
    floorassign     reduce using rule 76 (name -> identifier .)
    oparen          reduce using rule 76 (name -> identifier .)
    plus            reduce using rule 76 (name -> identifier .)
    minus           reduce using rule 76 (name -> identifier .)
    times           reduce using rule 76 (name -> identifier .)
    div             reduce using rule 76 (name -> identifier .)
    power           reduce using rule 76 (name -> identifier .)
    modulo          reduce using rule 76 (name -> identifier .)
    lshift          reduce using rule 76 (name -> identifier .)
    rshift          reduce using rule 76 (name -> identifier .)
    floordiv        reduce using rule 76 (name -> identifier .)
    and             reduce using rule 76 (name -> identifier .)
    or              reduce using rule 76 (name -> identifier .)
    xor             reduce using rule 76 (name -> identifier .)
    strand          reduce using rule 76 (name -> identifier .)
    stror           reduce using rule 76 (name -> identifier .)
    lt              reduce using rule 76 (name -> identifier .)
    gt              reduce using rule 76 (name -> identifier .)
    lequal          reduce using rule 76 (name -> identifier .)
    gequal          reduce using rule 76 (name -> identifier .)
    isnotequal      reduce using rule 76 (name -> identifier .)
    isequal         reduce using rule 76 (name -> identifier .)
    newline         reduce using rule 76 (name -> identifier .)
    print           reduce using rule 76 (name -> identifier .)
    identifier      reduce using rule 76 (name -> identifier .)
    lambda          reduce using rule 76 (name -> identifier .)
    invert          reduce using rule 76 (name -> identifier .)
    not             reduce using rule 76 (name -> identifier .)
    if              reduce using rule 76 (name -> identifier .)
    while           reduce using rule 76 (name -> identifier .)
    def             reduce using rule 76 (name -> identifier .)
    return          reduce using rule 76 (name -> identifier .)
    true            reduce using rule 76 (name -> identifier .)
    false           reduce using rule 76 (name -> identifier .)
    integer         reduce using rule 76 (name -> identifier .)
    none            reduce using rule 76 (name -> identifier .)
    $end            reduce using rule 76 (name -> identifier .)
    dedent          reduce using rule 76 (name -> identifier .)

  ! obracket        [ reduce using rule 76 (name -> identifier .) ]


state 31

    (12) statement -> expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 12 (statement -> expression .)
    print           reduce using rule 12 (statement -> expression .)
    identifier      reduce using rule 12 (statement -> expression .)
    lambda          reduce using rule 12 (statement -> expression .)
    invert          reduce using rule 12 (statement -> expression .)
    not             reduce using rule 12 (statement -> expression .)
    if              reduce using rule 12 (statement -> expression .)
    while           reduce using rule 12 (statement -> expression .)
    def             reduce using rule 12 (statement -> expression .)
    return          reduce using rule 12 (statement -> expression .)
    true            reduce using rule 12 (statement -> expression .)
    false           reduce using rule 12 (statement -> expression .)
    obracket        reduce using rule 12 (statement -> expression .)
    integer         reduce using rule 12 (statement -> expression .)
    none            reduce using rule 12 (statement -> expression .)
    $end            reduce using rule 12 (statement -> expression .)
    dedent          reduce using rule 12 (statement -> expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 12 (statement -> expression .) ]
  ! plus            [ reduce using rule 12 (statement -> expression .) ]
  ! oparen          [ reduce using rule 12 (statement -> expression .) ]


state 32

    (38) expression -> minus . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 85

state 33

    (20) compound_stmt -> def . identifier oparen id_list cparen colon suite

    identifier      shift and go to state 86


state 34

    (18) expression -> lambda . id_list colon expression
    (21) id_list -> .
    (22) id_list -> . identifier
    (23) id_list -> . identifier comma id_list

    colon           reduce using rule 21 (id_list -> .)
    identifier      shift and go to state 88

    id_list                        shift and go to state 87

state 35

    (44) expression -> name .
    (72) expression0 -> name .

  ! reduce/reduce conflict for oparen resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for plus resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for minus resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for times resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for div resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for power resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for modulo resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lshift resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for rshift resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for floordiv resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for and resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for or resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for xor resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for strand resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for stror resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lt resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for gt resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for gequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for isnotequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for isequal resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for newline resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for print resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for identifier resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for lambda resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for invert resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for not resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for if resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for while resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for def resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for return resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for true resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for false resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for obracket resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for integer resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for none resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for $end resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for dedent resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for colon resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for cparen resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for cbracket resolved using rule 44 (expression -> name .)
  ! reduce/reduce conflict for comma resolved using rule 44 (expression -> name .)
    oparen          reduce using rule 44 (expression -> name .)
    plus            reduce using rule 44 (expression -> name .)
    minus           reduce using rule 44 (expression -> name .)
    times           reduce using rule 44 (expression -> name .)
    div             reduce using rule 44 (expression -> name .)
    power           reduce using rule 44 (expression -> name .)
    modulo          reduce using rule 44 (expression -> name .)
    lshift          reduce using rule 44 (expression -> name .)
    rshift          reduce using rule 44 (expression -> name .)
    floordiv        reduce using rule 44 (expression -> name .)
    and             reduce using rule 44 (expression -> name .)
    or              reduce using rule 44 (expression -> name .)
    xor             reduce using rule 44 (expression -> name .)
    strand          reduce using rule 44 (expression -> name .)
    stror           reduce using rule 44 (expression -> name .)
    lt              reduce using rule 44 (expression -> name .)
    gt              reduce using rule 44 (expression -> name .)
    lequal          reduce using rule 44 (expression -> name .)
    gequal          reduce using rule 44 (expression -> name .)
    isnotequal      reduce using rule 44 (expression -> name .)
    isequal         reduce using rule 44 (expression -> name .)
    newline         reduce using rule 44 (expression -> name .)
    print           reduce using rule 44 (expression -> name .)
    identifier      reduce using rule 44 (expression -> name .)
    lambda          reduce using rule 44 (expression -> name .)
    invert          reduce using rule 44 (expression -> name .)
    not             reduce using rule 44 (expression -> name .)
    if              reduce using rule 44 (expression -> name .)
    while           reduce using rule 44 (expression -> name .)
    def             reduce using rule 44 (expression -> name .)
    return          reduce using rule 44 (expression -> name .)
    true            reduce using rule 44 (expression -> name .)
    false           reduce using rule 44 (expression -> name .)
    obracket        reduce using rule 44 (expression -> name .)
    integer         reduce using rule 44 (expression -> name .)
    none            reduce using rule 44 (expression -> name .)
    $end            reduce using rule 44 (expression -> name .)
    dedent          reduce using rule 44 (expression -> name .)
    colon           reduce using rule 44 (expression -> name .)
    cparen          reduce using rule 44 (expression -> name .)
    cbracket        reduce using rule 44 (expression -> name .)
    comma           reduce using rule 44 (expression -> name .)

  ! oparen          [ reduce using rule 72 (expression0 -> name .) ]
  ! plus            [ reduce using rule 72 (expression0 -> name .) ]
  ! minus           [ reduce using rule 72 (expression0 -> name .) ]
  ! times           [ reduce using rule 72 (expression0 -> name .) ]
  ! div             [ reduce using rule 72 (expression0 -> name .) ]
  ! power           [ reduce using rule 72 (expression0 -> name .) ]
  ! modulo          [ reduce using rule 72 (expression0 -> name .) ]
  ! lshift          [ reduce using rule 72 (expression0 -> name .) ]
  ! rshift          [ reduce using rule 72 (expression0 -> name .) ]
  ! floordiv        [ reduce using rule 72 (expression0 -> name .) ]
  ! and             [ reduce using rule 72 (expression0 -> name .) ]
  ! or              [ reduce using rule 72 (expression0 -> name .) ]
  ! xor             [ reduce using rule 72 (expression0 -> name .) ]
  ! strand          [ reduce using rule 72 (expression0 -> name .) ]
  ! stror           [ reduce using rule 72 (expression0 -> name .) ]
  ! lt              [ reduce using rule 72 (expression0 -> name .) ]
  ! gt              [ reduce using rule 72 (expression0 -> name .) ]
  ! lequal          [ reduce using rule 72 (expression0 -> name .) ]
  ! gequal          [ reduce using rule 72 (expression0 -> name .) ]
  ! isnotequal      [ reduce using rule 72 (expression0 -> name .) ]
  ! isequal         [ reduce using rule 72 (expression0 -> name .) ]
  ! newline         [ reduce using rule 72 (expression0 -> name .) ]
  ! print           [ reduce using rule 72 (expression0 -> name .) ]
  ! identifier      [ reduce using rule 72 (expression0 -> name .) ]
  ! lambda          [ reduce using rule 72 (expression0 -> name .) ]
  ! invert          [ reduce using rule 72 (expression0 -> name .) ]
  ! not             [ reduce using rule 72 (expression0 -> name .) ]
  ! if              [ reduce using rule 72 (expression0 -> name .) ]
  ! while           [ reduce using rule 72 (expression0 -> name .) ]
  ! def             [ reduce using rule 72 (expression0 -> name .) ]
  ! return          [ reduce using rule 72 (expression0 -> name .) ]
  ! true            [ reduce using rule 72 (expression0 -> name .) ]
  ! false           [ reduce using rule 72 (expression0 -> name .) ]
  ! obracket        [ reduce using rule 72 (expression0 -> name .) ]
  ! integer         [ reduce using rule 72 (expression0 -> name .) ]
  ! none            [ reduce using rule 72 (expression0 -> name .) ]
  ! $end            [ reduce using rule 72 (expression0 -> name .) ]
  ! dedent          [ reduce using rule 72 (expression0 -> name .) ]
  ! colon           [ reduce using rule 72 (expression0 -> name .) ]
  ! cparen          [ reduce using rule 72 (expression0 -> name .) ]
  ! cbracket        [ reduce using rule 72 (expression0 -> name .) ]
  ! comma           [ reduce using rule 72 (expression0 -> name .) ]


state 36

    (85) expression -> identifier . obracket integer cbracket
    (76) name -> identifier .

  ! shift/reduce conflict for obracket resolved as shift
    obracket        shift and go to state 63
    oparen          reduce using rule 76 (name -> identifier .)
    plus            reduce using rule 76 (name -> identifier .)
    minus           reduce using rule 76 (name -> identifier .)
    times           reduce using rule 76 (name -> identifier .)
    div             reduce using rule 76 (name -> identifier .)
    power           reduce using rule 76 (name -> identifier .)
    modulo          reduce using rule 76 (name -> identifier .)
    lshift          reduce using rule 76 (name -> identifier .)
    rshift          reduce using rule 76 (name -> identifier .)
    floordiv        reduce using rule 76 (name -> identifier .)
    and             reduce using rule 76 (name -> identifier .)
    or              reduce using rule 76 (name -> identifier .)
    xor             reduce using rule 76 (name -> identifier .)
    strand          reduce using rule 76 (name -> identifier .)
    stror           reduce using rule 76 (name -> identifier .)
    lt              reduce using rule 76 (name -> identifier .)
    gt              reduce using rule 76 (name -> identifier .)
    lequal          reduce using rule 76 (name -> identifier .)
    gequal          reduce using rule 76 (name -> identifier .)
    isnotequal      reduce using rule 76 (name -> identifier .)
    isequal         reduce using rule 76 (name -> identifier .)
    newline         reduce using rule 76 (name -> identifier .)
    print           reduce using rule 76 (name -> identifier .)
    identifier      reduce using rule 76 (name -> identifier .)
    lambda          reduce using rule 76 (name -> identifier .)
    invert          reduce using rule 76 (name -> identifier .)
    not             reduce using rule 76 (name -> identifier .)
    if              reduce using rule 76 (name -> identifier .)
    while           reduce using rule 76 (name -> identifier .)
    def             reduce using rule 76 (name -> identifier .)
    return          reduce using rule 76 (name -> identifier .)
    true            reduce using rule 76 (name -> identifier .)
    false           reduce using rule 76 (name -> identifier .)
    integer         reduce using rule 76 (name -> identifier .)
    none            reduce using rule 76 (name -> identifier .)
    $end            reduce using rule 76 (name -> identifier .)
    dedent          reduce using rule 76 (name -> identifier .)
    colon           reduce using rule 76 (name -> identifier .)
    cparen          reduce using rule 76 (name -> identifier .)
    cbracket        reduce using rule 76 (name -> identifier .)
    comma           reduce using rule 76 (name -> identifier .)

  ! obracket        [ reduce using rule 76 (name -> identifier .) ]


state 37

    (19) simple_statement -> return expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 19 (simple_statement -> return expression .)
    print           reduce using rule 19 (simple_statement -> return expression .)
    identifier      reduce using rule 19 (simple_statement -> return expression .)
    lambda          reduce using rule 19 (simple_statement -> return expression .)
    invert          reduce using rule 19 (simple_statement -> return expression .)
    not             reduce using rule 19 (simple_statement -> return expression .)
    if              reduce using rule 19 (simple_statement -> return expression .)
    while           reduce using rule 19 (simple_statement -> return expression .)
    def             reduce using rule 19 (simple_statement -> return expression .)
    return          reduce using rule 19 (simple_statement -> return expression .)
    true            reduce using rule 19 (simple_statement -> return expression .)
    false           reduce using rule 19 (simple_statement -> return expression .)
    obracket        reduce using rule 19 (simple_statement -> return expression .)
    integer         reduce using rule 19 (simple_statement -> return expression .)
    none            reduce using rule 19 (simple_statement -> return expression .)
    $end            reduce using rule 19 (simple_statement -> return expression .)
    dedent          reduce using rule 19 (simple_statement -> return expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 19 (simple_statement -> return expression .) ]
  ! plus            [ reduce using rule 19 (simple_statement -> return expression .) ]
  ! oparen          [ reduce using rule 19 (simple_statement -> return expression .) ]


state 38

    (65) ifstmt -> if expression . colon newline indent statement_list dedent
    (66) ifstmt -> if expression . colon newline indent statement_list dedent elsestmt
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    colon           shift and go to state 89
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 39

    (40) expression -> invert expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 40 (expression -> invert expression .)
    minus           reduce using rule 40 (expression -> invert expression .)
    times           reduce using rule 40 (expression -> invert expression .)
    div             reduce using rule 40 (expression -> invert expression .)
    modulo          reduce using rule 40 (expression -> invert expression .)
    lshift          reduce using rule 40 (expression -> invert expression .)
    rshift          reduce using rule 40 (expression -> invert expression .)
    floordiv        reduce using rule 40 (expression -> invert expression .)
    and             reduce using rule 40 (expression -> invert expression .)
    or              reduce using rule 40 (expression -> invert expression .)
    xor             reduce using rule 40 (expression -> invert expression .)
    strand          reduce using rule 40 (expression -> invert expression .)
    stror           reduce using rule 40 (expression -> invert expression .)
    lt              reduce using rule 40 (expression -> invert expression .)
    gt              reduce using rule 40 (expression -> invert expression .)
    lequal          reduce using rule 40 (expression -> invert expression .)
    gequal          reduce using rule 40 (expression -> invert expression .)
    isnotequal      reduce using rule 40 (expression -> invert expression .)
    isequal         reduce using rule 40 (expression -> invert expression .)
    newline         reduce using rule 40 (expression -> invert expression .)
    dedent          reduce using rule 40 (expression -> invert expression .)
    print           reduce using rule 40 (expression -> invert expression .)
    identifier      reduce using rule 40 (expression -> invert expression .)
    lambda          reduce using rule 40 (expression -> invert expression .)
    invert          reduce using rule 40 (expression -> invert expression .)
    not             reduce using rule 40 (expression -> invert expression .)
    if              reduce using rule 40 (expression -> invert expression .)
    while           reduce using rule 40 (expression -> invert expression .)
    def             reduce using rule 40 (expression -> invert expression .)
    return          reduce using rule 40 (expression -> invert expression .)
    true            reduce using rule 40 (expression -> invert expression .)
    false           reduce using rule 40 (expression -> invert expression .)
    obracket        reduce using rule 40 (expression -> invert expression .)
    integer         reduce using rule 40 (expression -> invert expression .)
    none            reduce using rule 40 (expression -> invert expression .)
    $end            reduce using rule 40 (expression -> invert expression .)
    colon           reduce using rule 40 (expression -> invert expression .)
    cparen          reduce using rule 40 (expression -> invert expression .)
    cbracket        reduce using rule 40 (expression -> invert expression .)
    comma           reduce using rule 40 (expression -> invert expression .)
    oparen          shift and go to state 74
    power           shift and go to state 76

  ! oparen          [ reduce using rule 40 (expression -> invert expression .) ]
  ! power           [ reduce using rule 40 (expression -> invert expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! times           [ shift and go to state 80 ]
  ! div             [ shift and go to state 83 ]
  ! modulo          [ shift and go to state 66 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! floordiv        [ shift and go to state 81 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 40

    (6) statement -> statement newline .

    newline         reduce using rule 6 (statement -> statement newline .)
    print           reduce using rule 6 (statement -> statement newline .)
    identifier      reduce using rule 6 (statement -> statement newline .)
    lambda          reduce using rule 6 (statement -> statement newline .)
    minus           reduce using rule 6 (statement -> statement newline .)
    plus            reduce using rule 6 (statement -> statement newline .)
    invert          reduce using rule 6 (statement -> statement newline .)
    oparen          reduce using rule 6 (statement -> statement newline .)
    not             reduce using rule 6 (statement -> statement newline .)
    if              reduce using rule 6 (statement -> statement newline .)
    while           reduce using rule 6 (statement -> statement newline .)
    def             reduce using rule 6 (statement -> statement newline .)
    return          reduce using rule 6 (statement -> statement newline .)
    true            reduce using rule 6 (statement -> statement newline .)
    false           reduce using rule 6 (statement -> statement newline .)
    obracket        reduce using rule 6 (statement -> statement newline .)
    integer         reduce using rule 6 (statement -> statement newline .)
    none            reduce using rule 6 (statement -> statement newline .)
    $end            reduce using rule 6 (statement -> statement newline .)
    dedent          reduce using rule 6 (statement -> statement newline .)


state 41

    (42) expression -> oparen expression . cparen
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    cparen          shift and go to state 90
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 42

    (7) statement -> print expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    newline         reduce using rule 7 (statement -> print expression .)
    print           reduce using rule 7 (statement -> print expression .)
    identifier      reduce using rule 7 (statement -> print expression .)
    lambda          reduce using rule 7 (statement -> print expression .)
    invert          reduce using rule 7 (statement -> print expression .)
    not             reduce using rule 7 (statement -> print expression .)
    if              reduce using rule 7 (statement -> print expression .)
    while           reduce using rule 7 (statement -> print expression .)
    def             reduce using rule 7 (statement -> print expression .)
    return          reduce using rule 7 (statement -> print expression .)
    true            reduce using rule 7 (statement -> print expression .)
    false           reduce using rule 7 (statement -> print expression .)
    obracket        reduce using rule 7 (statement -> print expression .)
    integer         reduce using rule 7 (statement -> print expression .)
    none            reduce using rule 7 (statement -> print expression .)
    $end            reduce using rule 7 (statement -> print expression .)
    dedent          reduce using rule 7 (statement -> print expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 7 (statement -> print expression .) ]
  ! plus            [ reduce using rule 7 (statement -> print expression .) ]
  ! oparen          [ reduce using rule 7 (statement -> print expression .) ]


state 43

    (5) statement -> newline statement .
    (6) statement -> statement . newline

  ! shift/reduce conflict for newline resolved as shift
    print           reduce using rule 5 (statement -> newline statement .)
    identifier      reduce using rule 5 (statement -> newline statement .)
    lambda          reduce using rule 5 (statement -> newline statement .)
    minus           reduce using rule 5 (statement -> newline statement .)
    plus            reduce using rule 5 (statement -> newline statement .)
    invert          reduce using rule 5 (statement -> newline statement .)
    oparen          reduce using rule 5 (statement -> newline statement .)
    not             reduce using rule 5 (statement -> newline statement .)
    if              reduce using rule 5 (statement -> newline statement .)
    while           reduce using rule 5 (statement -> newline statement .)
    def             reduce using rule 5 (statement -> newline statement .)
    return          reduce using rule 5 (statement -> newline statement .)
    true            reduce using rule 5 (statement -> newline statement .)
    false           reduce using rule 5 (statement -> newline statement .)
    obracket        reduce using rule 5 (statement -> newline statement .)
    integer         reduce using rule 5 (statement -> newline statement .)
    none            reduce using rule 5 (statement -> newline statement .)
    $end            reduce using rule 5 (statement -> newline statement .)
    dedent          reduce using rule 5 (statement -> newline statement .)
    newline         shift and go to state 40

  ! newline         [ reduce using rule 5 (statement -> newline statement .) ]


state 44

    (11) statement -> assname equals . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 91

state 45

    (43) expression -> not expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 43 (expression -> not expression .)
    stror           reduce using rule 43 (expression -> not expression .)
    lt              reduce using rule 43 (expression -> not expression .)
    gt              reduce using rule 43 (expression -> not expression .)
    lequal          reduce using rule 43 (expression -> not expression .)
    gequal          reduce using rule 43 (expression -> not expression .)
    isnotequal      reduce using rule 43 (expression -> not expression .)
    isequal         reduce using rule 43 (expression -> not expression .)
    newline         reduce using rule 43 (expression -> not expression .)
    dedent          reduce using rule 43 (expression -> not expression .)
    print           reduce using rule 43 (expression -> not expression .)
    identifier      reduce using rule 43 (expression -> not expression .)
    lambda          reduce using rule 43 (expression -> not expression .)
    invert          reduce using rule 43 (expression -> not expression .)
    not             reduce using rule 43 (expression -> not expression .)
    if              reduce using rule 43 (expression -> not expression .)
    while           reduce using rule 43 (expression -> not expression .)
    def             reduce using rule 43 (expression -> not expression .)
    return          reduce using rule 43 (expression -> not expression .)
    true            reduce using rule 43 (expression -> not expression .)
    false           reduce using rule 43 (expression -> not expression .)
    obracket        reduce using rule 43 (expression -> not expression .)
    integer         reduce using rule 43 (expression -> not expression .)
    none            reduce using rule 43 (expression -> not expression .)
    $end            reduce using rule 43 (expression -> not expression .)
    colon           reduce using rule 43 (expression -> not expression .)
    cparen          reduce using rule 43 (expression -> not expression .)
    cbracket        reduce using rule 43 (expression -> not expression .)
    comma           reduce using rule 43 (expression -> not expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 43 (expression -> not expression .) ]
  ! plus            [ reduce using rule 43 (expression -> not expression .) ]
  ! minus           [ reduce using rule 43 (expression -> not expression .) ]
  ! times           [ reduce using rule 43 (expression -> not expression .) ]
  ! div             [ reduce using rule 43 (expression -> not expression .) ]
  ! power           [ reduce using rule 43 (expression -> not expression .) ]
  ! modulo          [ reduce using rule 43 (expression -> not expression .) ]
  ! lshift          [ reduce using rule 43 (expression -> not expression .) ]
  ! rshift          [ reduce using rule 43 (expression -> not expression .) ]
  ! floordiv        [ reduce using rule 43 (expression -> not expression .) ]
  ! and             [ reduce using rule 43 (expression -> not expression .) ]
  ! or              [ reduce using rule 43 (expression -> not expression .) ]
  ! xor             [ reduce using rule 43 (expression -> not expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 46

    (36) statement -> name floorassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 92

state 47

    (33) statement -> name orassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 93

state 48

    (30) statement -> name lshiftassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 94

state 49

    (31) statement -> name rshiftassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 95

state 50

    (35) statement -> name powerassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 96

state 51

    (25) statement -> name incassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 97

state 52

    (27) statement -> name divassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 98

state 53

    (28) statement -> name mulassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 99

state 54

    (29) statement -> name modassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 100

state 55

    (32) statement -> name andassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 101

state 56

    (26) statement -> name decassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 102

state 57

    (34) statement -> name xorassign . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 103

state 58

    (84) list -> obracket list_obj . cbracket
    (82) list_obj -> list_obj . comma expression

    cbracket        shift and go to state 105
    comma           shift and go to state 104


state 59

    (81) list_obj -> expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    cbracket        reduce using rule 81 (list_obj -> expression .)
    comma           reduce using rule 81 (list_obj -> expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 60

    (70) whilestmt -> while expression . colon newline indent statement_list dedent
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    colon           shift and go to state 106
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 61

    (39) expression -> plus expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 39 (expression -> plus expression .)
    minus           reduce using rule 39 (expression -> plus expression .)
    lshift          reduce using rule 39 (expression -> plus expression .)
    rshift          reduce using rule 39 (expression -> plus expression .)
    and             reduce using rule 39 (expression -> plus expression .)
    or              reduce using rule 39 (expression -> plus expression .)
    xor             reduce using rule 39 (expression -> plus expression .)
    strand          reduce using rule 39 (expression -> plus expression .)
    stror           reduce using rule 39 (expression -> plus expression .)
    lt              reduce using rule 39 (expression -> plus expression .)
    gt              reduce using rule 39 (expression -> plus expression .)
    lequal          reduce using rule 39 (expression -> plus expression .)
    gequal          reduce using rule 39 (expression -> plus expression .)
    isnotequal      reduce using rule 39 (expression -> plus expression .)
    isequal         reduce using rule 39 (expression -> plus expression .)
    newline         reduce using rule 39 (expression -> plus expression .)
    dedent          reduce using rule 39 (expression -> plus expression .)
    print           reduce using rule 39 (expression -> plus expression .)
    identifier      reduce using rule 39 (expression -> plus expression .)
    lambda          reduce using rule 39 (expression -> plus expression .)
    invert          reduce using rule 39 (expression -> plus expression .)
    not             reduce using rule 39 (expression -> plus expression .)
    if              reduce using rule 39 (expression -> plus expression .)
    while           reduce using rule 39 (expression -> plus expression .)
    def             reduce using rule 39 (expression -> plus expression .)
    return          reduce using rule 39 (expression -> plus expression .)
    true            reduce using rule 39 (expression -> plus expression .)
    false           reduce using rule 39 (expression -> plus expression .)
    obracket        reduce using rule 39 (expression -> plus expression .)
    integer         reduce using rule 39 (expression -> plus expression .)
    none            reduce using rule 39 (expression -> plus expression .)
    $end            reduce using rule 39 (expression -> plus expression .)
    colon           reduce using rule 39 (expression -> plus expression .)
    cparen          reduce using rule 39 (expression -> plus expression .)
    cbracket        reduce using rule 39 (expression -> plus expression .)
    comma           reduce using rule 39 (expression -> plus expression .)
    oparen          shift and go to state 74
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 39 (expression -> plus expression .) ]
  ! times           [ reduce using rule 39 (expression -> plus expression .) ]
  ! div             [ reduce using rule 39 (expression -> plus expression .) ]
  ! power           [ reduce using rule 39 (expression -> plus expression .) ]
  ! modulo          [ reduce using rule 39 (expression -> plus expression .) ]
  ! floordiv        [ reduce using rule 39 (expression -> plus expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 62

    (4) statement_list -> statement_list statement .
    (6) statement -> statement . newline

  ! shift/reduce conflict for newline resolved as shift
    dedent          reduce using rule 4 (statement_list -> statement_list statement .)
    print           reduce using rule 4 (statement_list -> statement_list statement .)
    identifier      reduce using rule 4 (statement_list -> statement_list statement .)
    lambda          reduce using rule 4 (statement_list -> statement_list statement .)
    minus           reduce using rule 4 (statement_list -> statement_list statement .)
    plus            reduce using rule 4 (statement_list -> statement_list statement .)
    invert          reduce using rule 4 (statement_list -> statement_list statement .)
    oparen          reduce using rule 4 (statement_list -> statement_list statement .)
    not             reduce using rule 4 (statement_list -> statement_list statement .)
    if              reduce using rule 4 (statement_list -> statement_list statement .)
    while           reduce using rule 4 (statement_list -> statement_list statement .)
    def             reduce using rule 4 (statement_list -> statement_list statement .)
    return          reduce using rule 4 (statement_list -> statement_list statement .)
    true            reduce using rule 4 (statement_list -> statement_list statement .)
    false           reduce using rule 4 (statement_list -> statement_list statement .)
    obracket        reduce using rule 4 (statement_list -> statement_list statement .)
    integer         reduce using rule 4 (statement_list -> statement_list statement .)
    none            reduce using rule 4 (statement_list -> statement_list statement .)
    $end            reduce using rule 4 (statement_list -> statement_list statement .)
    newline         shift and go to state 40

  ! newline         [ reduce using rule 4 (statement_list -> statement_list statement .) ]


state 63

    (85) expression -> identifier obracket . integer cbracket

    integer         shift and go to state 107


state 64

    (54) expression -> expression and . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 108

state 65

    (60) expression -> expression gt . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 109

state 66

    (50) expression -> expression modulo . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 110

state 67

    (61) expression -> expression lequal . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 111

state 68

    (51) expression -> expression lshift . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 112

state 69

    (64) expression -> expression isequal . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 113

state 70

    (62) expression -> expression gequal . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 114

state 71

    (56) expression -> expression xor . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 115

state 72

    (58) expression -> expression stror . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 116

state 73

    (59) expression -> expression lt . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 117

state 74

    (17) expression -> expression oparen . parameters cparen
    (8) parameters -> . expression
    (9) parameters -> . parameters comma expression
    (10) parameters -> .
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    cparen          reduce using rule 10 (parameters -> .)
    comma           reduce using rule 10 (parameters -> .)
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    parameters                     shift and go to state 118
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 119

state 75

    (52) expression -> expression rshift . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 120

state 76

    (49) expression -> expression power . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 121

state 77

    (46) expression -> expression minus . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 122

state 78

    (57) expression -> expression strand . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 123

state 79

    (63) expression -> expression isnotequal . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 124

state 80

    (47) expression -> expression times . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 125

state 81

    (53) expression -> expression floordiv . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 126

state 82

    (45) expression -> expression plus . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 127

state 83

    (48) expression -> expression div . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 128

state 84

    (55) expression -> expression or . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 129

state 85

    (38) expression -> minus expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 38 (expression -> minus expression .)
    minus           reduce using rule 38 (expression -> minus expression .)
    lshift          reduce using rule 38 (expression -> minus expression .)
    rshift          reduce using rule 38 (expression -> minus expression .)
    and             reduce using rule 38 (expression -> minus expression .)
    or              reduce using rule 38 (expression -> minus expression .)
    xor             reduce using rule 38 (expression -> minus expression .)
    strand          reduce using rule 38 (expression -> minus expression .)
    stror           reduce using rule 38 (expression -> minus expression .)
    lt              reduce using rule 38 (expression -> minus expression .)
    gt              reduce using rule 38 (expression -> minus expression .)
    lequal          reduce using rule 38 (expression -> minus expression .)
    gequal          reduce using rule 38 (expression -> minus expression .)
    isnotequal      reduce using rule 38 (expression -> minus expression .)
    isequal         reduce using rule 38 (expression -> minus expression .)
    newline         reduce using rule 38 (expression -> minus expression .)
    dedent          reduce using rule 38 (expression -> minus expression .)
    print           reduce using rule 38 (expression -> minus expression .)
    identifier      reduce using rule 38 (expression -> minus expression .)
    lambda          reduce using rule 38 (expression -> minus expression .)
    invert          reduce using rule 38 (expression -> minus expression .)
    not             reduce using rule 38 (expression -> minus expression .)
    if              reduce using rule 38 (expression -> minus expression .)
    while           reduce using rule 38 (expression -> minus expression .)
    def             reduce using rule 38 (expression -> minus expression .)
    return          reduce using rule 38 (expression -> minus expression .)
    true            reduce using rule 38 (expression -> minus expression .)
    false           reduce using rule 38 (expression -> minus expression .)
    obracket        reduce using rule 38 (expression -> minus expression .)
    integer         reduce using rule 38 (expression -> minus expression .)
    none            reduce using rule 38 (expression -> minus expression .)
    $end            reduce using rule 38 (expression -> minus expression .)
    colon           reduce using rule 38 (expression -> minus expression .)
    cparen          reduce using rule 38 (expression -> minus expression .)
    cbracket        reduce using rule 38 (expression -> minus expression .)
    comma           reduce using rule 38 (expression -> minus expression .)
    oparen          shift and go to state 74
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 38 (expression -> minus expression .) ]
  ! times           [ reduce using rule 38 (expression -> minus expression .) ]
  ! div             [ reduce using rule 38 (expression -> minus expression .) ]
  ! power           [ reduce using rule 38 (expression -> minus expression .) ]
  ! modulo          [ reduce using rule 38 (expression -> minus expression .) ]
  ! floordiv        [ reduce using rule 38 (expression -> minus expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 86

    (20) compound_stmt -> def identifier . oparen id_list cparen colon suite

    oparen          shift and go to state 130


state 87

    (18) expression -> lambda id_list . colon expression

    colon           shift and go to state 131


state 88

    (22) id_list -> identifier .
    (23) id_list -> identifier . comma id_list

    colon           reduce using rule 22 (id_list -> identifier .)
    cparen          reduce using rule 22 (id_list -> identifier .)
    comma           shift and go to state 132


state 89

    (65) ifstmt -> if expression colon . newline indent statement_list dedent
    (66) ifstmt -> if expression colon . newline indent statement_list dedent elsestmt

    newline         shift and go to state 133


state 90

    (42) expression -> oparen expression cparen .

    oparen          reduce using rule 42 (expression -> oparen expression cparen .)
    plus            reduce using rule 42 (expression -> oparen expression cparen .)
    minus           reduce using rule 42 (expression -> oparen expression cparen .)
    times           reduce using rule 42 (expression -> oparen expression cparen .)
    div             reduce using rule 42 (expression -> oparen expression cparen .)
    power           reduce using rule 42 (expression -> oparen expression cparen .)
    modulo          reduce using rule 42 (expression -> oparen expression cparen .)
    lshift          reduce using rule 42 (expression -> oparen expression cparen .)
    rshift          reduce using rule 42 (expression -> oparen expression cparen .)
    floordiv        reduce using rule 42 (expression -> oparen expression cparen .)
    and             reduce using rule 42 (expression -> oparen expression cparen .)
    or              reduce using rule 42 (expression -> oparen expression cparen .)
    xor             reduce using rule 42 (expression -> oparen expression cparen .)
    strand          reduce using rule 42 (expression -> oparen expression cparen .)
    stror           reduce using rule 42 (expression -> oparen expression cparen .)
    lt              reduce using rule 42 (expression -> oparen expression cparen .)
    gt              reduce using rule 42 (expression -> oparen expression cparen .)
    lequal          reduce using rule 42 (expression -> oparen expression cparen .)
    gequal          reduce using rule 42 (expression -> oparen expression cparen .)
    isnotequal      reduce using rule 42 (expression -> oparen expression cparen .)
    isequal         reduce using rule 42 (expression -> oparen expression cparen .)
    newline         reduce using rule 42 (expression -> oparen expression cparen .)
    dedent          reduce using rule 42 (expression -> oparen expression cparen .)
    print           reduce using rule 42 (expression -> oparen expression cparen .)
    identifier      reduce using rule 42 (expression -> oparen expression cparen .)
    lambda          reduce using rule 42 (expression -> oparen expression cparen .)
    invert          reduce using rule 42 (expression -> oparen expression cparen .)
    not             reduce using rule 42 (expression -> oparen expression cparen .)
    if              reduce using rule 42 (expression -> oparen expression cparen .)
    while           reduce using rule 42 (expression -> oparen expression cparen .)
    def             reduce using rule 42 (expression -> oparen expression cparen .)
    return          reduce using rule 42 (expression -> oparen expression cparen .)
    true            reduce using rule 42 (expression -> oparen expression cparen .)
    false           reduce using rule 42 (expression -> oparen expression cparen .)
    obracket        reduce using rule 42 (expression -> oparen expression cparen .)
    integer         reduce using rule 42 (expression -> oparen expression cparen .)
    none            reduce using rule 42 (expression -> oparen expression cparen .)
    $end            reduce using rule 42 (expression -> oparen expression cparen .)
    colon           reduce using rule 42 (expression -> oparen expression cparen .)
    cparen          reduce using rule 42 (expression -> oparen expression cparen .)
    cbracket        reduce using rule 42 (expression -> oparen expression cparen .)
    comma           reduce using rule 42 (expression -> oparen expression cparen .)


state 91

    (11) statement -> assname equals expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 11 (statement -> assname equals expression .)
    print           reduce using rule 11 (statement -> assname equals expression .)
    identifier      reduce using rule 11 (statement -> assname equals expression .)
    lambda          reduce using rule 11 (statement -> assname equals expression .)
    invert          reduce using rule 11 (statement -> assname equals expression .)
    not             reduce using rule 11 (statement -> assname equals expression .)
    if              reduce using rule 11 (statement -> assname equals expression .)
    while           reduce using rule 11 (statement -> assname equals expression .)
    def             reduce using rule 11 (statement -> assname equals expression .)
    return          reduce using rule 11 (statement -> assname equals expression .)
    true            reduce using rule 11 (statement -> assname equals expression .)
    false           reduce using rule 11 (statement -> assname equals expression .)
    obracket        reduce using rule 11 (statement -> assname equals expression .)
    integer         reduce using rule 11 (statement -> assname equals expression .)
    none            reduce using rule 11 (statement -> assname equals expression .)
    $end            reduce using rule 11 (statement -> assname equals expression .)
    dedent          reduce using rule 11 (statement -> assname equals expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 11 (statement -> assname equals expression .) ]
  ! plus            [ reduce using rule 11 (statement -> assname equals expression .) ]
  ! oparen          [ reduce using rule 11 (statement -> assname equals expression .) ]


state 92

    (36) statement -> name floorassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 36 (statement -> name floorassign expression .)
    print           reduce using rule 36 (statement -> name floorassign expression .)
    identifier      reduce using rule 36 (statement -> name floorassign expression .)
    lambda          reduce using rule 36 (statement -> name floorassign expression .)
    invert          reduce using rule 36 (statement -> name floorassign expression .)
    not             reduce using rule 36 (statement -> name floorassign expression .)
    if              reduce using rule 36 (statement -> name floorassign expression .)
    while           reduce using rule 36 (statement -> name floorassign expression .)
    def             reduce using rule 36 (statement -> name floorassign expression .)
    return          reduce using rule 36 (statement -> name floorassign expression .)
    true            reduce using rule 36 (statement -> name floorassign expression .)
    false           reduce using rule 36 (statement -> name floorassign expression .)
    obracket        reduce using rule 36 (statement -> name floorassign expression .)
    integer         reduce using rule 36 (statement -> name floorassign expression .)
    none            reduce using rule 36 (statement -> name floorassign expression .)
    $end            reduce using rule 36 (statement -> name floorassign expression .)
    dedent          reduce using rule 36 (statement -> name floorassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 36 (statement -> name floorassign expression .) ]
  ! plus            [ reduce using rule 36 (statement -> name floorassign expression .) ]
  ! oparen          [ reduce using rule 36 (statement -> name floorassign expression .) ]


state 93

    (33) statement -> name orassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 33 (statement -> name orassign expression .)
    print           reduce using rule 33 (statement -> name orassign expression .)
    identifier      reduce using rule 33 (statement -> name orassign expression .)
    lambda          reduce using rule 33 (statement -> name orassign expression .)
    invert          reduce using rule 33 (statement -> name orassign expression .)
    not             reduce using rule 33 (statement -> name orassign expression .)
    if              reduce using rule 33 (statement -> name orassign expression .)
    while           reduce using rule 33 (statement -> name orassign expression .)
    def             reduce using rule 33 (statement -> name orassign expression .)
    return          reduce using rule 33 (statement -> name orassign expression .)
    true            reduce using rule 33 (statement -> name orassign expression .)
    false           reduce using rule 33 (statement -> name orassign expression .)
    obracket        reduce using rule 33 (statement -> name orassign expression .)
    integer         reduce using rule 33 (statement -> name orassign expression .)
    none            reduce using rule 33 (statement -> name orassign expression .)
    $end            reduce using rule 33 (statement -> name orassign expression .)
    dedent          reduce using rule 33 (statement -> name orassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 33 (statement -> name orassign expression .) ]
  ! plus            [ reduce using rule 33 (statement -> name orassign expression .) ]
  ! oparen          [ reduce using rule 33 (statement -> name orassign expression .) ]


state 94

    (30) statement -> name lshiftassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 30 (statement -> name lshiftassign expression .)
    print           reduce using rule 30 (statement -> name lshiftassign expression .)
    identifier      reduce using rule 30 (statement -> name lshiftassign expression .)
    lambda          reduce using rule 30 (statement -> name lshiftassign expression .)
    invert          reduce using rule 30 (statement -> name lshiftassign expression .)
    not             reduce using rule 30 (statement -> name lshiftassign expression .)
    if              reduce using rule 30 (statement -> name lshiftassign expression .)
    while           reduce using rule 30 (statement -> name lshiftassign expression .)
    def             reduce using rule 30 (statement -> name lshiftassign expression .)
    return          reduce using rule 30 (statement -> name lshiftassign expression .)
    true            reduce using rule 30 (statement -> name lshiftassign expression .)
    false           reduce using rule 30 (statement -> name lshiftassign expression .)
    obracket        reduce using rule 30 (statement -> name lshiftassign expression .)
    integer         reduce using rule 30 (statement -> name lshiftassign expression .)
    none            reduce using rule 30 (statement -> name lshiftassign expression .)
    $end            reduce using rule 30 (statement -> name lshiftassign expression .)
    dedent          reduce using rule 30 (statement -> name lshiftassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 30 (statement -> name lshiftassign expression .) ]
  ! plus            [ reduce using rule 30 (statement -> name lshiftassign expression .) ]
  ! oparen          [ reduce using rule 30 (statement -> name lshiftassign expression .) ]


state 95

    (31) statement -> name rshiftassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 31 (statement -> name rshiftassign expression .)
    print           reduce using rule 31 (statement -> name rshiftassign expression .)
    identifier      reduce using rule 31 (statement -> name rshiftassign expression .)
    lambda          reduce using rule 31 (statement -> name rshiftassign expression .)
    invert          reduce using rule 31 (statement -> name rshiftassign expression .)
    not             reduce using rule 31 (statement -> name rshiftassign expression .)
    if              reduce using rule 31 (statement -> name rshiftassign expression .)
    while           reduce using rule 31 (statement -> name rshiftassign expression .)
    def             reduce using rule 31 (statement -> name rshiftassign expression .)
    return          reduce using rule 31 (statement -> name rshiftassign expression .)
    true            reduce using rule 31 (statement -> name rshiftassign expression .)
    false           reduce using rule 31 (statement -> name rshiftassign expression .)
    obracket        reduce using rule 31 (statement -> name rshiftassign expression .)
    integer         reduce using rule 31 (statement -> name rshiftassign expression .)
    none            reduce using rule 31 (statement -> name rshiftassign expression .)
    $end            reduce using rule 31 (statement -> name rshiftassign expression .)
    dedent          reduce using rule 31 (statement -> name rshiftassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 31 (statement -> name rshiftassign expression .) ]
  ! plus            [ reduce using rule 31 (statement -> name rshiftassign expression .) ]
  ! oparen          [ reduce using rule 31 (statement -> name rshiftassign expression .) ]


state 96

    (35) statement -> name powerassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 35 (statement -> name powerassign expression .)
    print           reduce using rule 35 (statement -> name powerassign expression .)
    identifier      reduce using rule 35 (statement -> name powerassign expression .)
    lambda          reduce using rule 35 (statement -> name powerassign expression .)
    invert          reduce using rule 35 (statement -> name powerassign expression .)
    not             reduce using rule 35 (statement -> name powerassign expression .)
    if              reduce using rule 35 (statement -> name powerassign expression .)
    while           reduce using rule 35 (statement -> name powerassign expression .)
    def             reduce using rule 35 (statement -> name powerassign expression .)
    return          reduce using rule 35 (statement -> name powerassign expression .)
    true            reduce using rule 35 (statement -> name powerassign expression .)
    false           reduce using rule 35 (statement -> name powerassign expression .)
    obracket        reduce using rule 35 (statement -> name powerassign expression .)
    integer         reduce using rule 35 (statement -> name powerassign expression .)
    none            reduce using rule 35 (statement -> name powerassign expression .)
    $end            reduce using rule 35 (statement -> name powerassign expression .)
    dedent          reduce using rule 35 (statement -> name powerassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 35 (statement -> name powerassign expression .) ]
  ! plus            [ reduce using rule 35 (statement -> name powerassign expression .) ]
  ! oparen          [ reduce using rule 35 (statement -> name powerassign expression .) ]


state 97

    (25) statement -> name incassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 25 (statement -> name incassign expression .)
    print           reduce using rule 25 (statement -> name incassign expression .)
    identifier      reduce using rule 25 (statement -> name incassign expression .)
    lambda          reduce using rule 25 (statement -> name incassign expression .)
    invert          reduce using rule 25 (statement -> name incassign expression .)
    not             reduce using rule 25 (statement -> name incassign expression .)
    if              reduce using rule 25 (statement -> name incassign expression .)
    while           reduce using rule 25 (statement -> name incassign expression .)
    def             reduce using rule 25 (statement -> name incassign expression .)
    return          reduce using rule 25 (statement -> name incassign expression .)
    true            reduce using rule 25 (statement -> name incassign expression .)
    false           reduce using rule 25 (statement -> name incassign expression .)
    obracket        reduce using rule 25 (statement -> name incassign expression .)
    integer         reduce using rule 25 (statement -> name incassign expression .)
    none            reduce using rule 25 (statement -> name incassign expression .)
    $end            reduce using rule 25 (statement -> name incassign expression .)
    dedent          reduce using rule 25 (statement -> name incassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 25 (statement -> name incassign expression .) ]
  ! plus            [ reduce using rule 25 (statement -> name incassign expression .) ]
  ! oparen          [ reduce using rule 25 (statement -> name incassign expression .) ]


state 98

    (27) statement -> name divassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 27 (statement -> name divassign expression .)
    print           reduce using rule 27 (statement -> name divassign expression .)
    identifier      reduce using rule 27 (statement -> name divassign expression .)
    lambda          reduce using rule 27 (statement -> name divassign expression .)
    invert          reduce using rule 27 (statement -> name divassign expression .)
    not             reduce using rule 27 (statement -> name divassign expression .)
    if              reduce using rule 27 (statement -> name divassign expression .)
    while           reduce using rule 27 (statement -> name divassign expression .)
    def             reduce using rule 27 (statement -> name divassign expression .)
    return          reduce using rule 27 (statement -> name divassign expression .)
    true            reduce using rule 27 (statement -> name divassign expression .)
    false           reduce using rule 27 (statement -> name divassign expression .)
    obracket        reduce using rule 27 (statement -> name divassign expression .)
    integer         reduce using rule 27 (statement -> name divassign expression .)
    none            reduce using rule 27 (statement -> name divassign expression .)
    $end            reduce using rule 27 (statement -> name divassign expression .)
    dedent          reduce using rule 27 (statement -> name divassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 27 (statement -> name divassign expression .) ]
  ! plus            [ reduce using rule 27 (statement -> name divassign expression .) ]
  ! oparen          [ reduce using rule 27 (statement -> name divassign expression .) ]


state 99

    (28) statement -> name mulassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 28 (statement -> name mulassign expression .)
    print           reduce using rule 28 (statement -> name mulassign expression .)
    identifier      reduce using rule 28 (statement -> name mulassign expression .)
    lambda          reduce using rule 28 (statement -> name mulassign expression .)
    invert          reduce using rule 28 (statement -> name mulassign expression .)
    not             reduce using rule 28 (statement -> name mulassign expression .)
    if              reduce using rule 28 (statement -> name mulassign expression .)
    while           reduce using rule 28 (statement -> name mulassign expression .)
    def             reduce using rule 28 (statement -> name mulassign expression .)
    return          reduce using rule 28 (statement -> name mulassign expression .)
    true            reduce using rule 28 (statement -> name mulassign expression .)
    false           reduce using rule 28 (statement -> name mulassign expression .)
    obracket        reduce using rule 28 (statement -> name mulassign expression .)
    integer         reduce using rule 28 (statement -> name mulassign expression .)
    none            reduce using rule 28 (statement -> name mulassign expression .)
    $end            reduce using rule 28 (statement -> name mulassign expression .)
    dedent          reduce using rule 28 (statement -> name mulassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 28 (statement -> name mulassign expression .) ]
  ! plus            [ reduce using rule 28 (statement -> name mulassign expression .) ]
  ! oparen          [ reduce using rule 28 (statement -> name mulassign expression .) ]


state 100

    (29) statement -> name modassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 29 (statement -> name modassign expression .)
    print           reduce using rule 29 (statement -> name modassign expression .)
    identifier      reduce using rule 29 (statement -> name modassign expression .)
    lambda          reduce using rule 29 (statement -> name modassign expression .)
    invert          reduce using rule 29 (statement -> name modassign expression .)
    not             reduce using rule 29 (statement -> name modassign expression .)
    if              reduce using rule 29 (statement -> name modassign expression .)
    while           reduce using rule 29 (statement -> name modassign expression .)
    def             reduce using rule 29 (statement -> name modassign expression .)
    return          reduce using rule 29 (statement -> name modassign expression .)
    true            reduce using rule 29 (statement -> name modassign expression .)
    false           reduce using rule 29 (statement -> name modassign expression .)
    obracket        reduce using rule 29 (statement -> name modassign expression .)
    integer         reduce using rule 29 (statement -> name modassign expression .)
    none            reduce using rule 29 (statement -> name modassign expression .)
    $end            reduce using rule 29 (statement -> name modassign expression .)
    dedent          reduce using rule 29 (statement -> name modassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 29 (statement -> name modassign expression .) ]
  ! plus            [ reduce using rule 29 (statement -> name modassign expression .) ]
  ! oparen          [ reduce using rule 29 (statement -> name modassign expression .) ]


state 101

    (32) statement -> name andassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 32 (statement -> name andassign expression .)
    print           reduce using rule 32 (statement -> name andassign expression .)
    identifier      reduce using rule 32 (statement -> name andassign expression .)
    lambda          reduce using rule 32 (statement -> name andassign expression .)
    invert          reduce using rule 32 (statement -> name andassign expression .)
    not             reduce using rule 32 (statement -> name andassign expression .)
    if              reduce using rule 32 (statement -> name andassign expression .)
    while           reduce using rule 32 (statement -> name andassign expression .)
    def             reduce using rule 32 (statement -> name andassign expression .)
    return          reduce using rule 32 (statement -> name andassign expression .)
    true            reduce using rule 32 (statement -> name andassign expression .)
    false           reduce using rule 32 (statement -> name andassign expression .)
    obracket        reduce using rule 32 (statement -> name andassign expression .)
    integer         reduce using rule 32 (statement -> name andassign expression .)
    none            reduce using rule 32 (statement -> name andassign expression .)
    $end            reduce using rule 32 (statement -> name andassign expression .)
    dedent          reduce using rule 32 (statement -> name andassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 32 (statement -> name andassign expression .) ]
  ! plus            [ reduce using rule 32 (statement -> name andassign expression .) ]
  ! oparen          [ reduce using rule 32 (statement -> name andassign expression .) ]


state 102

    (26) statement -> name decassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 26 (statement -> name decassign expression .)
    print           reduce using rule 26 (statement -> name decassign expression .)
    identifier      reduce using rule 26 (statement -> name decassign expression .)
    lambda          reduce using rule 26 (statement -> name decassign expression .)
    invert          reduce using rule 26 (statement -> name decassign expression .)
    not             reduce using rule 26 (statement -> name decassign expression .)
    if              reduce using rule 26 (statement -> name decassign expression .)
    while           reduce using rule 26 (statement -> name decassign expression .)
    def             reduce using rule 26 (statement -> name decassign expression .)
    return          reduce using rule 26 (statement -> name decassign expression .)
    true            reduce using rule 26 (statement -> name decassign expression .)
    false           reduce using rule 26 (statement -> name decassign expression .)
    obracket        reduce using rule 26 (statement -> name decassign expression .)
    integer         reduce using rule 26 (statement -> name decassign expression .)
    none            reduce using rule 26 (statement -> name decassign expression .)
    $end            reduce using rule 26 (statement -> name decassign expression .)
    dedent          reduce using rule 26 (statement -> name decassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 26 (statement -> name decassign expression .) ]
  ! plus            [ reduce using rule 26 (statement -> name decassign expression .) ]
  ! oparen          [ reduce using rule 26 (statement -> name decassign expression .) ]


state 103

    (34) statement -> name xorassign expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 34 (statement -> name xorassign expression .)
    print           reduce using rule 34 (statement -> name xorassign expression .)
    identifier      reduce using rule 34 (statement -> name xorassign expression .)
    lambda          reduce using rule 34 (statement -> name xorassign expression .)
    invert          reduce using rule 34 (statement -> name xorassign expression .)
    not             reduce using rule 34 (statement -> name xorassign expression .)
    if              reduce using rule 34 (statement -> name xorassign expression .)
    while           reduce using rule 34 (statement -> name xorassign expression .)
    def             reduce using rule 34 (statement -> name xorassign expression .)
    return          reduce using rule 34 (statement -> name xorassign expression .)
    true            reduce using rule 34 (statement -> name xorassign expression .)
    false           reduce using rule 34 (statement -> name xorassign expression .)
    obracket        reduce using rule 34 (statement -> name xorassign expression .)
    integer         reduce using rule 34 (statement -> name xorassign expression .)
    none            reduce using rule 34 (statement -> name xorassign expression .)
    $end            reduce using rule 34 (statement -> name xorassign expression .)
    dedent          reduce using rule 34 (statement -> name xorassign expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! minus           [ reduce using rule 34 (statement -> name xorassign expression .) ]
  ! plus            [ reduce using rule 34 (statement -> name xorassign expression .) ]
  ! oparen          [ reduce using rule 34 (statement -> name xorassign expression .) ]


state 104

    (82) list_obj -> list_obj comma . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 134
    name                           shift and go to state 35

state 105

    (84) list -> obracket list_obj cbracket .

    cparen          reduce using rule 84 (list -> obracket list_obj cbracket .)
    oparen          reduce using rule 84 (list -> obracket list_obj cbracket .)
    plus            reduce using rule 84 (list -> obracket list_obj cbracket .)
    minus           reduce using rule 84 (list -> obracket list_obj cbracket .)
    times           reduce using rule 84 (list -> obracket list_obj cbracket .)
    div             reduce using rule 84 (list -> obracket list_obj cbracket .)
    power           reduce using rule 84 (list -> obracket list_obj cbracket .)
    modulo          reduce using rule 84 (list -> obracket list_obj cbracket .)
    lshift          reduce using rule 84 (list -> obracket list_obj cbracket .)
    rshift          reduce using rule 84 (list -> obracket list_obj cbracket .)
    floordiv        reduce using rule 84 (list -> obracket list_obj cbracket .)
    and             reduce using rule 84 (list -> obracket list_obj cbracket .)
    or              reduce using rule 84 (list -> obracket list_obj cbracket .)
    xor             reduce using rule 84 (list -> obracket list_obj cbracket .)
    strand          reduce using rule 84 (list -> obracket list_obj cbracket .)
    stror           reduce using rule 84 (list -> obracket list_obj cbracket .)
    lt              reduce using rule 84 (list -> obracket list_obj cbracket .)
    gt              reduce using rule 84 (list -> obracket list_obj cbracket .)
    lequal          reduce using rule 84 (list -> obracket list_obj cbracket .)
    gequal          reduce using rule 84 (list -> obracket list_obj cbracket .)
    isnotequal      reduce using rule 84 (list -> obracket list_obj cbracket .)
    isequal         reduce using rule 84 (list -> obracket list_obj cbracket .)
    newline         reduce using rule 84 (list -> obracket list_obj cbracket .)
    print           reduce using rule 84 (list -> obracket list_obj cbracket .)
    identifier      reduce using rule 84 (list -> obracket list_obj cbracket .)
    lambda          reduce using rule 84 (list -> obracket list_obj cbracket .)
    invert          reduce using rule 84 (list -> obracket list_obj cbracket .)
    not             reduce using rule 84 (list -> obracket list_obj cbracket .)
    if              reduce using rule 84 (list -> obracket list_obj cbracket .)
    while           reduce using rule 84 (list -> obracket list_obj cbracket .)
    def             reduce using rule 84 (list -> obracket list_obj cbracket .)
    return          reduce using rule 84 (list -> obracket list_obj cbracket .)
    true            reduce using rule 84 (list -> obracket list_obj cbracket .)
    false           reduce using rule 84 (list -> obracket list_obj cbracket .)
    obracket        reduce using rule 84 (list -> obracket list_obj cbracket .)
    integer         reduce using rule 84 (list -> obracket list_obj cbracket .)
    none            reduce using rule 84 (list -> obracket list_obj cbracket .)
    $end            reduce using rule 84 (list -> obracket list_obj cbracket .)
    dedent          reduce using rule 84 (list -> obracket list_obj cbracket .)
    colon           reduce using rule 84 (list -> obracket list_obj cbracket .)
    cbracket        reduce using rule 84 (list -> obracket list_obj cbracket .)
    comma           reduce using rule 84 (list -> obracket list_obj cbracket .)


state 106

    (70) whilestmt -> while expression colon . newline indent statement_list dedent

    newline         shift and go to state 135


state 107

    (85) expression -> identifier obracket integer . cbracket

    cbracket        shift and go to state 136


state 108

    (54) expression -> expression and expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    and             reduce using rule 54 (expression -> expression and expression .)
    or              reduce using rule 54 (expression -> expression and expression .)
    xor             reduce using rule 54 (expression -> expression and expression .)
    strand          reduce using rule 54 (expression -> expression and expression .)
    stror           reduce using rule 54 (expression -> expression and expression .)
    lt              reduce using rule 54 (expression -> expression and expression .)
    gt              reduce using rule 54 (expression -> expression and expression .)
    lequal          reduce using rule 54 (expression -> expression and expression .)
    gequal          reduce using rule 54 (expression -> expression and expression .)
    isnotequal      reduce using rule 54 (expression -> expression and expression .)
    isequal         reduce using rule 54 (expression -> expression and expression .)
    newline         reduce using rule 54 (expression -> expression and expression .)
    dedent          reduce using rule 54 (expression -> expression and expression .)
    print           reduce using rule 54 (expression -> expression and expression .)
    identifier      reduce using rule 54 (expression -> expression and expression .)
    lambda          reduce using rule 54 (expression -> expression and expression .)
    invert          reduce using rule 54 (expression -> expression and expression .)
    not             reduce using rule 54 (expression -> expression and expression .)
    if              reduce using rule 54 (expression -> expression and expression .)
    while           reduce using rule 54 (expression -> expression and expression .)
    def             reduce using rule 54 (expression -> expression and expression .)
    return          reduce using rule 54 (expression -> expression and expression .)
    true            reduce using rule 54 (expression -> expression and expression .)
    false           reduce using rule 54 (expression -> expression and expression .)
    obracket        reduce using rule 54 (expression -> expression and expression .)
    integer         reduce using rule 54 (expression -> expression and expression .)
    none            reduce using rule 54 (expression -> expression and expression .)
    $end            reduce using rule 54 (expression -> expression and expression .)
    colon           reduce using rule 54 (expression -> expression and expression .)
    cparen          reduce using rule 54 (expression -> expression and expression .)
    cbracket        reduce using rule 54 (expression -> expression and expression .)
    comma           reduce using rule 54 (expression -> expression and expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 54 (expression -> expression and expression .) ]
  ! plus            [ reduce using rule 54 (expression -> expression and expression .) ]
  ! minus           [ reduce using rule 54 (expression -> expression and expression .) ]
  ! times           [ reduce using rule 54 (expression -> expression and expression .) ]
  ! div             [ reduce using rule 54 (expression -> expression and expression .) ]
  ! power           [ reduce using rule 54 (expression -> expression and expression .) ]
  ! modulo          [ reduce using rule 54 (expression -> expression and expression .) ]
  ! lshift          [ reduce using rule 54 (expression -> expression and expression .) ]
  ! rshift          [ reduce using rule 54 (expression -> expression and expression .) ]
  ! floordiv        [ reduce using rule 54 (expression -> expression and expression .) ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 109

    (60) expression -> expression gt expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 60 (expression -> expression gt expression .)
    stror           reduce using rule 60 (expression -> expression gt expression .)
    lt              reduce using rule 60 (expression -> expression gt expression .)
    gt              reduce using rule 60 (expression -> expression gt expression .)
    lequal          reduce using rule 60 (expression -> expression gt expression .)
    gequal          reduce using rule 60 (expression -> expression gt expression .)
    isnotequal      reduce using rule 60 (expression -> expression gt expression .)
    isequal         reduce using rule 60 (expression -> expression gt expression .)
    newline         reduce using rule 60 (expression -> expression gt expression .)
    dedent          reduce using rule 60 (expression -> expression gt expression .)
    print           reduce using rule 60 (expression -> expression gt expression .)
    identifier      reduce using rule 60 (expression -> expression gt expression .)
    lambda          reduce using rule 60 (expression -> expression gt expression .)
    invert          reduce using rule 60 (expression -> expression gt expression .)
    not             reduce using rule 60 (expression -> expression gt expression .)
    if              reduce using rule 60 (expression -> expression gt expression .)
    while           reduce using rule 60 (expression -> expression gt expression .)
    def             reduce using rule 60 (expression -> expression gt expression .)
    return          reduce using rule 60 (expression -> expression gt expression .)
    true            reduce using rule 60 (expression -> expression gt expression .)
    false           reduce using rule 60 (expression -> expression gt expression .)
    obracket        reduce using rule 60 (expression -> expression gt expression .)
    integer         reduce using rule 60 (expression -> expression gt expression .)
    none            reduce using rule 60 (expression -> expression gt expression .)
    $end            reduce using rule 60 (expression -> expression gt expression .)
    colon           reduce using rule 60 (expression -> expression gt expression .)
    cparen          reduce using rule 60 (expression -> expression gt expression .)
    cbracket        reduce using rule 60 (expression -> expression gt expression .)
    comma           reduce using rule 60 (expression -> expression gt expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! plus            [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! minus           [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! times           [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! div             [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! power           [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! modulo          [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! lshift          [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! rshift          [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! floordiv        [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! and             [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! or              [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! xor             [ reduce using rule 60 (expression -> expression gt expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 110

    (50) expression -> expression modulo expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 50 (expression -> expression modulo expression .)
    minus           reduce using rule 50 (expression -> expression modulo expression .)
    times           reduce using rule 50 (expression -> expression modulo expression .)
    div             reduce using rule 50 (expression -> expression modulo expression .)
    modulo          reduce using rule 50 (expression -> expression modulo expression .)
    lshift          reduce using rule 50 (expression -> expression modulo expression .)
    rshift          reduce using rule 50 (expression -> expression modulo expression .)
    floordiv        reduce using rule 50 (expression -> expression modulo expression .)
    and             reduce using rule 50 (expression -> expression modulo expression .)
    or              reduce using rule 50 (expression -> expression modulo expression .)
    xor             reduce using rule 50 (expression -> expression modulo expression .)
    strand          reduce using rule 50 (expression -> expression modulo expression .)
    stror           reduce using rule 50 (expression -> expression modulo expression .)
    lt              reduce using rule 50 (expression -> expression modulo expression .)
    gt              reduce using rule 50 (expression -> expression modulo expression .)
    lequal          reduce using rule 50 (expression -> expression modulo expression .)
    gequal          reduce using rule 50 (expression -> expression modulo expression .)
    isnotequal      reduce using rule 50 (expression -> expression modulo expression .)
    isequal         reduce using rule 50 (expression -> expression modulo expression .)
    newline         reduce using rule 50 (expression -> expression modulo expression .)
    dedent          reduce using rule 50 (expression -> expression modulo expression .)
    print           reduce using rule 50 (expression -> expression modulo expression .)
    identifier      reduce using rule 50 (expression -> expression modulo expression .)
    lambda          reduce using rule 50 (expression -> expression modulo expression .)
    invert          reduce using rule 50 (expression -> expression modulo expression .)
    not             reduce using rule 50 (expression -> expression modulo expression .)
    if              reduce using rule 50 (expression -> expression modulo expression .)
    while           reduce using rule 50 (expression -> expression modulo expression .)
    def             reduce using rule 50 (expression -> expression modulo expression .)
    return          reduce using rule 50 (expression -> expression modulo expression .)
    true            reduce using rule 50 (expression -> expression modulo expression .)
    false           reduce using rule 50 (expression -> expression modulo expression .)
    obracket        reduce using rule 50 (expression -> expression modulo expression .)
    integer         reduce using rule 50 (expression -> expression modulo expression .)
    none            reduce using rule 50 (expression -> expression modulo expression .)
    $end            reduce using rule 50 (expression -> expression modulo expression .)
    colon           reduce using rule 50 (expression -> expression modulo expression .)
    cparen          reduce using rule 50 (expression -> expression modulo expression .)
    cbracket        reduce using rule 50 (expression -> expression modulo expression .)
    comma           reduce using rule 50 (expression -> expression modulo expression .)
    oparen          shift and go to state 74
    power           shift and go to state 76

  ! oparen          [ reduce using rule 50 (expression -> expression modulo expression .) ]
  ! power           [ reduce using rule 50 (expression -> expression modulo expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! times           [ shift and go to state 80 ]
  ! div             [ shift and go to state 83 ]
  ! modulo          [ shift and go to state 66 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! floordiv        [ shift and go to state 81 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 111

    (61) expression -> expression lequal expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 61 (expression -> expression lequal expression .)
    stror           reduce using rule 61 (expression -> expression lequal expression .)
    lt              reduce using rule 61 (expression -> expression lequal expression .)
    gt              reduce using rule 61 (expression -> expression lequal expression .)
    lequal          reduce using rule 61 (expression -> expression lequal expression .)
    gequal          reduce using rule 61 (expression -> expression lequal expression .)
    isnotequal      reduce using rule 61 (expression -> expression lequal expression .)
    isequal         reduce using rule 61 (expression -> expression lequal expression .)
    newline         reduce using rule 61 (expression -> expression lequal expression .)
    dedent          reduce using rule 61 (expression -> expression lequal expression .)
    print           reduce using rule 61 (expression -> expression lequal expression .)
    identifier      reduce using rule 61 (expression -> expression lequal expression .)
    lambda          reduce using rule 61 (expression -> expression lequal expression .)
    invert          reduce using rule 61 (expression -> expression lequal expression .)
    not             reduce using rule 61 (expression -> expression lequal expression .)
    if              reduce using rule 61 (expression -> expression lequal expression .)
    while           reduce using rule 61 (expression -> expression lequal expression .)
    def             reduce using rule 61 (expression -> expression lequal expression .)
    return          reduce using rule 61 (expression -> expression lequal expression .)
    true            reduce using rule 61 (expression -> expression lequal expression .)
    false           reduce using rule 61 (expression -> expression lequal expression .)
    obracket        reduce using rule 61 (expression -> expression lequal expression .)
    integer         reduce using rule 61 (expression -> expression lequal expression .)
    none            reduce using rule 61 (expression -> expression lequal expression .)
    $end            reduce using rule 61 (expression -> expression lequal expression .)
    colon           reduce using rule 61 (expression -> expression lequal expression .)
    cparen          reduce using rule 61 (expression -> expression lequal expression .)
    cbracket        reduce using rule 61 (expression -> expression lequal expression .)
    comma           reduce using rule 61 (expression -> expression lequal expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! plus            [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! minus           [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! times           [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! div             [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! power           [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! modulo          [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! lshift          [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! rshift          [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! floordiv        [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! and             [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! or              [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! xor             [ reduce using rule 61 (expression -> expression lequal expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 112

    (51) expression -> expression lshift expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    lshift          reduce using rule 51 (expression -> expression lshift expression .)
    rshift          reduce using rule 51 (expression -> expression lshift expression .)
    and             reduce using rule 51 (expression -> expression lshift expression .)
    or              reduce using rule 51 (expression -> expression lshift expression .)
    xor             reduce using rule 51 (expression -> expression lshift expression .)
    strand          reduce using rule 51 (expression -> expression lshift expression .)
    stror           reduce using rule 51 (expression -> expression lshift expression .)
    lt              reduce using rule 51 (expression -> expression lshift expression .)
    gt              reduce using rule 51 (expression -> expression lshift expression .)
    lequal          reduce using rule 51 (expression -> expression lshift expression .)
    gequal          reduce using rule 51 (expression -> expression lshift expression .)
    isnotequal      reduce using rule 51 (expression -> expression lshift expression .)
    isequal         reduce using rule 51 (expression -> expression lshift expression .)
    newline         reduce using rule 51 (expression -> expression lshift expression .)
    dedent          reduce using rule 51 (expression -> expression lshift expression .)
    print           reduce using rule 51 (expression -> expression lshift expression .)
    identifier      reduce using rule 51 (expression -> expression lshift expression .)
    lambda          reduce using rule 51 (expression -> expression lshift expression .)
    invert          reduce using rule 51 (expression -> expression lshift expression .)
    not             reduce using rule 51 (expression -> expression lshift expression .)
    if              reduce using rule 51 (expression -> expression lshift expression .)
    while           reduce using rule 51 (expression -> expression lshift expression .)
    def             reduce using rule 51 (expression -> expression lshift expression .)
    return          reduce using rule 51 (expression -> expression lshift expression .)
    true            reduce using rule 51 (expression -> expression lshift expression .)
    false           reduce using rule 51 (expression -> expression lshift expression .)
    obracket        reduce using rule 51 (expression -> expression lshift expression .)
    integer         reduce using rule 51 (expression -> expression lshift expression .)
    none            reduce using rule 51 (expression -> expression lshift expression .)
    $end            reduce using rule 51 (expression -> expression lshift expression .)
    colon           reduce using rule 51 (expression -> expression lshift expression .)
    cparen          reduce using rule 51 (expression -> expression lshift expression .)
    cbracket        reduce using rule 51 (expression -> expression lshift expression .)
    comma           reduce using rule 51 (expression -> expression lshift expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! plus            [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! minus           [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! times           [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! div             [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! power           [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! modulo          [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! floordiv        [ reduce using rule 51 (expression -> expression lshift expression .) ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 113

    (64) expression -> expression isequal expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 64 (expression -> expression isequal expression .)
    stror           reduce using rule 64 (expression -> expression isequal expression .)
    lt              reduce using rule 64 (expression -> expression isequal expression .)
    gt              reduce using rule 64 (expression -> expression isequal expression .)
    lequal          reduce using rule 64 (expression -> expression isequal expression .)
    gequal          reduce using rule 64 (expression -> expression isequal expression .)
    isnotequal      reduce using rule 64 (expression -> expression isequal expression .)
    isequal         reduce using rule 64 (expression -> expression isequal expression .)
    newline         reduce using rule 64 (expression -> expression isequal expression .)
    dedent          reduce using rule 64 (expression -> expression isequal expression .)
    print           reduce using rule 64 (expression -> expression isequal expression .)
    identifier      reduce using rule 64 (expression -> expression isequal expression .)
    lambda          reduce using rule 64 (expression -> expression isequal expression .)
    invert          reduce using rule 64 (expression -> expression isequal expression .)
    not             reduce using rule 64 (expression -> expression isequal expression .)
    if              reduce using rule 64 (expression -> expression isequal expression .)
    while           reduce using rule 64 (expression -> expression isequal expression .)
    def             reduce using rule 64 (expression -> expression isequal expression .)
    return          reduce using rule 64 (expression -> expression isequal expression .)
    true            reduce using rule 64 (expression -> expression isequal expression .)
    false           reduce using rule 64 (expression -> expression isequal expression .)
    obracket        reduce using rule 64 (expression -> expression isequal expression .)
    integer         reduce using rule 64 (expression -> expression isequal expression .)
    none            reduce using rule 64 (expression -> expression isequal expression .)
    $end            reduce using rule 64 (expression -> expression isequal expression .)
    colon           reduce using rule 64 (expression -> expression isequal expression .)
    cparen          reduce using rule 64 (expression -> expression isequal expression .)
    cbracket        reduce using rule 64 (expression -> expression isequal expression .)
    comma           reduce using rule 64 (expression -> expression isequal expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! plus            [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! minus           [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! times           [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! div             [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! power           [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! modulo          [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! lshift          [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! rshift          [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! floordiv        [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! and             [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! or              [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! xor             [ reduce using rule 64 (expression -> expression isequal expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 114

    (62) expression -> expression gequal expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 62 (expression -> expression gequal expression .)
    stror           reduce using rule 62 (expression -> expression gequal expression .)
    lt              reduce using rule 62 (expression -> expression gequal expression .)
    gt              reduce using rule 62 (expression -> expression gequal expression .)
    lequal          reduce using rule 62 (expression -> expression gequal expression .)
    gequal          reduce using rule 62 (expression -> expression gequal expression .)
    isnotequal      reduce using rule 62 (expression -> expression gequal expression .)
    isequal         reduce using rule 62 (expression -> expression gequal expression .)
    newline         reduce using rule 62 (expression -> expression gequal expression .)
    dedent          reduce using rule 62 (expression -> expression gequal expression .)
    print           reduce using rule 62 (expression -> expression gequal expression .)
    identifier      reduce using rule 62 (expression -> expression gequal expression .)
    lambda          reduce using rule 62 (expression -> expression gequal expression .)
    invert          reduce using rule 62 (expression -> expression gequal expression .)
    not             reduce using rule 62 (expression -> expression gequal expression .)
    if              reduce using rule 62 (expression -> expression gequal expression .)
    while           reduce using rule 62 (expression -> expression gequal expression .)
    def             reduce using rule 62 (expression -> expression gequal expression .)
    return          reduce using rule 62 (expression -> expression gequal expression .)
    true            reduce using rule 62 (expression -> expression gequal expression .)
    false           reduce using rule 62 (expression -> expression gequal expression .)
    obracket        reduce using rule 62 (expression -> expression gequal expression .)
    integer         reduce using rule 62 (expression -> expression gequal expression .)
    none            reduce using rule 62 (expression -> expression gequal expression .)
    $end            reduce using rule 62 (expression -> expression gequal expression .)
    colon           reduce using rule 62 (expression -> expression gequal expression .)
    cparen          reduce using rule 62 (expression -> expression gequal expression .)
    cbracket        reduce using rule 62 (expression -> expression gequal expression .)
    comma           reduce using rule 62 (expression -> expression gequal expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! plus            [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! minus           [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! times           [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! div             [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! power           [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! modulo          [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! lshift          [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! rshift          [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! floordiv        [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! and             [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! or              [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! xor             [ reduce using rule 62 (expression -> expression gequal expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 115

    (56) expression -> expression xor expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    or              reduce using rule 56 (expression -> expression xor expression .)
    xor             reduce using rule 56 (expression -> expression xor expression .)
    strand          reduce using rule 56 (expression -> expression xor expression .)
    stror           reduce using rule 56 (expression -> expression xor expression .)
    lt              reduce using rule 56 (expression -> expression xor expression .)
    gt              reduce using rule 56 (expression -> expression xor expression .)
    lequal          reduce using rule 56 (expression -> expression xor expression .)
    gequal          reduce using rule 56 (expression -> expression xor expression .)
    isnotequal      reduce using rule 56 (expression -> expression xor expression .)
    isequal         reduce using rule 56 (expression -> expression xor expression .)
    newline         reduce using rule 56 (expression -> expression xor expression .)
    dedent          reduce using rule 56 (expression -> expression xor expression .)
    print           reduce using rule 56 (expression -> expression xor expression .)
    identifier      reduce using rule 56 (expression -> expression xor expression .)
    lambda          reduce using rule 56 (expression -> expression xor expression .)
    invert          reduce using rule 56 (expression -> expression xor expression .)
    not             reduce using rule 56 (expression -> expression xor expression .)
    if              reduce using rule 56 (expression -> expression xor expression .)
    while           reduce using rule 56 (expression -> expression xor expression .)
    def             reduce using rule 56 (expression -> expression xor expression .)
    return          reduce using rule 56 (expression -> expression xor expression .)
    true            reduce using rule 56 (expression -> expression xor expression .)
    false           reduce using rule 56 (expression -> expression xor expression .)
    obracket        reduce using rule 56 (expression -> expression xor expression .)
    integer         reduce using rule 56 (expression -> expression xor expression .)
    none            reduce using rule 56 (expression -> expression xor expression .)
    $end            reduce using rule 56 (expression -> expression xor expression .)
    colon           reduce using rule 56 (expression -> expression xor expression .)
    cparen          reduce using rule 56 (expression -> expression xor expression .)
    cbracket        reduce using rule 56 (expression -> expression xor expression .)
    comma           reduce using rule 56 (expression -> expression xor expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64

  ! oparen          [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! plus            [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! minus           [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! times           [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! div             [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! power           [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! modulo          [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! lshift          [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! rshift          [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! floordiv        [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! and             [ reduce using rule 56 (expression -> expression xor expression .) ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 116

    (58) expression -> expression stror expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    stror           reduce using rule 58 (expression -> expression stror expression .)
    newline         reduce using rule 58 (expression -> expression stror expression .)
    dedent          reduce using rule 58 (expression -> expression stror expression .)
    print           reduce using rule 58 (expression -> expression stror expression .)
    identifier      reduce using rule 58 (expression -> expression stror expression .)
    lambda          reduce using rule 58 (expression -> expression stror expression .)
    invert          reduce using rule 58 (expression -> expression stror expression .)
    not             reduce using rule 58 (expression -> expression stror expression .)
    if              reduce using rule 58 (expression -> expression stror expression .)
    while           reduce using rule 58 (expression -> expression stror expression .)
    def             reduce using rule 58 (expression -> expression stror expression .)
    return          reduce using rule 58 (expression -> expression stror expression .)
    true            reduce using rule 58 (expression -> expression stror expression .)
    false           reduce using rule 58 (expression -> expression stror expression .)
    obracket        reduce using rule 58 (expression -> expression stror expression .)
    integer         reduce using rule 58 (expression -> expression stror expression .)
    none            reduce using rule 58 (expression -> expression stror expression .)
    $end            reduce using rule 58 (expression -> expression stror expression .)
    colon           reduce using rule 58 (expression -> expression stror expression .)
    cparen          reduce using rule 58 (expression -> expression stror expression .)
    cbracket        reduce using rule 58 (expression -> expression stror expression .)
    comma           reduce using rule 58 (expression -> expression stror expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! oparen          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! plus            [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! minus           [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! times           [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! div             [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! power           [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! modulo          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! lshift          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! rshift          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! floordiv        [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! and             [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! or              [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! xor             [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! strand          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! lt              [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! gt              [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! lequal          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! gequal          [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! isnotequal      [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! isequal         [ reduce using rule 58 (expression -> expression stror expression .) ]
  ! stror           [ shift and go to state 72 ]


state 117

    (59) expression -> expression lt expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 59 (expression -> expression lt expression .)
    stror           reduce using rule 59 (expression -> expression lt expression .)
    lt              reduce using rule 59 (expression -> expression lt expression .)
    gt              reduce using rule 59 (expression -> expression lt expression .)
    lequal          reduce using rule 59 (expression -> expression lt expression .)
    gequal          reduce using rule 59 (expression -> expression lt expression .)
    isnotequal      reduce using rule 59 (expression -> expression lt expression .)
    isequal         reduce using rule 59 (expression -> expression lt expression .)
    newline         reduce using rule 59 (expression -> expression lt expression .)
    dedent          reduce using rule 59 (expression -> expression lt expression .)
    print           reduce using rule 59 (expression -> expression lt expression .)
    identifier      reduce using rule 59 (expression -> expression lt expression .)
    lambda          reduce using rule 59 (expression -> expression lt expression .)
    invert          reduce using rule 59 (expression -> expression lt expression .)
    not             reduce using rule 59 (expression -> expression lt expression .)
    if              reduce using rule 59 (expression -> expression lt expression .)
    while           reduce using rule 59 (expression -> expression lt expression .)
    def             reduce using rule 59 (expression -> expression lt expression .)
    return          reduce using rule 59 (expression -> expression lt expression .)
    true            reduce using rule 59 (expression -> expression lt expression .)
    false           reduce using rule 59 (expression -> expression lt expression .)
    obracket        reduce using rule 59 (expression -> expression lt expression .)
    integer         reduce using rule 59 (expression -> expression lt expression .)
    none            reduce using rule 59 (expression -> expression lt expression .)
    $end            reduce using rule 59 (expression -> expression lt expression .)
    colon           reduce using rule 59 (expression -> expression lt expression .)
    cparen          reduce using rule 59 (expression -> expression lt expression .)
    cbracket        reduce using rule 59 (expression -> expression lt expression .)
    comma           reduce using rule 59 (expression -> expression lt expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! plus            [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! minus           [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! times           [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! div             [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! power           [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! modulo          [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! lshift          [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! rshift          [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! floordiv        [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! and             [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! or              [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! xor             [ reduce using rule 59 (expression -> expression lt expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 118

    (17) expression -> expression oparen parameters . cparen
    (9) parameters -> parameters . comma expression

    cparen          shift and go to state 138
    comma           shift and go to state 137


state 119

    (8) parameters -> expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    cparen          reduce using rule 8 (parameters -> expression .)
    comma           reduce using rule 8 (parameters -> expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 120

    (52) expression -> expression rshift expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    lshift          reduce using rule 52 (expression -> expression rshift expression .)
    rshift          reduce using rule 52 (expression -> expression rshift expression .)
    and             reduce using rule 52 (expression -> expression rshift expression .)
    or              reduce using rule 52 (expression -> expression rshift expression .)
    xor             reduce using rule 52 (expression -> expression rshift expression .)
    strand          reduce using rule 52 (expression -> expression rshift expression .)
    stror           reduce using rule 52 (expression -> expression rshift expression .)
    lt              reduce using rule 52 (expression -> expression rshift expression .)
    gt              reduce using rule 52 (expression -> expression rshift expression .)
    lequal          reduce using rule 52 (expression -> expression rshift expression .)
    gequal          reduce using rule 52 (expression -> expression rshift expression .)
    isnotequal      reduce using rule 52 (expression -> expression rshift expression .)
    isequal         reduce using rule 52 (expression -> expression rshift expression .)
    newline         reduce using rule 52 (expression -> expression rshift expression .)
    dedent          reduce using rule 52 (expression -> expression rshift expression .)
    print           reduce using rule 52 (expression -> expression rshift expression .)
    identifier      reduce using rule 52 (expression -> expression rshift expression .)
    lambda          reduce using rule 52 (expression -> expression rshift expression .)
    invert          reduce using rule 52 (expression -> expression rshift expression .)
    not             reduce using rule 52 (expression -> expression rshift expression .)
    if              reduce using rule 52 (expression -> expression rshift expression .)
    while           reduce using rule 52 (expression -> expression rshift expression .)
    def             reduce using rule 52 (expression -> expression rshift expression .)
    return          reduce using rule 52 (expression -> expression rshift expression .)
    true            reduce using rule 52 (expression -> expression rshift expression .)
    false           reduce using rule 52 (expression -> expression rshift expression .)
    obracket        reduce using rule 52 (expression -> expression rshift expression .)
    integer         reduce using rule 52 (expression -> expression rshift expression .)
    none            reduce using rule 52 (expression -> expression rshift expression .)
    $end            reduce using rule 52 (expression -> expression rshift expression .)
    colon           reduce using rule 52 (expression -> expression rshift expression .)
    cparen          reduce using rule 52 (expression -> expression rshift expression .)
    cbracket        reduce using rule 52 (expression -> expression rshift expression .)
    comma           reduce using rule 52 (expression -> expression rshift expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! plus            [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! minus           [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! times           [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! div             [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! power           [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! modulo          [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! floordiv        [ reduce using rule 52 (expression -> expression rshift expression .) ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 121

    (49) expression -> expression power expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 49 (expression -> expression power expression .)
    minus           reduce using rule 49 (expression -> expression power expression .)
    times           reduce using rule 49 (expression -> expression power expression .)
    div             reduce using rule 49 (expression -> expression power expression .)
    modulo          reduce using rule 49 (expression -> expression power expression .)
    lshift          reduce using rule 49 (expression -> expression power expression .)
    rshift          reduce using rule 49 (expression -> expression power expression .)
    floordiv        reduce using rule 49 (expression -> expression power expression .)
    and             reduce using rule 49 (expression -> expression power expression .)
    or              reduce using rule 49 (expression -> expression power expression .)
    xor             reduce using rule 49 (expression -> expression power expression .)
    strand          reduce using rule 49 (expression -> expression power expression .)
    stror           reduce using rule 49 (expression -> expression power expression .)
    lt              reduce using rule 49 (expression -> expression power expression .)
    gt              reduce using rule 49 (expression -> expression power expression .)
    lequal          reduce using rule 49 (expression -> expression power expression .)
    gequal          reduce using rule 49 (expression -> expression power expression .)
    isnotequal      reduce using rule 49 (expression -> expression power expression .)
    isequal         reduce using rule 49 (expression -> expression power expression .)
    newline         reduce using rule 49 (expression -> expression power expression .)
    dedent          reduce using rule 49 (expression -> expression power expression .)
    print           reduce using rule 49 (expression -> expression power expression .)
    identifier      reduce using rule 49 (expression -> expression power expression .)
    lambda          reduce using rule 49 (expression -> expression power expression .)
    invert          reduce using rule 49 (expression -> expression power expression .)
    not             reduce using rule 49 (expression -> expression power expression .)
    if              reduce using rule 49 (expression -> expression power expression .)
    while           reduce using rule 49 (expression -> expression power expression .)
    def             reduce using rule 49 (expression -> expression power expression .)
    return          reduce using rule 49 (expression -> expression power expression .)
    true            reduce using rule 49 (expression -> expression power expression .)
    false           reduce using rule 49 (expression -> expression power expression .)
    obracket        reduce using rule 49 (expression -> expression power expression .)
    integer         reduce using rule 49 (expression -> expression power expression .)
    none            reduce using rule 49 (expression -> expression power expression .)
    $end            reduce using rule 49 (expression -> expression power expression .)
    colon           reduce using rule 49 (expression -> expression power expression .)
    cparen          reduce using rule 49 (expression -> expression power expression .)
    cbracket        reduce using rule 49 (expression -> expression power expression .)
    comma           reduce using rule 49 (expression -> expression power expression .)
    oparen          shift and go to state 74
    power           shift and go to state 76

  ! oparen          [ reduce using rule 49 (expression -> expression power expression .) ]
  ! power           [ reduce using rule 49 (expression -> expression power expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! times           [ shift and go to state 80 ]
  ! div             [ shift and go to state 83 ]
  ! modulo          [ shift and go to state 66 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! floordiv        [ shift and go to state 81 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 122

    (46) expression -> expression minus expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 46 (expression -> expression minus expression .)
    minus           reduce using rule 46 (expression -> expression minus expression .)
    lshift          reduce using rule 46 (expression -> expression minus expression .)
    rshift          reduce using rule 46 (expression -> expression minus expression .)
    and             reduce using rule 46 (expression -> expression minus expression .)
    or              reduce using rule 46 (expression -> expression minus expression .)
    xor             reduce using rule 46 (expression -> expression minus expression .)
    strand          reduce using rule 46 (expression -> expression minus expression .)
    stror           reduce using rule 46 (expression -> expression minus expression .)
    lt              reduce using rule 46 (expression -> expression minus expression .)
    gt              reduce using rule 46 (expression -> expression minus expression .)
    lequal          reduce using rule 46 (expression -> expression minus expression .)
    gequal          reduce using rule 46 (expression -> expression minus expression .)
    isnotequal      reduce using rule 46 (expression -> expression minus expression .)
    isequal         reduce using rule 46 (expression -> expression minus expression .)
    newline         reduce using rule 46 (expression -> expression minus expression .)
    dedent          reduce using rule 46 (expression -> expression minus expression .)
    print           reduce using rule 46 (expression -> expression minus expression .)
    identifier      reduce using rule 46 (expression -> expression minus expression .)
    lambda          reduce using rule 46 (expression -> expression minus expression .)
    invert          reduce using rule 46 (expression -> expression minus expression .)
    not             reduce using rule 46 (expression -> expression minus expression .)
    if              reduce using rule 46 (expression -> expression minus expression .)
    while           reduce using rule 46 (expression -> expression minus expression .)
    def             reduce using rule 46 (expression -> expression minus expression .)
    return          reduce using rule 46 (expression -> expression minus expression .)
    true            reduce using rule 46 (expression -> expression minus expression .)
    false           reduce using rule 46 (expression -> expression minus expression .)
    obracket        reduce using rule 46 (expression -> expression minus expression .)
    integer         reduce using rule 46 (expression -> expression minus expression .)
    none            reduce using rule 46 (expression -> expression minus expression .)
    $end            reduce using rule 46 (expression -> expression minus expression .)
    colon           reduce using rule 46 (expression -> expression minus expression .)
    cparen          reduce using rule 46 (expression -> expression minus expression .)
    cbracket        reduce using rule 46 (expression -> expression minus expression .)
    comma           reduce using rule 46 (expression -> expression minus expression .)
    oparen          shift and go to state 74
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 46 (expression -> expression minus expression .) ]
  ! times           [ reduce using rule 46 (expression -> expression minus expression .) ]
  ! div             [ reduce using rule 46 (expression -> expression minus expression .) ]
  ! power           [ reduce using rule 46 (expression -> expression minus expression .) ]
  ! modulo          [ reduce using rule 46 (expression -> expression minus expression .) ]
  ! floordiv        [ reduce using rule 46 (expression -> expression minus expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 123

    (57) expression -> expression strand expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 57 (expression -> expression strand expression .)
    stror           reduce using rule 57 (expression -> expression strand expression .)
    newline         reduce using rule 57 (expression -> expression strand expression .)
    dedent          reduce using rule 57 (expression -> expression strand expression .)
    print           reduce using rule 57 (expression -> expression strand expression .)
    identifier      reduce using rule 57 (expression -> expression strand expression .)
    lambda          reduce using rule 57 (expression -> expression strand expression .)
    invert          reduce using rule 57 (expression -> expression strand expression .)
    not             reduce using rule 57 (expression -> expression strand expression .)
    if              reduce using rule 57 (expression -> expression strand expression .)
    while           reduce using rule 57 (expression -> expression strand expression .)
    def             reduce using rule 57 (expression -> expression strand expression .)
    return          reduce using rule 57 (expression -> expression strand expression .)
    true            reduce using rule 57 (expression -> expression strand expression .)
    false           reduce using rule 57 (expression -> expression strand expression .)
    obracket        reduce using rule 57 (expression -> expression strand expression .)
    integer         reduce using rule 57 (expression -> expression strand expression .)
    none            reduce using rule 57 (expression -> expression strand expression .)
    $end            reduce using rule 57 (expression -> expression strand expression .)
    colon           reduce using rule 57 (expression -> expression strand expression .)
    cparen          reduce using rule 57 (expression -> expression strand expression .)
    cbracket        reduce using rule 57 (expression -> expression strand expression .)
    comma           reduce using rule 57 (expression -> expression strand expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! oparen          [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! plus            [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! minus           [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! times           [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! div             [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! power           [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! modulo          [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! lshift          [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! rshift          [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! floordiv        [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! and             [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! or              [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! xor             [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! lt              [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! gt              [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! lequal          [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! gequal          [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! isnotequal      [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! isequal         [ reduce using rule 57 (expression -> expression strand expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]


state 124

    (63) expression -> expression isnotequal expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    strand          reduce using rule 63 (expression -> expression isnotequal expression .)
    stror           reduce using rule 63 (expression -> expression isnotequal expression .)
    lt              reduce using rule 63 (expression -> expression isnotequal expression .)
    gt              reduce using rule 63 (expression -> expression isnotequal expression .)
    lequal          reduce using rule 63 (expression -> expression isnotequal expression .)
    gequal          reduce using rule 63 (expression -> expression isnotequal expression .)
    isnotequal      reduce using rule 63 (expression -> expression isnotequal expression .)
    isequal         reduce using rule 63 (expression -> expression isnotequal expression .)
    newline         reduce using rule 63 (expression -> expression isnotequal expression .)
    dedent          reduce using rule 63 (expression -> expression isnotequal expression .)
    print           reduce using rule 63 (expression -> expression isnotequal expression .)
    identifier      reduce using rule 63 (expression -> expression isnotequal expression .)
    lambda          reduce using rule 63 (expression -> expression isnotequal expression .)
    invert          reduce using rule 63 (expression -> expression isnotequal expression .)
    not             reduce using rule 63 (expression -> expression isnotequal expression .)
    if              reduce using rule 63 (expression -> expression isnotequal expression .)
    while           reduce using rule 63 (expression -> expression isnotequal expression .)
    def             reduce using rule 63 (expression -> expression isnotequal expression .)
    return          reduce using rule 63 (expression -> expression isnotequal expression .)
    true            reduce using rule 63 (expression -> expression isnotequal expression .)
    false           reduce using rule 63 (expression -> expression isnotequal expression .)
    obracket        reduce using rule 63 (expression -> expression isnotequal expression .)
    integer         reduce using rule 63 (expression -> expression isnotequal expression .)
    none            reduce using rule 63 (expression -> expression isnotequal expression .)
    $end            reduce using rule 63 (expression -> expression isnotequal expression .)
    colon           reduce using rule 63 (expression -> expression isnotequal expression .)
    cparen          reduce using rule 63 (expression -> expression isnotequal expression .)
    cbracket        reduce using rule 63 (expression -> expression isnotequal expression .)
    comma           reduce using rule 63 (expression -> expression isnotequal expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! plus            [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! minus           [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! times           [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! div             [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! power           [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! modulo          [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! lshift          [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! rshift          [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! floordiv        [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! and             [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! or              [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! xor             [ reduce using rule 63 (expression -> expression isnotequal expression .) ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 125

    (47) expression -> expression times expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 47 (expression -> expression times expression .)
    minus           reduce using rule 47 (expression -> expression times expression .)
    times           reduce using rule 47 (expression -> expression times expression .)
    div             reduce using rule 47 (expression -> expression times expression .)
    modulo          reduce using rule 47 (expression -> expression times expression .)
    lshift          reduce using rule 47 (expression -> expression times expression .)
    rshift          reduce using rule 47 (expression -> expression times expression .)
    floordiv        reduce using rule 47 (expression -> expression times expression .)
    and             reduce using rule 47 (expression -> expression times expression .)
    or              reduce using rule 47 (expression -> expression times expression .)
    xor             reduce using rule 47 (expression -> expression times expression .)
    strand          reduce using rule 47 (expression -> expression times expression .)
    stror           reduce using rule 47 (expression -> expression times expression .)
    lt              reduce using rule 47 (expression -> expression times expression .)
    gt              reduce using rule 47 (expression -> expression times expression .)
    lequal          reduce using rule 47 (expression -> expression times expression .)
    gequal          reduce using rule 47 (expression -> expression times expression .)
    isnotequal      reduce using rule 47 (expression -> expression times expression .)
    isequal         reduce using rule 47 (expression -> expression times expression .)
    newline         reduce using rule 47 (expression -> expression times expression .)
    dedent          reduce using rule 47 (expression -> expression times expression .)
    print           reduce using rule 47 (expression -> expression times expression .)
    identifier      reduce using rule 47 (expression -> expression times expression .)
    lambda          reduce using rule 47 (expression -> expression times expression .)
    invert          reduce using rule 47 (expression -> expression times expression .)
    not             reduce using rule 47 (expression -> expression times expression .)
    if              reduce using rule 47 (expression -> expression times expression .)
    while           reduce using rule 47 (expression -> expression times expression .)
    def             reduce using rule 47 (expression -> expression times expression .)
    return          reduce using rule 47 (expression -> expression times expression .)
    true            reduce using rule 47 (expression -> expression times expression .)
    false           reduce using rule 47 (expression -> expression times expression .)
    obracket        reduce using rule 47 (expression -> expression times expression .)
    integer         reduce using rule 47 (expression -> expression times expression .)
    none            reduce using rule 47 (expression -> expression times expression .)
    $end            reduce using rule 47 (expression -> expression times expression .)
    colon           reduce using rule 47 (expression -> expression times expression .)
    cparen          reduce using rule 47 (expression -> expression times expression .)
    cbracket        reduce using rule 47 (expression -> expression times expression .)
    comma           reduce using rule 47 (expression -> expression times expression .)
    oparen          shift and go to state 74
    power           shift and go to state 76

  ! oparen          [ reduce using rule 47 (expression -> expression times expression .) ]
  ! power           [ reduce using rule 47 (expression -> expression times expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! times           [ shift and go to state 80 ]
  ! div             [ shift and go to state 83 ]
  ! modulo          [ shift and go to state 66 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! floordiv        [ shift and go to state 81 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 126

    (53) expression -> expression floordiv expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 53 (expression -> expression floordiv expression .)
    minus           reduce using rule 53 (expression -> expression floordiv expression .)
    times           reduce using rule 53 (expression -> expression floordiv expression .)
    div             reduce using rule 53 (expression -> expression floordiv expression .)
    modulo          reduce using rule 53 (expression -> expression floordiv expression .)
    lshift          reduce using rule 53 (expression -> expression floordiv expression .)
    rshift          reduce using rule 53 (expression -> expression floordiv expression .)
    floordiv        reduce using rule 53 (expression -> expression floordiv expression .)
    and             reduce using rule 53 (expression -> expression floordiv expression .)
    or              reduce using rule 53 (expression -> expression floordiv expression .)
    xor             reduce using rule 53 (expression -> expression floordiv expression .)
    strand          reduce using rule 53 (expression -> expression floordiv expression .)
    stror           reduce using rule 53 (expression -> expression floordiv expression .)
    lt              reduce using rule 53 (expression -> expression floordiv expression .)
    gt              reduce using rule 53 (expression -> expression floordiv expression .)
    lequal          reduce using rule 53 (expression -> expression floordiv expression .)
    gequal          reduce using rule 53 (expression -> expression floordiv expression .)
    isnotequal      reduce using rule 53 (expression -> expression floordiv expression .)
    isequal         reduce using rule 53 (expression -> expression floordiv expression .)
    newline         reduce using rule 53 (expression -> expression floordiv expression .)
    dedent          reduce using rule 53 (expression -> expression floordiv expression .)
    print           reduce using rule 53 (expression -> expression floordiv expression .)
    identifier      reduce using rule 53 (expression -> expression floordiv expression .)
    lambda          reduce using rule 53 (expression -> expression floordiv expression .)
    invert          reduce using rule 53 (expression -> expression floordiv expression .)
    not             reduce using rule 53 (expression -> expression floordiv expression .)
    if              reduce using rule 53 (expression -> expression floordiv expression .)
    while           reduce using rule 53 (expression -> expression floordiv expression .)
    def             reduce using rule 53 (expression -> expression floordiv expression .)
    return          reduce using rule 53 (expression -> expression floordiv expression .)
    true            reduce using rule 53 (expression -> expression floordiv expression .)
    false           reduce using rule 53 (expression -> expression floordiv expression .)
    obracket        reduce using rule 53 (expression -> expression floordiv expression .)
    integer         reduce using rule 53 (expression -> expression floordiv expression .)
    none            reduce using rule 53 (expression -> expression floordiv expression .)
    $end            reduce using rule 53 (expression -> expression floordiv expression .)
    colon           reduce using rule 53 (expression -> expression floordiv expression .)
    cparen          reduce using rule 53 (expression -> expression floordiv expression .)
    cbracket        reduce using rule 53 (expression -> expression floordiv expression .)
    comma           reduce using rule 53 (expression -> expression floordiv expression .)
    oparen          shift and go to state 74
    power           shift and go to state 76

  ! oparen          [ reduce using rule 53 (expression -> expression floordiv expression .) ]
  ! power           [ reduce using rule 53 (expression -> expression floordiv expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! times           [ shift and go to state 80 ]
  ! div             [ shift and go to state 83 ]
  ! modulo          [ shift and go to state 66 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! floordiv        [ shift and go to state 81 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 127

    (45) expression -> expression plus expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 45 (expression -> expression plus expression .)
    minus           reduce using rule 45 (expression -> expression plus expression .)
    lshift          reduce using rule 45 (expression -> expression plus expression .)
    rshift          reduce using rule 45 (expression -> expression plus expression .)
    and             reduce using rule 45 (expression -> expression plus expression .)
    or              reduce using rule 45 (expression -> expression plus expression .)
    xor             reduce using rule 45 (expression -> expression plus expression .)
    strand          reduce using rule 45 (expression -> expression plus expression .)
    stror           reduce using rule 45 (expression -> expression plus expression .)
    lt              reduce using rule 45 (expression -> expression plus expression .)
    gt              reduce using rule 45 (expression -> expression plus expression .)
    lequal          reduce using rule 45 (expression -> expression plus expression .)
    gequal          reduce using rule 45 (expression -> expression plus expression .)
    isnotequal      reduce using rule 45 (expression -> expression plus expression .)
    isequal         reduce using rule 45 (expression -> expression plus expression .)
    newline         reduce using rule 45 (expression -> expression plus expression .)
    dedent          reduce using rule 45 (expression -> expression plus expression .)
    print           reduce using rule 45 (expression -> expression plus expression .)
    identifier      reduce using rule 45 (expression -> expression plus expression .)
    lambda          reduce using rule 45 (expression -> expression plus expression .)
    invert          reduce using rule 45 (expression -> expression plus expression .)
    not             reduce using rule 45 (expression -> expression plus expression .)
    if              reduce using rule 45 (expression -> expression plus expression .)
    while           reduce using rule 45 (expression -> expression plus expression .)
    def             reduce using rule 45 (expression -> expression plus expression .)
    return          reduce using rule 45 (expression -> expression plus expression .)
    true            reduce using rule 45 (expression -> expression plus expression .)
    false           reduce using rule 45 (expression -> expression plus expression .)
    obracket        reduce using rule 45 (expression -> expression plus expression .)
    integer         reduce using rule 45 (expression -> expression plus expression .)
    none            reduce using rule 45 (expression -> expression plus expression .)
    $end            reduce using rule 45 (expression -> expression plus expression .)
    colon           reduce using rule 45 (expression -> expression plus expression .)
    cparen          reduce using rule 45 (expression -> expression plus expression .)
    cbracket        reduce using rule 45 (expression -> expression plus expression .)
    comma           reduce using rule 45 (expression -> expression plus expression .)
    oparen          shift and go to state 74
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    floordiv        shift and go to state 81

  ! oparen          [ reduce using rule 45 (expression -> expression plus expression .) ]
  ! times           [ reduce using rule 45 (expression -> expression plus expression .) ]
  ! div             [ reduce using rule 45 (expression -> expression plus expression .) ]
  ! power           [ reduce using rule 45 (expression -> expression plus expression .) ]
  ! modulo          [ reduce using rule 45 (expression -> expression plus expression .) ]
  ! floordiv        [ reduce using rule 45 (expression -> expression plus expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 128

    (48) expression -> expression div expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    plus            reduce using rule 48 (expression -> expression div expression .)
    minus           reduce using rule 48 (expression -> expression div expression .)
    times           reduce using rule 48 (expression -> expression div expression .)
    div             reduce using rule 48 (expression -> expression div expression .)
    modulo          reduce using rule 48 (expression -> expression div expression .)
    lshift          reduce using rule 48 (expression -> expression div expression .)
    rshift          reduce using rule 48 (expression -> expression div expression .)
    floordiv        reduce using rule 48 (expression -> expression div expression .)
    and             reduce using rule 48 (expression -> expression div expression .)
    or              reduce using rule 48 (expression -> expression div expression .)
    xor             reduce using rule 48 (expression -> expression div expression .)
    strand          reduce using rule 48 (expression -> expression div expression .)
    stror           reduce using rule 48 (expression -> expression div expression .)
    lt              reduce using rule 48 (expression -> expression div expression .)
    gt              reduce using rule 48 (expression -> expression div expression .)
    lequal          reduce using rule 48 (expression -> expression div expression .)
    gequal          reduce using rule 48 (expression -> expression div expression .)
    isnotequal      reduce using rule 48 (expression -> expression div expression .)
    isequal         reduce using rule 48 (expression -> expression div expression .)
    newline         reduce using rule 48 (expression -> expression div expression .)
    dedent          reduce using rule 48 (expression -> expression div expression .)
    print           reduce using rule 48 (expression -> expression div expression .)
    identifier      reduce using rule 48 (expression -> expression div expression .)
    lambda          reduce using rule 48 (expression -> expression div expression .)
    invert          reduce using rule 48 (expression -> expression div expression .)
    not             reduce using rule 48 (expression -> expression div expression .)
    if              reduce using rule 48 (expression -> expression div expression .)
    while           reduce using rule 48 (expression -> expression div expression .)
    def             reduce using rule 48 (expression -> expression div expression .)
    return          reduce using rule 48 (expression -> expression div expression .)
    true            reduce using rule 48 (expression -> expression div expression .)
    false           reduce using rule 48 (expression -> expression div expression .)
    obracket        reduce using rule 48 (expression -> expression div expression .)
    integer         reduce using rule 48 (expression -> expression div expression .)
    none            reduce using rule 48 (expression -> expression div expression .)
    $end            reduce using rule 48 (expression -> expression div expression .)
    colon           reduce using rule 48 (expression -> expression div expression .)
    cparen          reduce using rule 48 (expression -> expression div expression .)
    cbracket        reduce using rule 48 (expression -> expression div expression .)
    comma           reduce using rule 48 (expression -> expression div expression .)
    oparen          shift and go to state 74
    power           shift and go to state 76

  ! oparen          [ reduce using rule 48 (expression -> expression div expression .) ]
  ! power           [ reduce using rule 48 (expression -> expression div expression .) ]
  ! plus            [ shift and go to state 82 ]
  ! minus           [ shift and go to state 77 ]
  ! times           [ shift and go to state 80 ]
  ! div             [ shift and go to state 83 ]
  ! modulo          [ shift and go to state 66 ]
  ! lshift          [ shift and go to state 68 ]
  ! rshift          [ shift and go to state 75 ]
  ! floordiv        [ shift and go to state 81 ]
  ! and             [ shift and go to state 64 ]
  ! or              [ shift and go to state 84 ]
  ! xor             [ shift and go to state 71 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 129

    (55) expression -> expression or expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    or              reduce using rule 55 (expression -> expression or expression .)
    strand          reduce using rule 55 (expression -> expression or expression .)
    stror           reduce using rule 55 (expression -> expression or expression .)
    lt              reduce using rule 55 (expression -> expression or expression .)
    gt              reduce using rule 55 (expression -> expression or expression .)
    lequal          reduce using rule 55 (expression -> expression or expression .)
    gequal          reduce using rule 55 (expression -> expression or expression .)
    isnotequal      reduce using rule 55 (expression -> expression or expression .)
    isequal         reduce using rule 55 (expression -> expression or expression .)
    newline         reduce using rule 55 (expression -> expression or expression .)
    dedent          reduce using rule 55 (expression -> expression or expression .)
    print           reduce using rule 55 (expression -> expression or expression .)
    identifier      reduce using rule 55 (expression -> expression or expression .)
    lambda          reduce using rule 55 (expression -> expression or expression .)
    invert          reduce using rule 55 (expression -> expression or expression .)
    not             reduce using rule 55 (expression -> expression or expression .)
    if              reduce using rule 55 (expression -> expression or expression .)
    while           reduce using rule 55 (expression -> expression or expression .)
    def             reduce using rule 55 (expression -> expression or expression .)
    return          reduce using rule 55 (expression -> expression or expression .)
    true            reduce using rule 55 (expression -> expression or expression .)
    false           reduce using rule 55 (expression -> expression or expression .)
    obracket        reduce using rule 55 (expression -> expression or expression .)
    integer         reduce using rule 55 (expression -> expression or expression .)
    none            reduce using rule 55 (expression -> expression or expression .)
    $end            reduce using rule 55 (expression -> expression or expression .)
    colon           reduce using rule 55 (expression -> expression or expression .)
    cparen          reduce using rule 55 (expression -> expression or expression .)
    cbracket        reduce using rule 55 (expression -> expression or expression .)
    comma           reduce using rule 55 (expression -> expression or expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    xor             shift and go to state 71

  ! oparen          [ reduce using rule 55 (expression -> expression or expression .) ]
  ! plus            [ reduce using rule 55 (expression -> expression or expression .) ]
  ! minus           [ reduce using rule 55 (expression -> expression or expression .) ]
  ! times           [ reduce using rule 55 (expression -> expression or expression .) ]
  ! div             [ reduce using rule 55 (expression -> expression or expression .) ]
  ! power           [ reduce using rule 55 (expression -> expression or expression .) ]
  ! modulo          [ reduce using rule 55 (expression -> expression or expression .) ]
  ! lshift          [ reduce using rule 55 (expression -> expression or expression .) ]
  ! rshift          [ reduce using rule 55 (expression -> expression or expression .) ]
  ! floordiv        [ reduce using rule 55 (expression -> expression or expression .) ]
  ! and             [ reduce using rule 55 (expression -> expression or expression .) ]
  ! xor             [ reduce using rule 55 (expression -> expression or expression .) ]
  ! or              [ shift and go to state 84 ]
  ! strand          [ shift and go to state 78 ]
  ! stror           [ shift and go to state 72 ]
  ! lt              [ shift and go to state 73 ]
  ! gt              [ shift and go to state 65 ]
  ! lequal          [ shift and go to state 67 ]
  ! gequal          [ shift and go to state 70 ]
  ! isnotequal      [ shift and go to state 79 ]
  ! isequal         [ shift and go to state 69 ]


state 130

    (20) compound_stmt -> def identifier oparen . id_list cparen colon suite
    (21) id_list -> .
    (22) id_list -> . identifier
    (23) id_list -> . identifier comma id_list

    cparen          reduce using rule 21 (id_list -> .)
    identifier      shift and go to state 88

    id_list                        shift and go to state 139

state 131

    (18) expression -> lambda id_list colon . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 140

state 132

    (23) id_list -> identifier comma . id_list
    (21) id_list -> .
    (22) id_list -> . identifier
    (23) id_list -> . identifier comma id_list

    colon           reduce using rule 21 (id_list -> .)
    cparen          reduce using rule 21 (id_list -> .)
    identifier      shift and go to state 88

    id_list                        shift and go to state 141

state 133

    (65) ifstmt -> if expression colon newline . indent statement_list dedent
    (66) ifstmt -> if expression colon newline . indent statement_list dedent elsestmt

    indent          shift and go to state 142


state 134

    (82) list_obj -> list_obj comma expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    cbracket        reduce using rule 82 (list_obj -> list_obj comma expression .)
    comma           reduce using rule 82 (list_obj -> list_obj comma expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 135

    (70) whilestmt -> while expression colon newline . indent statement_list dedent

    indent          shift and go to state 143


state 136

    (85) expression -> identifier obracket integer cbracket .

    oparen          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    plus            reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    minus           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    times           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    div             reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    power           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    modulo          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    lshift          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    rshift          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    floordiv        reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    and             reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    or              reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    xor             reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    strand          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    stror           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    lt              reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    gt              reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    lequal          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    gequal          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    isnotequal      reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    isequal         reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    newline         reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    dedent          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    print           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    identifier      reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    lambda          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    invert          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    not             reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    if              reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    while           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    def             reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    return          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    true            reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    false           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    obracket        reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    integer         reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    none            reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    $end            reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    colon           reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    cparen          reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    cbracket        reduce using rule 85 (expression -> identifier obracket integer cbracket .)
    comma           reduce using rule 85 (expression -> identifier obracket integer cbracket .)


state 137

    (9) parameters -> parameters comma . expression
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 144

state 138

    (17) expression -> expression oparen parameters cparen .

    oparen          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    plus            reduce using rule 17 (expression -> expression oparen parameters cparen .)
    minus           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    times           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    div             reduce using rule 17 (expression -> expression oparen parameters cparen .)
    power           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    modulo          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    lshift          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    rshift          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    floordiv        reduce using rule 17 (expression -> expression oparen parameters cparen .)
    and             reduce using rule 17 (expression -> expression oparen parameters cparen .)
    or              reduce using rule 17 (expression -> expression oparen parameters cparen .)
    xor             reduce using rule 17 (expression -> expression oparen parameters cparen .)
    strand          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    stror           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    lt              reduce using rule 17 (expression -> expression oparen parameters cparen .)
    gt              reduce using rule 17 (expression -> expression oparen parameters cparen .)
    lequal          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    gequal          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    isnotequal      reduce using rule 17 (expression -> expression oparen parameters cparen .)
    isequal         reduce using rule 17 (expression -> expression oparen parameters cparen .)
    newline         reduce using rule 17 (expression -> expression oparen parameters cparen .)
    dedent          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    print           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    identifier      reduce using rule 17 (expression -> expression oparen parameters cparen .)
    lambda          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    invert          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    not             reduce using rule 17 (expression -> expression oparen parameters cparen .)
    if              reduce using rule 17 (expression -> expression oparen parameters cparen .)
    while           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    def             reduce using rule 17 (expression -> expression oparen parameters cparen .)
    return          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    true            reduce using rule 17 (expression -> expression oparen parameters cparen .)
    false           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    obracket        reduce using rule 17 (expression -> expression oparen parameters cparen .)
    integer         reduce using rule 17 (expression -> expression oparen parameters cparen .)
    none            reduce using rule 17 (expression -> expression oparen parameters cparen .)
    $end            reduce using rule 17 (expression -> expression oparen parameters cparen .)
    colon           reduce using rule 17 (expression -> expression oparen parameters cparen .)
    cparen          reduce using rule 17 (expression -> expression oparen parameters cparen .)
    cbracket        reduce using rule 17 (expression -> expression oparen parameters cparen .)
    comma           reduce using rule 17 (expression -> expression oparen parameters cparen .)


state 139

    (20) compound_stmt -> def identifier oparen id_list . cparen colon suite

    cparen          shift and go to state 145


state 140

    (18) expression -> lambda id_list colon expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

  ! shift/reduce conflict for oparen resolved as shift
  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
  ! shift/reduce conflict for strand resolved as shift
  ! shift/reduce conflict for stror resolved as shift
  ! shift/reduce conflict for lt resolved as shift
  ! shift/reduce conflict for gt resolved as shift
  ! shift/reduce conflict for lequal resolved as shift
  ! shift/reduce conflict for gequal resolved as shift
  ! shift/reduce conflict for isnotequal resolved as shift
  ! shift/reduce conflict for isequal resolved as shift
    newline         reduce using rule 18 (expression -> lambda id_list colon expression .)
    dedent          reduce using rule 18 (expression -> lambda id_list colon expression .)
    print           reduce using rule 18 (expression -> lambda id_list colon expression .)
    identifier      reduce using rule 18 (expression -> lambda id_list colon expression .)
    lambda          reduce using rule 18 (expression -> lambda id_list colon expression .)
    invert          reduce using rule 18 (expression -> lambda id_list colon expression .)
    not             reduce using rule 18 (expression -> lambda id_list colon expression .)
    if              reduce using rule 18 (expression -> lambda id_list colon expression .)
    while           reduce using rule 18 (expression -> lambda id_list colon expression .)
    def             reduce using rule 18 (expression -> lambda id_list colon expression .)
    return          reduce using rule 18 (expression -> lambda id_list colon expression .)
    true            reduce using rule 18 (expression -> lambda id_list colon expression .)
    false           reduce using rule 18 (expression -> lambda id_list colon expression .)
    obracket        reduce using rule 18 (expression -> lambda id_list colon expression .)
    integer         reduce using rule 18 (expression -> lambda id_list colon expression .)
    none            reduce using rule 18 (expression -> lambda id_list colon expression .)
    $end            reduce using rule 18 (expression -> lambda id_list colon expression .)
    colon           reduce using rule 18 (expression -> lambda id_list colon expression .)
    cparen          reduce using rule 18 (expression -> lambda id_list colon expression .)
    cbracket        reduce using rule 18 (expression -> lambda id_list colon expression .)
    comma           reduce using rule 18 (expression -> lambda id_list colon expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69

  ! oparen          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! plus            [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! minus           [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! times           [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! div             [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! power           [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! modulo          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! lshift          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! rshift          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! floordiv        [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! and             [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! or              [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! xor             [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! strand          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! stror           [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! lt              [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! gt              [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! lequal          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! gequal          [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! isnotequal      [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]
  ! isequal         [ reduce using rule 18 (expression -> lambda id_list colon expression .) ]


state 141

    (23) id_list -> identifier comma id_list .

    colon           reduce using rule 23 (id_list -> identifier comma id_list .)
    cparen          reduce using rule 23 (id_list -> identifier comma id_list .)


state 142

    (65) ifstmt -> if expression colon newline indent . statement_list dedent
    (66) ifstmt -> if expression colon newline indent . statement_list dedent elsestmt
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    ifstmt                         shift and go to state 7
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 12
    statement_list                 shift and go to state 146
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    compound_stmt                  shift and go to state 15

state 143

    (70) whilestmt -> while expression colon newline indent . statement_list dedent
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 12
    statement_list                 shift and go to state 147
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 144

    (9) parameters -> parameters comma expression .
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    cparen          reduce using rule 9 (parameters -> parameters comma expression .)
    comma           reduce using rule 9 (parameters -> parameters comma expression .)
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 145

    (20) compound_stmt -> def identifier oparen id_list cparen . colon suite

    colon           shift and go to state 148


state 146

    (65) ifstmt -> if expression colon newline indent statement_list . dedent
    (66) ifstmt -> if expression colon newline indent statement_list . dedent elsestmt
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    dedent          shift and go to state 149
    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    ifstmt                         shift and go to state 7
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 62
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    compound_stmt                  shift and go to state 15

state 147

    (70) whilestmt -> while expression colon newline indent statement_list . dedent
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    dedent          shift and go to state 150
    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 62
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 148

    (20) compound_stmt -> def identifier oparen id_list cparen colon . suite
    (24) suite -> . newline indent statement_list dedent

    newline         shift and go to state 151

    suite                          shift and go to state 152

state 149

    (65) ifstmt -> if expression colon newline indent statement_list dedent .
    (66) ifstmt -> if expression colon newline indent statement_list dedent . elsestmt
    (67) elsestmt -> . else colon newline indent statement_list dedent
    (68) elsestmt -> . elif expression colon newline indent statement_list dedent
    (69) elsestmt -> . elif expression colon newline indent statement_list dedent elsestmt

    newline         reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    dedent          reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    print           reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    identifier      reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    lambda          reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    minus           reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    plus            reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    invert          reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    oparen          reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    not             reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    if              reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    while           reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    def             reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    return          reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    true            reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    false           reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    obracket        reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    integer         reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    none            reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    $end            reduce using rule 65 (ifstmt -> if expression colon newline indent statement_list dedent .)
    else            shift and go to state 154
    elif            shift and go to state 153

    elsestmt                       shift and go to state 155

state 150

    (70) whilestmt -> while expression colon newline indent statement_list dedent .

    newline         reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    dedent          reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    print           reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    identifier      reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    lambda          reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    minus           reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    plus            reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    invert          reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    oparen          reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    not             reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    if              reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    while           reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    def             reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    return          reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    true            reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    false           reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    obracket        reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    integer         reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    none            reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)
    $end            reduce using rule 70 (whilestmt -> while expression colon newline indent statement_list dedent .)


state 151

    (24) suite -> newline . indent statement_list dedent

    indent          shift and go to state 156


state 152

    (20) compound_stmt -> def identifier oparen id_list cparen colon suite .

    newline         reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    dedent          reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    print           reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    identifier      reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    lambda          reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    minus           reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    plus            reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    invert          reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    oparen          reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    not             reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    if              reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    while           reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    def             reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    return          reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    true            reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    false           reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    obracket        reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    integer         reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    none            reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)
    $end            reduce using rule 20 (compound_stmt -> def identifier oparen id_list cparen colon suite .)


state 153

    (68) elsestmt -> elif . expression colon newline indent statement_list dedent
    (69) elsestmt -> elif . expression colon newline indent statement_list dedent elsestmt
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (76) name -> . identifier
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    identifier      shift and go to state 36
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 35
    list                           shift and go to state 26
    boolean                        shift and go to state 5
    noval                          shift and go to state 1
    expression0                    shift and go to state 21
    expression                     shift and go to state 157

state 154

    (67) elsestmt -> else . colon newline indent statement_list dedent

    colon           shift and go to state 158


state 155

    (66) ifstmt -> if expression colon newline indent statement_list dedent elsestmt .

    newline         reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    dedent          reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    print           reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    identifier      reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    lambda          reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    minus           reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    plus            reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    invert          reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    oparen          reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    not             reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    if              reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    while           reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    def             reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    return          reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    true            reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    false           reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    obracket        reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    integer         reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    none            reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    $end            reduce using rule 66 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)


state 156

    (24) suite -> newline indent . statement_list dedent
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 12
    statement_list                 shift and go to state 159
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 157

    (68) elsestmt -> elif expression . colon newline indent statement_list dedent
    (69) elsestmt -> elif expression . colon newline indent statement_list dedent elsestmt
    (17) expression -> expression . oparen parameters cparen
    (45) expression -> expression . plus expression
    (46) expression -> expression . minus expression
    (47) expression -> expression . times expression
    (48) expression -> expression . div expression
    (49) expression -> expression . power expression
    (50) expression -> expression . modulo expression
    (51) expression -> expression . lshift expression
    (52) expression -> expression . rshift expression
    (53) expression -> expression . floordiv expression
    (54) expression -> expression . and expression
    (55) expression -> expression . or expression
    (56) expression -> expression . xor expression
    (57) expression -> expression . strand expression
    (58) expression -> expression . stror expression
    (59) expression -> expression . lt expression
    (60) expression -> expression . gt expression
    (61) expression -> expression . lequal expression
    (62) expression -> expression . gequal expression
    (63) expression -> expression . isnotequal expression
    (64) expression -> expression . isequal expression

    colon           shift and go to state 160
    oparen          shift and go to state 74
    plus            shift and go to state 82
    minus           shift and go to state 77
    times           shift and go to state 80
    div             shift and go to state 83
    power           shift and go to state 76
    modulo          shift and go to state 66
    lshift          shift and go to state 68
    rshift          shift and go to state 75
    floordiv        shift and go to state 81
    and             shift and go to state 64
    or              shift and go to state 84
    xor             shift and go to state 71
    strand          shift and go to state 78
    stror           shift and go to state 72
    lt              shift and go to state 73
    gt              shift and go to state 65
    lequal          shift and go to state 67
    gequal          shift and go to state 70
    isnotequal      shift and go to state 79
    isequal         shift and go to state 69


state 158

    (67) elsestmt -> else colon . newline indent statement_list dedent

    newline         shift and go to state 161


state 159

    (24) suite -> newline indent statement_list . dedent
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    dedent          shift and go to state 162
    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 62
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 160

    (68) elsestmt -> elif expression colon . newline indent statement_list dedent
    (69) elsestmt -> elif expression colon . newline indent statement_list dedent elsestmt

    newline         shift and go to state 163


state 161

    (67) elsestmt -> else colon newline . indent statement_list dedent

    indent          shift and go to state 164


state 162

    (24) suite -> newline indent statement_list dedent .

    newline         reduce using rule 24 (suite -> newline indent statement_list dedent .)
    print           reduce using rule 24 (suite -> newline indent statement_list dedent .)
    identifier      reduce using rule 24 (suite -> newline indent statement_list dedent .)
    lambda          reduce using rule 24 (suite -> newline indent statement_list dedent .)
    minus           reduce using rule 24 (suite -> newline indent statement_list dedent .)
    plus            reduce using rule 24 (suite -> newline indent statement_list dedent .)
    invert          reduce using rule 24 (suite -> newline indent statement_list dedent .)
    oparen          reduce using rule 24 (suite -> newline indent statement_list dedent .)
    not             reduce using rule 24 (suite -> newline indent statement_list dedent .)
    if              reduce using rule 24 (suite -> newline indent statement_list dedent .)
    while           reduce using rule 24 (suite -> newline indent statement_list dedent .)
    def             reduce using rule 24 (suite -> newline indent statement_list dedent .)
    return          reduce using rule 24 (suite -> newline indent statement_list dedent .)
    true            reduce using rule 24 (suite -> newline indent statement_list dedent .)
    false           reduce using rule 24 (suite -> newline indent statement_list dedent .)
    obracket        reduce using rule 24 (suite -> newline indent statement_list dedent .)
    integer         reduce using rule 24 (suite -> newline indent statement_list dedent .)
    none            reduce using rule 24 (suite -> newline indent statement_list dedent .)
    $end            reduce using rule 24 (suite -> newline indent statement_list dedent .)
    dedent          reduce using rule 24 (suite -> newline indent statement_list dedent .)


state 163

    (68) elsestmt -> elif expression colon newline . indent statement_list dedent
    (69) elsestmt -> elif expression colon newline . indent statement_list dedent elsestmt

    indent          shift and go to state 165


state 164

    (67) elsestmt -> else colon newline indent . statement_list dedent
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 12
    statement_list                 shift and go to state 166
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 165

    (68) elsestmt -> elif expression colon newline indent . statement_list dedent
    (69) elsestmt -> elif expression colon newline indent . statement_list dedent elsestmt
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    ifstmt                         shift and go to state 7
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 12
    statement_list                 shift and go to state 167
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    compound_stmt                  shift and go to state 15

state 166

    (67) elsestmt -> else colon newline indent statement_list . dedent
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    dedent          shift and go to state 168
    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    compound_stmt                  shift and go to state 15
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 62
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    ifstmt                         shift and go to state 7

state 167

    (68) elsestmt -> elif expression colon newline indent statement_list . dedent
    (69) elsestmt -> elif expression colon newline indent statement_list . dedent elsestmt
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (11) statement -> . assname equals expression
    (12) statement -> . expression
    (13) statement -> . ifstmt
    (14) statement -> . whilestmt
    (15) statement -> . compound_stmt
    (16) statement -> . simple_statement
    (25) statement -> . name incassign expression
    (26) statement -> . name decassign expression
    (27) statement -> . name divassign expression
    (28) statement -> . name mulassign expression
    (29) statement -> . name modassign expression
    (30) statement -> . name lshiftassign expression
    (31) statement -> . name rshiftassign expression
    (32) statement -> . name andassign expression
    (33) statement -> . name orassign expression
    (34) statement -> . name xorassign expression
    (35) statement -> . name powerassign expression
    (36) statement -> . name floorassign expression
    (75) assname -> . identifier
    (17) expression -> . expression oparen parameters cparen
    (18) expression -> . lambda id_list colon expression
    (37) expression -> . boolean
    (38) expression -> . minus expression
    (39) expression -> . plus expression
    (40) expression -> . invert expression
    (41) expression -> . expression0
    (42) expression -> . oparen expression cparen
    (43) expression -> . not expression
    (44) expression -> . name
    (45) expression -> . expression plus expression
    (46) expression -> . expression minus expression
    (47) expression -> . expression times expression
    (48) expression -> . expression div expression
    (49) expression -> . expression power expression
    (50) expression -> . expression modulo expression
    (51) expression -> . expression lshift expression
    (52) expression -> . expression rshift expression
    (53) expression -> . expression floordiv expression
    (54) expression -> . expression and expression
    (55) expression -> . expression or expression
    (56) expression -> . expression xor expression
    (57) expression -> . expression strand expression
    (58) expression -> . expression stror expression
    (59) expression -> . expression lt expression
    (60) expression -> . expression gt expression
    (61) expression -> . expression lequal expression
    (62) expression -> . expression gequal expression
    (63) expression -> . expression isnotequal expression
    (64) expression -> . expression isequal expression
    (83) expression -> . list
    (85) expression -> . identifier obracket integer cbracket
    (65) ifstmt -> . if expression colon newline indent statement_list dedent
    (66) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (70) whilestmt -> . while expression colon newline indent statement_list dedent
    (20) compound_stmt -> . def identifier oparen id_list cparen colon suite
    (19) simple_statement -> . return expression
    (76) name -> . identifier
    (78) boolean -> . true
    (79) boolean -> . false
    (71) expression0 -> . num
    (72) expression0 -> . name
    (73) expression0 -> . noval
    (84) list -> . obracket list_obj cbracket
    (74) num -> . integer
    (77) noval -> . none

    dedent          shift and go to state 169
    newline         shift and go to state 17
    print           shift and go to state 14
    identifier      shift and go to state 30
    lambda          shift and go to state 34
    minus           shift and go to state 32
    plus            shift and go to state 28
    invert          shift and go to state 11
    oparen          shift and go to state 13
    not             shift and go to state 20
    if              shift and go to state 9
    while           shift and go to state 27
    def             shift and go to state 33
    return          shift and go to state 6
    true            shift and go to state 22
    false           shift and go to state 8
    obracket        shift and go to state 25
    integer         shift and go to state 16
    none            shift and go to state 23

    num                            shift and go to state 10
    name                           shift and go to state 24
    list                           shift and go to state 26
    noval                          shift and go to state 1
    simple_statement               shift and go to state 2
    ifstmt                         shift and go to state 7
    whilestmt                      shift and go to state 4
    assname                        shift and go to state 19
    boolean                        shift and go to state 5
    statement                      shift and go to state 62
    expression0                    shift and go to state 21
    expression                     shift and go to state 31
    compound_stmt                  shift and go to state 15

state 168

    (67) elsestmt -> else colon newline indent statement_list dedent .

    newline         reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    print           reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    identifier      reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    lambda          reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    minus           reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    plus            reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    invert          reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    oparen          reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    not             reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    if              reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    while           reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    def             reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    return          reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    true            reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    false           reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    obracket        reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    integer         reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    none            reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    $end            reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)
    dedent          reduce using rule 67 (elsestmt -> else colon newline indent statement_list dedent .)


state 169

    (68) elsestmt -> elif expression colon newline indent statement_list dedent .
    (69) elsestmt -> elif expression colon newline indent statement_list dedent . elsestmt
    (67) elsestmt -> . else colon newline indent statement_list dedent
    (68) elsestmt -> . elif expression colon newline indent statement_list dedent
    (69) elsestmt -> . elif expression colon newline indent statement_list dedent elsestmt

    newline         reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    print           reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    identifier      reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    lambda          reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    minus           reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    plus            reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    invert          reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    oparen          reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    not             reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    if              reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    while           reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    def             reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    return          reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    true            reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    false           reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    obracket        reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    integer         reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    none            reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    $end            reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    dedent          reduce using rule 68 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    else            shift and go to state 154
    elif            shift and go to state 153

    elsestmt                       shift and go to state 170

state 170

    (69) elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .

    newline         reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    print           reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    identifier      reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    lambda          reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    minus           reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    plus            reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    invert          reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    oparen          reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    not             reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    if              reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    while           reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    def             reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    return          reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    true            reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    false           reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    obracket        reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    integer         reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    none            reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    $end            reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    dedent          reduce using rule 69 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for newline in state 12 resolved as shift
WARNING: shift/reduce conflict for obracket in state 30 resolved as shift
WARNING: shift/reduce conflict for oparen in state 31 resolved as shift
WARNING: shift/reduce conflict for plus in state 31 resolved as shift
WARNING: shift/reduce conflict for minus in state 31 resolved as shift
WARNING: shift/reduce conflict for obracket in state 36 resolved as shift
WARNING: shift/reduce conflict for oparen in state 37 resolved as shift
WARNING: shift/reduce conflict for plus in state 37 resolved as shift
WARNING: shift/reduce conflict for minus in state 37 resolved as shift
WARNING: shift/reduce conflict for newline in state 43 resolved as shift
WARNING: shift/reduce conflict for newline in state 62 resolved as shift
WARNING: shift/reduce conflict for oparen in state 91 resolved as shift
WARNING: shift/reduce conflict for plus in state 91 resolved as shift
WARNING: shift/reduce conflict for minus in state 91 resolved as shift
WARNING: shift/reduce conflict for oparen in state 92 resolved as shift
WARNING: shift/reduce conflict for plus in state 92 resolved as shift
WARNING: shift/reduce conflict for minus in state 92 resolved as shift
WARNING: shift/reduce conflict for oparen in state 93 resolved as shift
WARNING: shift/reduce conflict for plus in state 93 resolved as shift
WARNING: shift/reduce conflict for minus in state 93 resolved as shift
WARNING: shift/reduce conflict for oparen in state 94 resolved as shift
WARNING: shift/reduce conflict for plus in state 94 resolved as shift
WARNING: shift/reduce conflict for minus in state 94 resolved as shift
WARNING: shift/reduce conflict for oparen in state 95 resolved as shift
WARNING: shift/reduce conflict for plus in state 95 resolved as shift
WARNING: shift/reduce conflict for minus in state 95 resolved as shift
WARNING: shift/reduce conflict for oparen in state 96 resolved as shift
WARNING: shift/reduce conflict for plus in state 96 resolved as shift
WARNING: shift/reduce conflict for minus in state 96 resolved as shift
WARNING: shift/reduce conflict for oparen in state 97 resolved as shift
WARNING: shift/reduce conflict for plus in state 97 resolved as shift
WARNING: shift/reduce conflict for minus in state 97 resolved as shift
WARNING: shift/reduce conflict for oparen in state 98 resolved as shift
WARNING: shift/reduce conflict for plus in state 98 resolved as shift
WARNING: shift/reduce conflict for minus in state 98 resolved as shift
WARNING: shift/reduce conflict for oparen in state 99 resolved as shift
WARNING: shift/reduce conflict for plus in state 99 resolved as shift
WARNING: shift/reduce conflict for minus in state 99 resolved as shift
WARNING: shift/reduce conflict for oparen in state 100 resolved as shift
WARNING: shift/reduce conflict for plus in state 100 resolved as shift
WARNING: shift/reduce conflict for minus in state 100 resolved as shift
WARNING: shift/reduce conflict for oparen in state 101 resolved as shift
WARNING: shift/reduce conflict for plus in state 101 resolved as shift
WARNING: shift/reduce conflict for minus in state 101 resolved as shift
WARNING: shift/reduce conflict for oparen in state 102 resolved as shift
WARNING: shift/reduce conflict for plus in state 102 resolved as shift
WARNING: shift/reduce conflict for minus in state 102 resolved as shift
WARNING: shift/reduce conflict for oparen in state 103 resolved as shift
WARNING: shift/reduce conflict for plus in state 103 resolved as shift
WARNING: shift/reduce conflict for minus in state 103 resolved as shift
WARNING: shift/reduce conflict for oparen in state 140 resolved as shift
WARNING: shift/reduce conflict for plus in state 140 resolved as shift
WARNING: shift/reduce conflict for minus in state 140 resolved as shift
WARNING: shift/reduce conflict for times in state 140 resolved as shift
WARNING: shift/reduce conflict for div in state 140 resolved as shift
WARNING: shift/reduce conflict for power in state 140 resolved as shift
WARNING: shift/reduce conflict for modulo in state 140 resolved as shift
WARNING: shift/reduce conflict for lshift in state 140 resolved as shift
WARNING: shift/reduce conflict for rshift in state 140 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 140 resolved as shift
WARNING: shift/reduce conflict for and in state 140 resolved as shift
WARNING: shift/reduce conflict for or in state 140 resolved as shift
WARNING: shift/reduce conflict for xor in state 140 resolved as shift
WARNING: shift/reduce conflict for strand in state 140 resolved as shift
WARNING: shift/reduce conflict for stror in state 140 resolved as shift
WARNING: shift/reduce conflict for lt in state 140 resolved as shift
WARNING: shift/reduce conflict for gt in state 140 resolved as shift
WARNING: shift/reduce conflict for lequal in state 140 resolved as shift
WARNING: shift/reduce conflict for gequal in state 140 resolved as shift
WARNING: shift/reduce conflict for isnotequal in state 140 resolved as shift
WARNING: shift/reduce conflict for isequal in state 140 resolved as shift
WARNING: reduce/reduce conflict in state 24 resolved using rule (expression -> name)
WARNING: rejected rule (expression0 -> name) in state 24
WARNING: reduce/reduce conflict in state 35 resolved using rule (expression -> name)
WARNING: rejected rule (expression0 -> name) in state 35
WARNING: Rule (expression0 -> name) is never reduced
