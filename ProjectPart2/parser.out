Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    comment
    gt
    obracket
    lt
    usub
    uadd
    ocurly
    dedent
    rparen
    string
    lparen
    ccurly
    indent
    cbracket

Grammar

Rule 0     S' -> module
Rule 1     module -> stmt
Rule 2     stmt -> statement_list
Rule 3     statement_list -> statement
Rule 4     statement_list -> statement_list newline statement
Rule 5     statement -> print expression
Rule 6     statement -> print name
Rule 7     expression -> input oparen parameters cparen
Rule 8     parameters -> expression
Rule 9     parameters -> parameters comma expression
Rule 10    parameters -> <empty>
Rule 11    statement -> expression
Rule 12    statement -> assname equals expression
Rule 13    expression -> minus num
Rule 14    expression -> minus oparen expression cparen
Rule 15    expression -> plus num
Rule 16    expression -> plus oparen expression cparen
Rule 17    expression -> invert num
Rule 18    expression -> invert oparen expression cparen
Rule 19    statement -> name incassign expression
Rule 20    statement -> name decassign expression
Rule 21    statement -> name divassign expression
Rule 22    statement -> name mulassign expression
Rule 23    statement -> name modassign expression
Rule 24    statement -> name lshiftassign expression
Rule 25    statement -> name rshiftassign expression
Rule 26    statement -> name andassign expression
Rule 27    statement -> name orassign expression
Rule 28    statement -> name xorassign expression
Rule 29    statement -> name powerassign expression
Rule 30    expression -> expression plus expression
Rule 31    expression -> expression minus expression
Rule 32    expression -> expression times expression
Rule 33    expression -> expression div expression
Rule 34    expression -> expression power expression
Rule 35    expression -> expression modulo expression
Rule 36    expression -> expression lshift expression
Rule 37    expression -> expression rshift expression
Rule 38    expression -> expression floordiv expression
Rule 39    expression -> expression and expression
Rule 40    expression -> expression or expression
Rule 41    expression -> expression xor expression
Rule 42    expression -> num
Rule 43    num -> integer
Rule 44    expression -> name
Rule 45    assname -> identifier
Rule 46    name -> identifier

Terminals, with rules where they appear

and                  : 39
andassign            : 26
cbracket             : 
ccurly               : 
comma                : 9
comment              : 
cparen               : 7 14 16 18
decassign            : 20
dedent               : 
div                  : 33
divassign            : 21
equals               : 12
error                : 
floordiv             : 38
gt                   : 
identifier           : 45 46
incassign            : 19
indent               : 
input                : 7
integer              : 43
invert               : 17 18
lparen               : 
lshift               : 36
lshiftassign         : 24
lt                   : 
minus                : 13 14 31
modassign            : 23
modulo               : 35
mulassign            : 22
newline              : 4
obracket             : 
ocurly               : 
oparen               : 7 14 16 18
or                   : 40
orassign             : 27
plus                 : 15 16 30
power                : 34
powerassign          : 29
print                : 5 6
rparen               : 
rshift               : 37
rshiftassign         : 25
string               : 
times                : 32
uadd                 : 
usub                 : 
xor                  : 41
xorassign            : 28

Nonterminals, with rules where they appear

assname              : 12
expression           : 5 8 9 11 12 14 16 18 19 20 21 22 23 24 25 26 27 28 29 30 30 31 31 32 32 33 33 34 34 35 35 36 36 37 37 38 38 39 39 40 40 41 41
module               : 0
name                 : 6 19 20 21 22 23 24 25 26 27 28 29 44
num                  : 13 15 17 42
parameters           : 7 9
statement            : 3 4
statement_list       : 2 4
stmt                 : 1

Parsing method: LALR

state 0

    (0) S' -> . module
    (1) module -> . stmt
    (2) stmt -> . statement_list
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list newline statement
    (5) statement -> . print expression
    (6) statement -> . print name
    (11) statement -> . expression
    (12) statement -> . assname equals expression
    (19) statement -> . name incassign expression
    (20) statement -> . name decassign expression
    (21) statement -> . name divassign expression
    (22) statement -> . name mulassign expression
    (23) statement -> . name modassign expression
    (24) statement -> . name lshiftassign expression
    (25) statement -> . name rshiftassign expression
    (26) statement -> . name andassign expression
    (27) statement -> . name orassign expression
    (28) statement -> . name xorassign expression
    (29) statement -> . name powerassign expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (45) assname -> . identifier
    (46) name -> . identifier
    (43) num -> . integer

    print           shift and go to state 5
    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    identifier      shift and go to state 13
    integer         shift and go to state 9

    name                           shift and go to state 10
    stmt                           shift and go to state 7
    assname                        shift and go to state 8
    num                            shift and go to state 2
    module                         shift and go to state 1
    statement                      shift and go to state 4
    statement_list                 shift and go to state 12
    expression                     shift and go to state 14

state 1

    (0) S' -> module .



state 2

    (42) expression -> num .

    plus            reduce using rule 42 (expression -> num .)
    minus           reduce using rule 42 (expression -> num .)
    times           reduce using rule 42 (expression -> num .)
    div             reduce using rule 42 (expression -> num .)
    power           reduce using rule 42 (expression -> num .)
    modulo          reduce using rule 42 (expression -> num .)
    lshift          reduce using rule 42 (expression -> num .)
    rshift          reduce using rule 42 (expression -> num .)
    floordiv        reduce using rule 42 (expression -> num .)
    and             reduce using rule 42 (expression -> num .)
    or              reduce using rule 42 (expression -> num .)
    xor             reduce using rule 42 (expression -> num .)
    newline         reduce using rule 42 (expression -> num .)
    $end            reduce using rule 42 (expression -> num .)
    cparen          reduce using rule 42 (expression -> num .)
    comma           reduce using rule 42 (expression -> num .)


state 3

    (17) expression -> invert . num
    (18) expression -> invert . oparen expression cparen
    (43) num -> . integer

    oparen          shift and go to state 17
    integer         shift and go to state 9

    num                            shift and go to state 16

state 4

    (3) statement_list -> statement .

    newline         reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)


state 5

    (5) statement -> print . expression
    (6) statement -> print . name
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (46) name -> . identifier
    (43) num -> . integer

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    identifier      shift and go to state 19
    integer         shift and go to state 9

    num                            shift and go to state 2
    expression                     shift and go to state 20
    name                           shift and go to state 18

state 6

    (7) expression -> input . oparen parameters cparen

    oparen          shift and go to state 21


state 7

    (1) module -> stmt .

    $end            reduce using rule 1 (module -> stmt .)


state 8

    (12) statement -> assname . equals expression

    equals          shift and go to state 22


state 9

    (43) num -> integer .

    plus            reduce using rule 43 (num -> integer .)
    minus           reduce using rule 43 (num -> integer .)
    times           reduce using rule 43 (num -> integer .)
    div             reduce using rule 43 (num -> integer .)
    power           reduce using rule 43 (num -> integer .)
    modulo          reduce using rule 43 (num -> integer .)
    lshift          reduce using rule 43 (num -> integer .)
    rshift          reduce using rule 43 (num -> integer .)
    floordiv        reduce using rule 43 (num -> integer .)
    and             reduce using rule 43 (num -> integer .)
    or              reduce using rule 43 (num -> integer .)
    xor             reduce using rule 43 (num -> integer .)
    newline         reduce using rule 43 (num -> integer .)
    $end            reduce using rule 43 (num -> integer .)
    cparen          reduce using rule 43 (num -> integer .)
    comma           reduce using rule 43 (num -> integer .)


state 10

    (19) statement -> name . incassign expression
    (20) statement -> name . decassign expression
    (21) statement -> name . divassign expression
    (22) statement -> name . mulassign expression
    (23) statement -> name . modassign expression
    (24) statement -> name . lshiftassign expression
    (25) statement -> name . rshiftassign expression
    (26) statement -> name . andassign expression
    (27) statement -> name . orassign expression
    (28) statement -> name . xorassign expression
    (29) statement -> name . powerassign expression
    (44) expression -> name .

    incassign       shift and go to state 27
    decassign       shift and go to state 32
    divassign       shift and go to state 28
    mulassign       shift and go to state 29
    modassign       shift and go to state 30
    lshiftassign    shift and go to state 24
    rshiftassign    shift and go to state 25
    andassign       shift and go to state 31
    orassign        shift and go to state 23
    xorassign       shift and go to state 33
    powerassign     shift and go to state 26
    plus            reduce using rule 44 (expression -> name .)
    minus           reduce using rule 44 (expression -> name .)
    times           reduce using rule 44 (expression -> name .)
    div             reduce using rule 44 (expression -> name .)
    power           reduce using rule 44 (expression -> name .)
    modulo          reduce using rule 44 (expression -> name .)
    lshift          reduce using rule 44 (expression -> name .)
    rshift          reduce using rule 44 (expression -> name .)
    floordiv        reduce using rule 44 (expression -> name .)
    and             reduce using rule 44 (expression -> name .)
    or              reduce using rule 44 (expression -> name .)
    xor             reduce using rule 44 (expression -> name .)
    newline         reduce using rule 44 (expression -> name .)
    $end            reduce using rule 44 (expression -> name .)


state 11

    (15) expression -> plus . num
    (16) expression -> plus . oparen expression cparen
    (43) num -> . integer

    oparen          shift and go to state 35
    integer         shift and go to state 9

    num                            shift and go to state 34

state 12

    (2) stmt -> statement_list .
    (4) statement_list -> statement_list . newline statement

    $end            reduce using rule 2 (stmt -> statement_list .)
    newline         shift and go to state 36


state 13

    (45) assname -> identifier .
    (46) name -> identifier .

    equals          reduce using rule 45 (assname -> identifier .)
    incassign       reduce using rule 46 (name -> identifier .)
    decassign       reduce using rule 46 (name -> identifier .)
    divassign       reduce using rule 46 (name -> identifier .)
    mulassign       reduce using rule 46 (name -> identifier .)
    modassign       reduce using rule 46 (name -> identifier .)
    lshiftassign    reduce using rule 46 (name -> identifier .)
    rshiftassign    reduce using rule 46 (name -> identifier .)
    andassign       reduce using rule 46 (name -> identifier .)
    orassign        reduce using rule 46 (name -> identifier .)
    xorassign       reduce using rule 46 (name -> identifier .)
    powerassign     reduce using rule 46 (name -> identifier .)
    plus            reduce using rule 46 (name -> identifier .)
    minus           reduce using rule 46 (name -> identifier .)
    times           reduce using rule 46 (name -> identifier .)
    div             reduce using rule 46 (name -> identifier .)
    power           reduce using rule 46 (name -> identifier .)
    modulo          reduce using rule 46 (name -> identifier .)
    lshift          reduce using rule 46 (name -> identifier .)
    rshift          reduce using rule 46 (name -> identifier .)
    floordiv        reduce using rule 46 (name -> identifier .)
    and             reduce using rule 46 (name -> identifier .)
    or              reduce using rule 46 (name -> identifier .)
    xor             reduce using rule 46 (name -> identifier .)
    newline         reduce using rule 46 (name -> identifier .)
    $end            reduce using rule 46 (name -> identifier .)


state 14

    (11) statement -> expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 11 (statement -> expression .)
    $end            reduce using rule 11 (statement -> expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 15

    (13) expression -> minus . num
    (14) expression -> minus . oparen expression cparen
    (43) num -> . integer

    oparen          shift and go to state 50
    integer         shift and go to state 9

    num                            shift and go to state 49

state 16

    (17) expression -> invert num .

    plus            reduce using rule 17 (expression -> invert num .)
    minus           reduce using rule 17 (expression -> invert num .)
    times           reduce using rule 17 (expression -> invert num .)
    div             reduce using rule 17 (expression -> invert num .)
    power           reduce using rule 17 (expression -> invert num .)
    modulo          reduce using rule 17 (expression -> invert num .)
    lshift          reduce using rule 17 (expression -> invert num .)
    rshift          reduce using rule 17 (expression -> invert num .)
    floordiv        reduce using rule 17 (expression -> invert num .)
    and             reduce using rule 17 (expression -> invert num .)
    or              reduce using rule 17 (expression -> invert num .)
    xor             reduce using rule 17 (expression -> invert num .)
    newline         reduce using rule 17 (expression -> invert num .)
    $end            reduce using rule 17 (expression -> invert num .)
    cparen          reduce using rule 17 (expression -> invert num .)
    comma           reduce using rule 17 (expression -> invert num .)


state 17

    (18) expression -> invert oparen . expression cparen
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 52
    name                           shift and go to state 51

state 18

    (6) statement -> print name .
    (44) expression -> name .

  ! reduce/reduce conflict for newline resolved using rule 6 (statement -> print name .)
  ! reduce/reduce conflict for $end resolved using rule 6 (statement -> print name .)
    newline         reduce using rule 6 (statement -> print name .)
    $end            reduce using rule 6 (statement -> print name .)
    plus            reduce using rule 44 (expression -> name .)
    minus           reduce using rule 44 (expression -> name .)
    times           reduce using rule 44 (expression -> name .)
    div             reduce using rule 44 (expression -> name .)
    power           reduce using rule 44 (expression -> name .)
    modulo          reduce using rule 44 (expression -> name .)
    lshift          reduce using rule 44 (expression -> name .)
    rshift          reduce using rule 44 (expression -> name .)
    floordiv        reduce using rule 44 (expression -> name .)
    and             reduce using rule 44 (expression -> name .)
    or              reduce using rule 44 (expression -> name .)
    xor             reduce using rule 44 (expression -> name .)

  ! newline         [ reduce using rule 44 (expression -> name .) ]
  ! $end            [ reduce using rule 44 (expression -> name .) ]


state 19

    (46) name -> identifier .

    cparen          reduce using rule 46 (name -> identifier .)
    plus            reduce using rule 46 (name -> identifier .)
    minus           reduce using rule 46 (name -> identifier .)
    times           reduce using rule 46 (name -> identifier .)
    div             reduce using rule 46 (name -> identifier .)
    power           reduce using rule 46 (name -> identifier .)
    modulo          reduce using rule 46 (name -> identifier .)
    lshift          reduce using rule 46 (name -> identifier .)
    rshift          reduce using rule 46 (name -> identifier .)
    floordiv        reduce using rule 46 (name -> identifier .)
    and             reduce using rule 46 (name -> identifier .)
    or              reduce using rule 46 (name -> identifier .)
    xor             reduce using rule 46 (name -> identifier .)
    newline         reduce using rule 46 (name -> identifier .)
    $end            reduce using rule 46 (name -> identifier .)
    comma           reduce using rule 46 (name -> identifier .)


state 20

    (5) statement -> print expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 5 (statement -> print expression .)
    $end            reduce using rule 5 (statement -> print expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 21

    (7) expression -> input oparen . parameters cparen
    (8) parameters -> . expression
    (9) parameters -> . parameters comma expression
    (10) parameters -> .
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    cparen          reduce using rule 10 (parameters -> .)
    comma           reduce using rule 10 (parameters -> .)
    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 54
    name                           shift and go to state 51
    parameters                     shift and go to state 53

state 22

    (12) statement -> assname equals . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 55
    name                           shift and go to state 51

state 23

    (27) statement -> name orassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 56
    name                           shift and go to state 51

state 24

    (24) statement -> name lshiftassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 57
    name                           shift and go to state 51

state 25

    (25) statement -> name rshiftassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 58
    name                           shift and go to state 51

state 26

    (29) statement -> name powerassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 59
    name                           shift and go to state 51

state 27

    (19) statement -> name incassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 60
    name                           shift and go to state 51

state 28

    (21) statement -> name divassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 61
    name                           shift and go to state 51

state 29

    (22) statement -> name mulassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 62
    name                           shift and go to state 51

state 30

    (23) statement -> name modassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 63
    name                           shift and go to state 51

state 31

    (26) statement -> name andassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 64
    name                           shift and go to state 51

state 32

    (20) statement -> name decassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 65
    name                           shift and go to state 51

state 33

    (28) statement -> name xorassign . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 66
    name                           shift and go to state 51

state 34

    (15) expression -> plus num .

    plus            reduce using rule 15 (expression -> plus num .)
    minus           reduce using rule 15 (expression -> plus num .)
    times           reduce using rule 15 (expression -> plus num .)
    div             reduce using rule 15 (expression -> plus num .)
    power           reduce using rule 15 (expression -> plus num .)
    modulo          reduce using rule 15 (expression -> plus num .)
    lshift          reduce using rule 15 (expression -> plus num .)
    rshift          reduce using rule 15 (expression -> plus num .)
    floordiv        reduce using rule 15 (expression -> plus num .)
    and             reduce using rule 15 (expression -> plus num .)
    or              reduce using rule 15 (expression -> plus num .)
    xor             reduce using rule 15 (expression -> plus num .)
    newline         reduce using rule 15 (expression -> plus num .)
    $end            reduce using rule 15 (expression -> plus num .)
    cparen          reduce using rule 15 (expression -> plus num .)
    comma           reduce using rule 15 (expression -> plus num .)


state 35

    (16) expression -> plus oparen . expression cparen
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 67
    name                           shift and go to state 51

state 36

    (4) statement_list -> statement_list newline . statement
    (5) statement -> . print expression
    (6) statement -> . print name
    (11) statement -> . expression
    (12) statement -> . assname equals expression
    (19) statement -> . name incassign expression
    (20) statement -> . name decassign expression
    (21) statement -> . name divassign expression
    (22) statement -> . name mulassign expression
    (23) statement -> . name modassign expression
    (24) statement -> . name lshiftassign expression
    (25) statement -> . name rshiftassign expression
    (26) statement -> . name andassign expression
    (27) statement -> . name orassign expression
    (28) statement -> . name xorassign expression
    (29) statement -> . name powerassign expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (45) assname -> . identifier
    (46) name -> . identifier
    (43) num -> . integer

    print           shift and go to state 5
    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    identifier      shift and go to state 13
    integer         shift and go to state 9

    name                           shift and go to state 10
    assname                        shift and go to state 8
    num                            shift and go to state 2
    statement                      shift and go to state 68
    expression                     shift and go to state 14

state 37

    (39) expression -> expression and . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 69
    name                           shift and go to state 51

state 38

    (40) expression -> expression or . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 70
    name                           shift and go to state 51

state 39

    (35) expression -> expression modulo . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 71
    name                           shift and go to state 51

state 40

    (34) expression -> expression power . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 72
    name                           shift and go to state 51

state 41

    (41) expression -> expression xor . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 73
    name                           shift and go to state 51

state 42

    (32) expression -> expression times . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 74
    name                           shift and go to state 51

state 43

    (38) expression -> expression floordiv . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 75
    name                           shift and go to state 51

state 44

    (30) expression -> expression plus . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 76
    name                           shift and go to state 51

state 45

    (36) expression -> expression lshift . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 77
    name                           shift and go to state 51

state 46

    (37) expression -> expression rshift . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 78
    name                           shift and go to state 51

state 47

    (33) expression -> expression div . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 79
    name                           shift and go to state 51

state 48

    (31) expression -> expression minus . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 80
    name                           shift and go to state 51

state 49

    (13) expression -> minus num .

    plus            reduce using rule 13 (expression -> minus num .)
    minus           reduce using rule 13 (expression -> minus num .)
    times           reduce using rule 13 (expression -> minus num .)
    div             reduce using rule 13 (expression -> minus num .)
    power           reduce using rule 13 (expression -> minus num .)
    modulo          reduce using rule 13 (expression -> minus num .)
    lshift          reduce using rule 13 (expression -> minus num .)
    rshift          reduce using rule 13 (expression -> minus num .)
    floordiv        reduce using rule 13 (expression -> minus num .)
    and             reduce using rule 13 (expression -> minus num .)
    or              reduce using rule 13 (expression -> minus num .)
    xor             reduce using rule 13 (expression -> minus num .)
    newline         reduce using rule 13 (expression -> minus num .)
    $end            reduce using rule 13 (expression -> minus num .)
    cparen          reduce using rule 13 (expression -> minus num .)
    comma           reduce using rule 13 (expression -> minus num .)


state 50

    (14) expression -> minus oparen . expression cparen
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 81
    name                           shift and go to state 51

state 51

    (44) expression -> name .

    plus            reduce using rule 44 (expression -> name .)
    minus           reduce using rule 44 (expression -> name .)
    times           reduce using rule 44 (expression -> name .)
    div             reduce using rule 44 (expression -> name .)
    power           reduce using rule 44 (expression -> name .)
    modulo          reduce using rule 44 (expression -> name .)
    lshift          reduce using rule 44 (expression -> name .)
    rshift          reduce using rule 44 (expression -> name .)
    floordiv        reduce using rule 44 (expression -> name .)
    and             reduce using rule 44 (expression -> name .)
    or              reduce using rule 44 (expression -> name .)
    xor             reduce using rule 44 (expression -> name .)
    newline         reduce using rule 44 (expression -> name .)
    $end            reduce using rule 44 (expression -> name .)
    cparen          reduce using rule 44 (expression -> name .)
    comma           reduce using rule 44 (expression -> name .)


state 52

    (18) expression -> invert oparen expression . cparen
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    cparen          shift and go to state 82
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 53

    (7) expression -> input oparen parameters . cparen
    (9) parameters -> parameters . comma expression

    cparen          shift and go to state 83
    comma           shift and go to state 84


state 54

    (8) parameters -> expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    cparen          reduce using rule 8 (parameters -> expression .)
    comma           reduce using rule 8 (parameters -> expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 55

    (12) statement -> assname equals expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 12 (statement -> assname equals expression .)
    $end            reduce using rule 12 (statement -> assname equals expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 56

    (27) statement -> name orassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 27 (statement -> name orassign expression .)
    $end            reduce using rule 27 (statement -> name orassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 57

    (24) statement -> name lshiftassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 24 (statement -> name lshiftassign expression .)
    $end            reduce using rule 24 (statement -> name lshiftassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 58

    (25) statement -> name rshiftassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 25 (statement -> name rshiftassign expression .)
    $end            reduce using rule 25 (statement -> name rshiftassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 59

    (29) statement -> name powerassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 29 (statement -> name powerassign expression .)
    $end            reduce using rule 29 (statement -> name powerassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 60

    (19) statement -> name incassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 19 (statement -> name incassign expression .)
    $end            reduce using rule 19 (statement -> name incassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 61

    (21) statement -> name divassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 21 (statement -> name divassign expression .)
    $end            reduce using rule 21 (statement -> name divassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 62

    (22) statement -> name mulassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 22 (statement -> name mulassign expression .)
    $end            reduce using rule 22 (statement -> name mulassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 63

    (23) statement -> name modassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 23 (statement -> name modassign expression .)
    $end            reduce using rule 23 (statement -> name modassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 64

    (26) statement -> name andassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 26 (statement -> name andassign expression .)
    $end            reduce using rule 26 (statement -> name andassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 65

    (20) statement -> name decassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 20 (statement -> name decassign expression .)
    $end            reduce using rule 20 (statement -> name decassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 66

    (28) statement -> name xorassign expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    newline         reduce using rule 28 (statement -> name xorassign expression .)
    $end            reduce using rule 28 (statement -> name xorassign expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 67

    (16) expression -> plus oparen expression . cparen
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    cparen          shift and go to state 85
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 68

    (4) statement_list -> statement_list newline statement .

    newline         reduce using rule 4 (statement_list -> statement_list newline statement .)
    $end            reduce using rule 4 (statement_list -> statement_list newline statement .)


state 69

    (39) expression -> expression and expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 39 (expression -> expression and expression .)
    $end            reduce using rule 39 (expression -> expression and expression .)
    cparen          reduce using rule 39 (expression -> expression and expression .)
    comma           reduce using rule 39 (expression -> expression and expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 39 (expression -> expression and expression .) ]
  ! minus           [ reduce using rule 39 (expression -> expression and expression .) ]
  ! times           [ reduce using rule 39 (expression -> expression and expression .) ]
  ! div             [ reduce using rule 39 (expression -> expression and expression .) ]
  ! power           [ reduce using rule 39 (expression -> expression and expression .) ]
  ! modulo          [ reduce using rule 39 (expression -> expression and expression .) ]
  ! lshift          [ reduce using rule 39 (expression -> expression and expression .) ]
  ! rshift          [ reduce using rule 39 (expression -> expression and expression .) ]
  ! floordiv        [ reduce using rule 39 (expression -> expression and expression .) ]
  ! and             [ reduce using rule 39 (expression -> expression and expression .) ]
  ! or              [ reduce using rule 39 (expression -> expression and expression .) ]
  ! xor             [ reduce using rule 39 (expression -> expression and expression .) ]


state 70

    (40) expression -> expression or expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 40 (expression -> expression or expression .)
    $end            reduce using rule 40 (expression -> expression or expression .)
    cparen          reduce using rule 40 (expression -> expression or expression .)
    comma           reduce using rule 40 (expression -> expression or expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 40 (expression -> expression or expression .) ]
  ! minus           [ reduce using rule 40 (expression -> expression or expression .) ]
  ! times           [ reduce using rule 40 (expression -> expression or expression .) ]
  ! div             [ reduce using rule 40 (expression -> expression or expression .) ]
  ! power           [ reduce using rule 40 (expression -> expression or expression .) ]
  ! modulo          [ reduce using rule 40 (expression -> expression or expression .) ]
  ! lshift          [ reduce using rule 40 (expression -> expression or expression .) ]
  ! rshift          [ reduce using rule 40 (expression -> expression or expression .) ]
  ! floordiv        [ reduce using rule 40 (expression -> expression or expression .) ]
  ! and             [ reduce using rule 40 (expression -> expression or expression .) ]
  ! or              [ reduce using rule 40 (expression -> expression or expression .) ]
  ! xor             [ reduce using rule 40 (expression -> expression or expression .) ]


state 71

    (35) expression -> expression modulo expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 35 (expression -> expression modulo expression .)
    $end            reduce using rule 35 (expression -> expression modulo expression .)
    cparen          reduce using rule 35 (expression -> expression modulo expression .)
    comma           reduce using rule 35 (expression -> expression modulo expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! minus           [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! times           [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! div             [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! power           [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! modulo          [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! lshift          [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! rshift          [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! floordiv        [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! and             [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! or              [ reduce using rule 35 (expression -> expression modulo expression .) ]
  ! xor             [ reduce using rule 35 (expression -> expression modulo expression .) ]


state 72

    (34) expression -> expression power expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    plus            reduce using rule 34 (expression -> expression power expression .)
    minus           reduce using rule 34 (expression -> expression power expression .)
    times           reduce using rule 34 (expression -> expression power expression .)
    div             reduce using rule 34 (expression -> expression power expression .)
    modulo          reduce using rule 34 (expression -> expression power expression .)
    lshift          reduce using rule 34 (expression -> expression power expression .)
    rshift          reduce using rule 34 (expression -> expression power expression .)
    floordiv        reduce using rule 34 (expression -> expression power expression .)
    and             reduce using rule 34 (expression -> expression power expression .)
    or              reduce using rule 34 (expression -> expression power expression .)
    xor             reduce using rule 34 (expression -> expression power expression .)
    newline         reduce using rule 34 (expression -> expression power expression .)
    $end            reduce using rule 34 (expression -> expression power expression .)
    cparen          reduce using rule 34 (expression -> expression power expression .)
    comma           reduce using rule 34 (expression -> expression power expression .)
    power           shift and go to state 40

  ! power           [ reduce using rule 34 (expression -> expression power expression .) ]
  ! plus            [ shift and go to state 44 ]
  ! minus           [ shift and go to state 48 ]
  ! times           [ shift and go to state 42 ]
  ! div             [ shift and go to state 47 ]
  ! modulo          [ shift and go to state 39 ]
  ! lshift          [ shift and go to state 45 ]
  ! rshift          [ shift and go to state 46 ]
  ! floordiv        [ shift and go to state 43 ]
  ! and             [ shift and go to state 37 ]
  ! or              [ shift and go to state 38 ]
  ! xor             [ shift and go to state 41 ]


state 73

    (41) expression -> expression xor expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 41 (expression -> expression xor expression .)
    $end            reduce using rule 41 (expression -> expression xor expression .)
    cparen          reduce using rule 41 (expression -> expression xor expression .)
    comma           reduce using rule 41 (expression -> expression xor expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! minus           [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! times           [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! div             [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! power           [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! modulo          [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! lshift          [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! rshift          [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! floordiv        [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! and             [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! or              [ reduce using rule 41 (expression -> expression xor expression .) ]
  ! xor             [ reduce using rule 41 (expression -> expression xor expression .) ]


state 74

    (32) expression -> expression times expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    plus            reduce using rule 32 (expression -> expression times expression .)
    minus           reduce using rule 32 (expression -> expression times expression .)
    times           reduce using rule 32 (expression -> expression times expression .)
    div             reduce using rule 32 (expression -> expression times expression .)
    modulo          reduce using rule 32 (expression -> expression times expression .)
    lshift          reduce using rule 32 (expression -> expression times expression .)
    rshift          reduce using rule 32 (expression -> expression times expression .)
    floordiv        reduce using rule 32 (expression -> expression times expression .)
    and             reduce using rule 32 (expression -> expression times expression .)
    or              reduce using rule 32 (expression -> expression times expression .)
    xor             reduce using rule 32 (expression -> expression times expression .)
    newline         reduce using rule 32 (expression -> expression times expression .)
    $end            reduce using rule 32 (expression -> expression times expression .)
    cparen          reduce using rule 32 (expression -> expression times expression .)
    comma           reduce using rule 32 (expression -> expression times expression .)
    power           shift and go to state 40

  ! power           [ reduce using rule 32 (expression -> expression times expression .) ]
  ! plus            [ shift and go to state 44 ]
  ! minus           [ shift and go to state 48 ]
  ! times           [ shift and go to state 42 ]
  ! div             [ shift and go to state 47 ]
  ! modulo          [ shift and go to state 39 ]
  ! lshift          [ shift and go to state 45 ]
  ! rshift          [ shift and go to state 46 ]
  ! floordiv        [ shift and go to state 43 ]
  ! and             [ shift and go to state 37 ]
  ! or              [ shift and go to state 38 ]
  ! xor             [ shift and go to state 41 ]


state 75

    (38) expression -> expression floordiv expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 38 (expression -> expression floordiv expression .)
    $end            reduce using rule 38 (expression -> expression floordiv expression .)
    cparen          reduce using rule 38 (expression -> expression floordiv expression .)
    comma           reduce using rule 38 (expression -> expression floordiv expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! minus           [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! times           [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! div             [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! power           [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! modulo          [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! lshift          [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! rshift          [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! floordiv        [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! and             [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! or              [ reduce using rule 38 (expression -> expression floordiv expression .) ]
  ! xor             [ reduce using rule 38 (expression -> expression floordiv expression .) ]


state 76

    (30) expression -> expression plus expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    plus            reduce using rule 30 (expression -> expression plus expression .)
    minus           reduce using rule 30 (expression -> expression plus expression .)
    modulo          reduce using rule 30 (expression -> expression plus expression .)
    lshift          reduce using rule 30 (expression -> expression plus expression .)
    rshift          reduce using rule 30 (expression -> expression plus expression .)
    floordiv        reduce using rule 30 (expression -> expression plus expression .)
    and             reduce using rule 30 (expression -> expression plus expression .)
    or              reduce using rule 30 (expression -> expression plus expression .)
    xor             reduce using rule 30 (expression -> expression plus expression .)
    newline         reduce using rule 30 (expression -> expression plus expression .)
    $end            reduce using rule 30 (expression -> expression plus expression .)
    cparen          reduce using rule 30 (expression -> expression plus expression .)
    comma           reduce using rule 30 (expression -> expression plus expression .)
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40

  ! times           [ reduce using rule 30 (expression -> expression plus expression .) ]
  ! div             [ reduce using rule 30 (expression -> expression plus expression .) ]
  ! power           [ reduce using rule 30 (expression -> expression plus expression .) ]
  ! plus            [ shift and go to state 44 ]
  ! minus           [ shift and go to state 48 ]
  ! modulo          [ shift and go to state 39 ]
  ! lshift          [ shift and go to state 45 ]
  ! rshift          [ shift and go to state 46 ]
  ! floordiv        [ shift and go to state 43 ]
  ! and             [ shift and go to state 37 ]
  ! or              [ shift and go to state 38 ]
  ! xor             [ shift and go to state 41 ]


state 77

    (36) expression -> expression lshift expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 36 (expression -> expression lshift expression .)
    $end            reduce using rule 36 (expression -> expression lshift expression .)
    cparen          reduce using rule 36 (expression -> expression lshift expression .)
    comma           reduce using rule 36 (expression -> expression lshift expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! minus           [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! times           [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! div             [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! power           [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! modulo          [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! lshift          [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! rshift          [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! floordiv        [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! and             [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! or              [ reduce using rule 36 (expression -> expression lshift expression .) ]
  ! xor             [ reduce using rule 36 (expression -> expression lshift expression .) ]


state 78

    (37) expression -> expression rshift expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
  ! shift/reduce conflict for times resolved as shift
  ! shift/reduce conflict for div resolved as shift
  ! shift/reduce conflict for power resolved as shift
  ! shift/reduce conflict for modulo resolved as shift
  ! shift/reduce conflict for lshift resolved as shift
  ! shift/reduce conflict for rshift resolved as shift
  ! shift/reduce conflict for floordiv resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
  ! shift/reduce conflict for xor resolved as shift
    newline         reduce using rule 37 (expression -> expression rshift expression .)
    $end            reduce using rule 37 (expression -> expression rshift expression .)
    cparen          reduce using rule 37 (expression -> expression rshift expression .)
    comma           reduce using rule 37 (expression -> expression rshift expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

  ! plus            [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! minus           [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! times           [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! div             [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! power           [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! modulo          [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! lshift          [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! rshift          [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! floordiv        [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! and             [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! or              [ reduce using rule 37 (expression -> expression rshift expression .) ]
  ! xor             [ reduce using rule 37 (expression -> expression rshift expression .) ]


state 79

    (33) expression -> expression div expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    plus            reduce using rule 33 (expression -> expression div expression .)
    minus           reduce using rule 33 (expression -> expression div expression .)
    times           reduce using rule 33 (expression -> expression div expression .)
    div             reduce using rule 33 (expression -> expression div expression .)
    modulo          reduce using rule 33 (expression -> expression div expression .)
    lshift          reduce using rule 33 (expression -> expression div expression .)
    rshift          reduce using rule 33 (expression -> expression div expression .)
    floordiv        reduce using rule 33 (expression -> expression div expression .)
    and             reduce using rule 33 (expression -> expression div expression .)
    or              reduce using rule 33 (expression -> expression div expression .)
    xor             reduce using rule 33 (expression -> expression div expression .)
    newline         reduce using rule 33 (expression -> expression div expression .)
    $end            reduce using rule 33 (expression -> expression div expression .)
    cparen          reduce using rule 33 (expression -> expression div expression .)
    comma           reduce using rule 33 (expression -> expression div expression .)
    power           shift and go to state 40

  ! power           [ reduce using rule 33 (expression -> expression div expression .) ]
  ! plus            [ shift and go to state 44 ]
  ! minus           [ shift and go to state 48 ]
  ! times           [ shift and go to state 42 ]
  ! div             [ shift and go to state 47 ]
  ! modulo          [ shift and go to state 39 ]
  ! lshift          [ shift and go to state 45 ]
  ! rshift          [ shift and go to state 46 ]
  ! floordiv        [ shift and go to state 43 ]
  ! and             [ shift and go to state 37 ]
  ! or              [ shift and go to state 38 ]
  ! xor             [ shift and go to state 41 ]


state 80

    (31) expression -> expression minus expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    plus            reduce using rule 31 (expression -> expression minus expression .)
    minus           reduce using rule 31 (expression -> expression minus expression .)
    modulo          reduce using rule 31 (expression -> expression minus expression .)
    lshift          reduce using rule 31 (expression -> expression minus expression .)
    rshift          reduce using rule 31 (expression -> expression minus expression .)
    floordiv        reduce using rule 31 (expression -> expression minus expression .)
    and             reduce using rule 31 (expression -> expression minus expression .)
    or              reduce using rule 31 (expression -> expression minus expression .)
    xor             reduce using rule 31 (expression -> expression minus expression .)
    newline         reduce using rule 31 (expression -> expression minus expression .)
    $end            reduce using rule 31 (expression -> expression minus expression .)
    cparen          reduce using rule 31 (expression -> expression minus expression .)
    comma           reduce using rule 31 (expression -> expression minus expression .)
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40

  ! times           [ reduce using rule 31 (expression -> expression minus expression .) ]
  ! div             [ reduce using rule 31 (expression -> expression minus expression .) ]
  ! power           [ reduce using rule 31 (expression -> expression minus expression .) ]
  ! plus            [ shift and go to state 44 ]
  ! minus           [ shift and go to state 48 ]
  ! modulo          [ shift and go to state 39 ]
  ! lshift          [ shift and go to state 45 ]
  ! rshift          [ shift and go to state 46 ]
  ! floordiv        [ shift and go to state 43 ]
  ! and             [ shift and go to state 37 ]
  ! or              [ shift and go to state 38 ]
  ! xor             [ shift and go to state 41 ]


state 81

    (14) expression -> minus oparen expression . cparen
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    cparen          shift and go to state 86
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41


state 82

    (18) expression -> invert oparen expression cparen .

    plus            reduce using rule 18 (expression -> invert oparen expression cparen .)
    minus           reduce using rule 18 (expression -> invert oparen expression cparen .)
    times           reduce using rule 18 (expression -> invert oparen expression cparen .)
    div             reduce using rule 18 (expression -> invert oparen expression cparen .)
    power           reduce using rule 18 (expression -> invert oparen expression cparen .)
    modulo          reduce using rule 18 (expression -> invert oparen expression cparen .)
    lshift          reduce using rule 18 (expression -> invert oparen expression cparen .)
    rshift          reduce using rule 18 (expression -> invert oparen expression cparen .)
    floordiv        reduce using rule 18 (expression -> invert oparen expression cparen .)
    and             reduce using rule 18 (expression -> invert oparen expression cparen .)
    or              reduce using rule 18 (expression -> invert oparen expression cparen .)
    xor             reduce using rule 18 (expression -> invert oparen expression cparen .)
    newline         reduce using rule 18 (expression -> invert oparen expression cparen .)
    $end            reduce using rule 18 (expression -> invert oparen expression cparen .)
    cparen          reduce using rule 18 (expression -> invert oparen expression cparen .)
    comma           reduce using rule 18 (expression -> invert oparen expression cparen .)


state 83

    (7) expression -> input oparen parameters cparen .

    plus            reduce using rule 7 (expression -> input oparen parameters cparen .)
    minus           reduce using rule 7 (expression -> input oparen parameters cparen .)
    times           reduce using rule 7 (expression -> input oparen parameters cparen .)
    div             reduce using rule 7 (expression -> input oparen parameters cparen .)
    power           reduce using rule 7 (expression -> input oparen parameters cparen .)
    modulo          reduce using rule 7 (expression -> input oparen parameters cparen .)
    lshift          reduce using rule 7 (expression -> input oparen parameters cparen .)
    rshift          reduce using rule 7 (expression -> input oparen parameters cparen .)
    floordiv        reduce using rule 7 (expression -> input oparen parameters cparen .)
    and             reduce using rule 7 (expression -> input oparen parameters cparen .)
    or              reduce using rule 7 (expression -> input oparen parameters cparen .)
    xor             reduce using rule 7 (expression -> input oparen parameters cparen .)
    newline         reduce using rule 7 (expression -> input oparen parameters cparen .)
    $end            reduce using rule 7 (expression -> input oparen parameters cparen .)
    cparen          reduce using rule 7 (expression -> input oparen parameters cparen .)
    comma           reduce using rule 7 (expression -> input oparen parameters cparen .)


state 84

    (9) parameters -> parameters comma . expression
    (7) expression -> . input oparen parameters cparen
    (13) expression -> . minus num
    (14) expression -> . minus oparen expression cparen
    (15) expression -> . plus num
    (16) expression -> . plus oparen expression cparen
    (17) expression -> . invert num
    (18) expression -> . invert oparen expression cparen
    (30) expression -> . expression plus expression
    (31) expression -> . expression minus expression
    (32) expression -> . expression times expression
    (33) expression -> . expression div expression
    (34) expression -> . expression power expression
    (35) expression -> . expression modulo expression
    (36) expression -> . expression lshift expression
    (37) expression -> . expression rshift expression
    (38) expression -> . expression floordiv expression
    (39) expression -> . expression and expression
    (40) expression -> . expression or expression
    (41) expression -> . expression xor expression
    (42) expression -> . num
    (44) expression -> . name
    (43) num -> . integer
    (46) name -> . identifier

    input           shift and go to state 6
    minus           shift and go to state 15
    plus            shift and go to state 11
    invert          shift and go to state 3
    integer         shift and go to state 9
    identifier      shift and go to state 19

    num                            shift and go to state 2
    expression                     shift and go to state 87
    name                           shift and go to state 51

state 85

    (16) expression -> plus oparen expression cparen .

    plus            reduce using rule 16 (expression -> plus oparen expression cparen .)
    minus           reduce using rule 16 (expression -> plus oparen expression cparen .)
    times           reduce using rule 16 (expression -> plus oparen expression cparen .)
    div             reduce using rule 16 (expression -> plus oparen expression cparen .)
    power           reduce using rule 16 (expression -> plus oparen expression cparen .)
    modulo          reduce using rule 16 (expression -> plus oparen expression cparen .)
    lshift          reduce using rule 16 (expression -> plus oparen expression cparen .)
    rshift          reduce using rule 16 (expression -> plus oparen expression cparen .)
    floordiv        reduce using rule 16 (expression -> plus oparen expression cparen .)
    and             reduce using rule 16 (expression -> plus oparen expression cparen .)
    or              reduce using rule 16 (expression -> plus oparen expression cparen .)
    xor             reduce using rule 16 (expression -> plus oparen expression cparen .)
    newline         reduce using rule 16 (expression -> plus oparen expression cparen .)
    $end            reduce using rule 16 (expression -> plus oparen expression cparen .)
    cparen          reduce using rule 16 (expression -> plus oparen expression cparen .)
    comma           reduce using rule 16 (expression -> plus oparen expression cparen .)


state 86

    (14) expression -> minus oparen expression cparen .

    plus            reduce using rule 14 (expression -> minus oparen expression cparen .)
    minus           reduce using rule 14 (expression -> minus oparen expression cparen .)
    times           reduce using rule 14 (expression -> minus oparen expression cparen .)
    div             reduce using rule 14 (expression -> minus oparen expression cparen .)
    power           reduce using rule 14 (expression -> minus oparen expression cparen .)
    modulo          reduce using rule 14 (expression -> minus oparen expression cparen .)
    lshift          reduce using rule 14 (expression -> minus oparen expression cparen .)
    rshift          reduce using rule 14 (expression -> minus oparen expression cparen .)
    floordiv        reduce using rule 14 (expression -> minus oparen expression cparen .)
    and             reduce using rule 14 (expression -> minus oparen expression cparen .)
    or              reduce using rule 14 (expression -> minus oparen expression cparen .)
    xor             reduce using rule 14 (expression -> minus oparen expression cparen .)
    newline         reduce using rule 14 (expression -> minus oparen expression cparen .)
    $end            reduce using rule 14 (expression -> minus oparen expression cparen .)
    cparen          reduce using rule 14 (expression -> minus oparen expression cparen .)
    comma           reduce using rule 14 (expression -> minus oparen expression cparen .)


state 87

    (9) parameters -> parameters comma expression .
    (30) expression -> expression . plus expression
    (31) expression -> expression . minus expression
    (32) expression -> expression . times expression
    (33) expression -> expression . div expression
    (34) expression -> expression . power expression
    (35) expression -> expression . modulo expression
    (36) expression -> expression . lshift expression
    (37) expression -> expression . rshift expression
    (38) expression -> expression . floordiv expression
    (39) expression -> expression . and expression
    (40) expression -> expression . or expression
    (41) expression -> expression . xor expression

    cparen          reduce using rule 9 (parameters -> parameters comma expression .)
    comma           reduce using rule 9 (parameters -> parameters comma expression .)
    plus            shift and go to state 44
    minus           shift and go to state 48
    times           shift and go to state 42
    div             shift and go to state 47
    power           shift and go to state 40
    modulo          shift and go to state 39
    lshift          shift and go to state 45
    rshift          shift and go to state 46
    floordiv        shift and go to state 43
    and             shift and go to state 37
    or              shift and go to state 38
    xor             shift and go to state 41

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for plus in state 69 resolved as shift
WARNING: shift/reduce conflict for minus in state 69 resolved as shift
WARNING: shift/reduce conflict for times in state 69 resolved as shift
WARNING: shift/reduce conflict for div in state 69 resolved as shift
WARNING: shift/reduce conflict for power in state 69 resolved as shift
WARNING: shift/reduce conflict for modulo in state 69 resolved as shift
WARNING: shift/reduce conflict for lshift in state 69 resolved as shift
WARNING: shift/reduce conflict for rshift in state 69 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 69 resolved as shift
WARNING: shift/reduce conflict for and in state 69 resolved as shift
WARNING: shift/reduce conflict for or in state 69 resolved as shift
WARNING: shift/reduce conflict for xor in state 69 resolved as shift
WARNING: shift/reduce conflict for plus in state 70 resolved as shift
WARNING: shift/reduce conflict for minus in state 70 resolved as shift
WARNING: shift/reduce conflict for times in state 70 resolved as shift
WARNING: shift/reduce conflict for div in state 70 resolved as shift
WARNING: shift/reduce conflict for power in state 70 resolved as shift
WARNING: shift/reduce conflict for modulo in state 70 resolved as shift
WARNING: shift/reduce conflict for lshift in state 70 resolved as shift
WARNING: shift/reduce conflict for rshift in state 70 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 70 resolved as shift
WARNING: shift/reduce conflict for and in state 70 resolved as shift
WARNING: shift/reduce conflict for or in state 70 resolved as shift
WARNING: shift/reduce conflict for xor in state 70 resolved as shift
WARNING: shift/reduce conflict for plus in state 71 resolved as shift
WARNING: shift/reduce conflict for minus in state 71 resolved as shift
WARNING: shift/reduce conflict for times in state 71 resolved as shift
WARNING: shift/reduce conflict for div in state 71 resolved as shift
WARNING: shift/reduce conflict for power in state 71 resolved as shift
WARNING: shift/reduce conflict for modulo in state 71 resolved as shift
WARNING: shift/reduce conflict for lshift in state 71 resolved as shift
WARNING: shift/reduce conflict for rshift in state 71 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 71 resolved as shift
WARNING: shift/reduce conflict for and in state 71 resolved as shift
WARNING: shift/reduce conflict for or in state 71 resolved as shift
WARNING: shift/reduce conflict for xor in state 71 resolved as shift
WARNING: shift/reduce conflict for plus in state 73 resolved as shift
WARNING: shift/reduce conflict for minus in state 73 resolved as shift
WARNING: shift/reduce conflict for times in state 73 resolved as shift
WARNING: shift/reduce conflict for div in state 73 resolved as shift
WARNING: shift/reduce conflict for power in state 73 resolved as shift
WARNING: shift/reduce conflict for modulo in state 73 resolved as shift
WARNING: shift/reduce conflict for lshift in state 73 resolved as shift
WARNING: shift/reduce conflict for rshift in state 73 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 73 resolved as shift
WARNING: shift/reduce conflict for and in state 73 resolved as shift
WARNING: shift/reduce conflict for or in state 73 resolved as shift
WARNING: shift/reduce conflict for xor in state 73 resolved as shift
WARNING: shift/reduce conflict for plus in state 75 resolved as shift
WARNING: shift/reduce conflict for minus in state 75 resolved as shift
WARNING: shift/reduce conflict for times in state 75 resolved as shift
WARNING: shift/reduce conflict for div in state 75 resolved as shift
WARNING: shift/reduce conflict for power in state 75 resolved as shift
WARNING: shift/reduce conflict for modulo in state 75 resolved as shift
WARNING: shift/reduce conflict for lshift in state 75 resolved as shift
WARNING: shift/reduce conflict for rshift in state 75 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 75 resolved as shift
WARNING: shift/reduce conflict for and in state 75 resolved as shift
WARNING: shift/reduce conflict for or in state 75 resolved as shift
WARNING: shift/reduce conflict for xor in state 75 resolved as shift
WARNING: shift/reduce conflict for plus in state 77 resolved as shift
WARNING: shift/reduce conflict for minus in state 77 resolved as shift
WARNING: shift/reduce conflict for times in state 77 resolved as shift
WARNING: shift/reduce conflict for div in state 77 resolved as shift
WARNING: shift/reduce conflict for power in state 77 resolved as shift
WARNING: shift/reduce conflict for modulo in state 77 resolved as shift
WARNING: shift/reduce conflict for lshift in state 77 resolved as shift
WARNING: shift/reduce conflict for rshift in state 77 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 77 resolved as shift
WARNING: shift/reduce conflict for and in state 77 resolved as shift
WARNING: shift/reduce conflict for or in state 77 resolved as shift
WARNING: shift/reduce conflict for xor in state 77 resolved as shift
WARNING: shift/reduce conflict for plus in state 78 resolved as shift
WARNING: shift/reduce conflict for minus in state 78 resolved as shift
WARNING: shift/reduce conflict for times in state 78 resolved as shift
WARNING: shift/reduce conflict for div in state 78 resolved as shift
WARNING: shift/reduce conflict for power in state 78 resolved as shift
WARNING: shift/reduce conflict for modulo in state 78 resolved as shift
WARNING: shift/reduce conflict for lshift in state 78 resolved as shift
WARNING: shift/reduce conflict for rshift in state 78 resolved as shift
WARNING: shift/reduce conflict for floordiv in state 78 resolved as shift
WARNING: shift/reduce conflict for and in state 78 resolved as shift
WARNING: shift/reduce conflict for or in state 78 resolved as shift
WARNING: shift/reduce conflict for xor in state 78 resolved as shift
WARNING: reduce/reduce conflict in state 18 resolved using rule (statement -> print name)
WARNING: rejected rule (expression -> name) in state 18
