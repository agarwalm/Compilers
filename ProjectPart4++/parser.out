Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    comment
    obracket
    usub
    uadd
    ocurly
    rparen
    string
    lparen
    ccurly
    cbracket

Grammar

Rule 0     S' -> module
Rule 1     module -> stmt
Rule 2     stmt -> statement_list
Rule 3     statement_list -> statement
Rule 4     statement_list -> statement_list statement
Rule 5     statement -> newline statement
Rule 6     statement -> statement newline
Rule 7     statement -> print expression
Rule 8     expression -> input oparen parameters cparen
Rule 9     parameters -> expression
Rule 10    parameters -> parameters comma expression
Rule 11    parameters -> <empty>
Rule 12    statement -> assname equals expression
Rule 13    statement -> expression
Rule 14    statement -> ifstmt
Rule 15    statement -> whilestmt
Rule 16    statement -> name incassign expression
Rule 17    statement -> name decassign expression
Rule 18    statement -> name divassign expression
Rule 19    statement -> name mulassign expression
Rule 20    statement -> name modassign expression
Rule 21    statement -> name lshiftassign expression
Rule 22    statement -> name rshiftassign expression
Rule 23    statement -> name andassign expression
Rule 24    statement -> name orassign expression
Rule 25    statement -> name xorassign expression
Rule 26    statement -> name powerassign expression
Rule 27    statement -> name floorassign expression
Rule 28    expression -> boolean
Rule 29    expression -> minus expression
Rule 30    expression -> plus expression
Rule 31    expression -> invert expression
Rule 32    expression -> expression0
Rule 33    expression -> oparen expression cparen
Rule 34    expression -> not expression
Rule 35    expression -> name
Rule 36    expression -> expression plus expression
Rule 37    expression -> expression minus expression
Rule 38    expression -> expression times expression
Rule 39    expression -> expression div expression
Rule 40    expression -> expression power expression
Rule 41    expression -> expression modulo expression
Rule 42    expression -> expression lshift expression
Rule 43    expression -> expression rshift expression
Rule 44    expression -> expression floordiv expression
Rule 45    expression -> expression and expression
Rule 46    expression -> expression or expression
Rule 47    expression -> expression xor expression
Rule 48    expression -> expression strand expression
Rule 49    expression -> expression stror expression
Rule 50    expression -> expression lt expression
Rule 51    expression -> expression gt expression
Rule 52    expression -> expression lequal expression
Rule 53    expression -> expression gequal expression
Rule 54    expression -> expression isnotequal expression
Rule 55    expression -> expression isequal expression
Rule 56    ifstmt -> if expression colon newline indent statement_list dedent
Rule 57    ifstmt -> if expression colon newline indent statement_list dedent elsestmt
Rule 58    elsestmt -> else colon newline indent statement_list dedent
Rule 59    elsestmt -> elif expression colon newline indent statement_list dedent
Rule 60    elsestmt -> elif expression colon newline indent statement_list dedent elsestmt
Rule 61    whilestmt -> while expression colon newline indent statement_list dedent
Rule 62    expression0 -> num
Rule 63    expression0 -> name
Rule 64    expression0 -> boolean
Rule 65    num -> integer
Rule 66    assname -> identifier
Rule 67    name -> identifier
Rule 68    boolean -> true
Rule 69    boolean -> false

Terminals, with rules where they appear

and                  : 45
andassign            : 23
cbracket             : 
ccurly               : 
colon                : 56 57 58 59 60 61
comma                : 10
comment              : 
cparen               : 8 33
decassign            : 17
dedent               : 56 57 58 59 60 61
div                  : 39
divassign            : 18
elif                 : 59 60
else                 : 58
equals               : 12
error                : 
false                : 69
floorassign          : 27
floordiv             : 44
gequal               : 53
gt                   : 51
identifier           : 66 67
if                   : 56 57
incassign            : 16
indent               : 56 57 58 59 60 61
input                : 8
integer              : 65
invert               : 31
isequal              : 55
isnotequal           : 54
lequal               : 52
lparen               : 
lshift               : 42
lshiftassign         : 21
lt                   : 50
minus                : 29 37
modassign            : 20
modulo               : 41
mulassign            : 19
newline              : 5 6 56 57 58 59 60 61
not                  : 34
obracket             : 
ocurly               : 
oparen               : 8 33
or                   : 46
orassign             : 24
plus                 : 30 36
power                : 40
powerassign          : 26
print                : 7
rparen               : 
rshift               : 43
rshiftassign         : 22
strand               : 48
string               : 
stror                : 49
times                : 38
true                 : 68
uadd                 : 
usub                 : 
while                : 61
xor                  : 47
xorassign            : 25

Nonterminals, with rules where they appear

assname              : 12
boolean              : 28 64
elsestmt             : 57 60
expression           : 7 9 10 12 13 16 17 18 19 20 21 22 23 24 25 26 27 29 30 31 33 34 36 36 37 37 38 38 39 39 40 40 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 57 59 60 61
expression0          : 32
ifstmt               : 14
module               : 0
name                 : 16 17 18 19 20 21 22 23 24 25 26 27 35 63
num                  : 62
parameters           : 8 10
statement            : 3 4 5 6
statement_list       : 2 4 56 57 58 59 60 61
stmt                 : 1
whilestmt            : 15

Parsing method: LALR

state 0

    (0) S' -> . module
    (1) module -> . stmt
    (2) stmt -> . statement_list
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    stmt                           shift and go to state 15
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    module                         shift and go to state 1
    statement                      shift and go to state 9
    statement_list                 shift and go to state 23
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 1

    (0) S' -> module .



state 2

    (15) statement -> whilestmt .

    newline         reduce using rule 15 (statement -> whilestmt .)
    dedent          reduce using rule 15 (statement -> whilestmt .)
    print           reduce using rule 15 (statement -> whilestmt .)
    identifier      reduce using rule 15 (statement -> whilestmt .)
    input           reduce using rule 15 (statement -> whilestmt .)
    minus           reduce using rule 15 (statement -> whilestmt .)
    plus            reduce using rule 15 (statement -> whilestmt .)
    invert          reduce using rule 15 (statement -> whilestmt .)
    oparen          reduce using rule 15 (statement -> whilestmt .)
    not             reduce using rule 15 (statement -> whilestmt .)
    if              reduce using rule 15 (statement -> whilestmt .)
    while           reduce using rule 15 (statement -> whilestmt .)
    true            reduce using rule 15 (statement -> whilestmt .)
    false           reduce using rule 15 (statement -> whilestmt .)
    integer         reduce using rule 15 (statement -> whilestmt .)
    $end            reduce using rule 15 (statement -> whilestmt .)


state 3

    (28) expression -> boolean .
    (64) expression0 -> boolean .

  ! reduce/reduce conflict for plus resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for minus resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for times resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for div resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for power resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for modulo resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for lshift resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for rshift resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for floordiv resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for and resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for or resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for xor resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for strand resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for stror resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for lt resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for gt resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for lequal resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for gequal resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for isnotequal resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for isequal resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for newline resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for print resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for identifier resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for input resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for invert resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for oparen resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for not resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for if resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for while resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for true resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for false resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for integer resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for $end resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for dedent resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for colon resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for cparen resolved using rule 28 (expression -> boolean .)
  ! reduce/reduce conflict for comma resolved using rule 28 (expression -> boolean .)
    plus            reduce using rule 28 (expression -> boolean .)
    minus           reduce using rule 28 (expression -> boolean .)
    times           reduce using rule 28 (expression -> boolean .)
    div             reduce using rule 28 (expression -> boolean .)
    power           reduce using rule 28 (expression -> boolean .)
    modulo          reduce using rule 28 (expression -> boolean .)
    lshift          reduce using rule 28 (expression -> boolean .)
    rshift          reduce using rule 28 (expression -> boolean .)
    floordiv        reduce using rule 28 (expression -> boolean .)
    and             reduce using rule 28 (expression -> boolean .)
    or              reduce using rule 28 (expression -> boolean .)
    xor             reduce using rule 28 (expression -> boolean .)
    strand          reduce using rule 28 (expression -> boolean .)
    stror           reduce using rule 28 (expression -> boolean .)
    lt              reduce using rule 28 (expression -> boolean .)
    gt              reduce using rule 28 (expression -> boolean .)
    lequal          reduce using rule 28 (expression -> boolean .)
    gequal          reduce using rule 28 (expression -> boolean .)
    isnotequal      reduce using rule 28 (expression -> boolean .)
    isequal         reduce using rule 28 (expression -> boolean .)
    newline         reduce using rule 28 (expression -> boolean .)
    print           reduce using rule 28 (expression -> boolean .)
    identifier      reduce using rule 28 (expression -> boolean .)
    input           reduce using rule 28 (expression -> boolean .)
    invert          reduce using rule 28 (expression -> boolean .)
    oparen          reduce using rule 28 (expression -> boolean .)
    not             reduce using rule 28 (expression -> boolean .)
    if              reduce using rule 28 (expression -> boolean .)
    while           reduce using rule 28 (expression -> boolean .)
    true            reduce using rule 28 (expression -> boolean .)
    false           reduce using rule 28 (expression -> boolean .)
    integer         reduce using rule 28 (expression -> boolean .)
    $end            reduce using rule 28 (expression -> boolean .)
    colon           reduce using rule 28 (expression -> boolean .)
    cparen          reduce using rule 28 (expression -> boolean .)
    dedent          reduce using rule 28 (expression -> boolean .)
    comma           reduce using rule 28 (expression -> boolean .)

  ! plus            [ reduce using rule 64 (expression0 -> boolean .) ]
  ! minus           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! times           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! div             [ reduce using rule 64 (expression0 -> boolean .) ]
  ! power           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! modulo          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! lshift          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! rshift          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! floordiv        [ reduce using rule 64 (expression0 -> boolean .) ]
  ! and             [ reduce using rule 64 (expression0 -> boolean .) ]
  ! or              [ reduce using rule 64 (expression0 -> boolean .) ]
  ! xor             [ reduce using rule 64 (expression0 -> boolean .) ]
  ! strand          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! stror           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! lt              [ reduce using rule 64 (expression0 -> boolean .) ]
  ! gt              [ reduce using rule 64 (expression0 -> boolean .) ]
  ! lequal          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! gequal          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! isnotequal      [ reduce using rule 64 (expression0 -> boolean .) ]
  ! isequal         [ reduce using rule 64 (expression0 -> boolean .) ]
  ! newline         [ reduce using rule 64 (expression0 -> boolean .) ]
  ! print           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! identifier      [ reduce using rule 64 (expression0 -> boolean .) ]
  ! input           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! invert          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! oparen          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! not             [ reduce using rule 64 (expression0 -> boolean .) ]
  ! if              [ reduce using rule 64 (expression0 -> boolean .) ]
  ! while           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! true            [ reduce using rule 64 (expression0 -> boolean .) ]
  ! false           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! integer         [ reduce using rule 64 (expression0 -> boolean .) ]
  ! $end            [ reduce using rule 64 (expression0 -> boolean .) ]
  ! dedent          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! colon           [ reduce using rule 64 (expression0 -> boolean .) ]
  ! cparen          [ reduce using rule 64 (expression0 -> boolean .) ]
  ! comma           [ reduce using rule 64 (expression0 -> boolean .) ]


state 4

    (69) boolean -> false .

    plus            reduce using rule 69 (boolean -> false .)
    minus           reduce using rule 69 (boolean -> false .)
    times           reduce using rule 69 (boolean -> false .)
    div             reduce using rule 69 (boolean -> false .)
    power           reduce using rule 69 (boolean -> false .)
    modulo          reduce using rule 69 (boolean -> false .)
    lshift          reduce using rule 69 (boolean -> false .)
    rshift          reduce using rule 69 (boolean -> false .)
    floordiv        reduce using rule 69 (boolean -> false .)
    and             reduce using rule 69 (boolean -> false .)
    or              reduce using rule 69 (boolean -> false .)
    xor             reduce using rule 69 (boolean -> false .)
    strand          reduce using rule 69 (boolean -> false .)
    stror           reduce using rule 69 (boolean -> false .)
    lt              reduce using rule 69 (boolean -> false .)
    gt              reduce using rule 69 (boolean -> false .)
    lequal          reduce using rule 69 (boolean -> false .)
    gequal          reduce using rule 69 (boolean -> false .)
    isnotequal      reduce using rule 69 (boolean -> false .)
    isequal         reduce using rule 69 (boolean -> false .)
    newline         reduce using rule 69 (boolean -> false .)
    print           reduce using rule 69 (boolean -> false .)
    identifier      reduce using rule 69 (boolean -> false .)
    input           reduce using rule 69 (boolean -> false .)
    invert          reduce using rule 69 (boolean -> false .)
    oparen          reduce using rule 69 (boolean -> false .)
    not             reduce using rule 69 (boolean -> false .)
    if              reduce using rule 69 (boolean -> false .)
    while           reduce using rule 69 (boolean -> false .)
    true            reduce using rule 69 (boolean -> false .)
    false           reduce using rule 69 (boolean -> false .)
    integer         reduce using rule 69 (boolean -> false .)
    $end            reduce using rule 69 (boolean -> false .)
    dedent          reduce using rule 69 (boolean -> false .)
    colon           reduce using rule 69 (boolean -> false .)
    cparen          reduce using rule 69 (boolean -> false .)
    comma           reduce using rule 69 (boolean -> false .)


state 5

    (14) statement -> ifstmt .

    newline         reduce using rule 14 (statement -> ifstmt .)
    dedent          reduce using rule 14 (statement -> ifstmt .)
    print           reduce using rule 14 (statement -> ifstmt .)
    identifier      reduce using rule 14 (statement -> ifstmt .)
    input           reduce using rule 14 (statement -> ifstmt .)
    minus           reduce using rule 14 (statement -> ifstmt .)
    plus            reduce using rule 14 (statement -> ifstmt .)
    invert          reduce using rule 14 (statement -> ifstmt .)
    oparen          reduce using rule 14 (statement -> ifstmt .)
    not             reduce using rule 14 (statement -> ifstmt .)
    if              reduce using rule 14 (statement -> ifstmt .)
    while           reduce using rule 14 (statement -> ifstmt .)
    true            reduce using rule 14 (statement -> ifstmt .)
    false           reduce using rule 14 (statement -> ifstmt .)
    integer         reduce using rule 14 (statement -> ifstmt .)
    $end            reduce using rule 14 (statement -> ifstmt .)


state 6

    (56) ifstmt -> if . expression colon newline indent statement_list dedent
    (57) ifstmt -> if . expression colon newline indent statement_list dedent elsestmt
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 27
    boolean                        shift and go to state 3
    expression0                    shift and go to state 18
    expression                     shift and go to state 29

state 7

    (62) expression0 -> num .

    plus            reduce using rule 62 (expression0 -> num .)
    minus           reduce using rule 62 (expression0 -> num .)
    times           reduce using rule 62 (expression0 -> num .)
    div             reduce using rule 62 (expression0 -> num .)
    power           reduce using rule 62 (expression0 -> num .)
    modulo          reduce using rule 62 (expression0 -> num .)
    lshift          reduce using rule 62 (expression0 -> num .)
    rshift          reduce using rule 62 (expression0 -> num .)
    floordiv        reduce using rule 62 (expression0 -> num .)
    and             reduce using rule 62 (expression0 -> num .)
    or              reduce using rule 62 (expression0 -> num .)
    xor             reduce using rule 62 (expression0 -> num .)
    strand          reduce using rule 62 (expression0 -> num .)
    stror           reduce using rule 62 (expression0 -> num .)
    lt              reduce using rule 62 (expression0 -> num .)
    gt              reduce using rule 62 (expression0 -> num .)
    lequal          reduce using rule 62 (expression0 -> num .)
    gequal          reduce using rule 62 (expression0 -> num .)
    isnotequal      reduce using rule 62 (expression0 -> num .)
    isequal         reduce using rule 62 (expression0 -> num .)
    newline         reduce using rule 62 (expression0 -> num .)
    print           reduce using rule 62 (expression0 -> num .)
    identifier      reduce using rule 62 (expression0 -> num .)
    input           reduce using rule 62 (expression0 -> num .)
    invert          reduce using rule 62 (expression0 -> num .)
    oparen          reduce using rule 62 (expression0 -> num .)
    not             reduce using rule 62 (expression0 -> num .)
    if              reduce using rule 62 (expression0 -> num .)
    while           reduce using rule 62 (expression0 -> num .)
    true            reduce using rule 62 (expression0 -> num .)
    false           reduce using rule 62 (expression0 -> num .)
    integer         reduce using rule 62 (expression0 -> num .)
    $end            reduce using rule 62 (expression0 -> num .)
    dedent          reduce using rule 62 (expression0 -> num .)
    colon           reduce using rule 62 (expression0 -> num .)
    cparen          reduce using rule 62 (expression0 -> num .)
    comma           reduce using rule 62 (expression0 -> num .)


state 8

    (31) expression -> invert . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 30

state 9

    (3) statement_list -> statement .
    (6) statement -> statement . newline

  ! shift/reduce conflict for newline resolved as shift
    print           reduce using rule 3 (statement_list -> statement .)
    identifier      reduce using rule 3 (statement_list -> statement .)
    input           reduce using rule 3 (statement_list -> statement .)
    minus           reduce using rule 3 (statement_list -> statement .)
    plus            reduce using rule 3 (statement_list -> statement .)
    invert          reduce using rule 3 (statement_list -> statement .)
    oparen          reduce using rule 3 (statement_list -> statement .)
    not             reduce using rule 3 (statement_list -> statement .)
    if              reduce using rule 3 (statement_list -> statement .)
    while           reduce using rule 3 (statement_list -> statement .)
    true            reduce using rule 3 (statement_list -> statement .)
    false           reduce using rule 3 (statement_list -> statement .)
    integer         reduce using rule 3 (statement_list -> statement .)
    $end            reduce using rule 3 (statement_list -> statement .)
    dedent          reduce using rule 3 (statement_list -> statement .)
    newline         shift and go to state 31

  ! newline         [ reduce using rule 3 (statement_list -> statement .) ]


state 10

    (33) expression -> oparen . expression cparen
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 32

state 11

    (7) statement -> print . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 33

state 12

    (8) expression -> input . oparen parameters cparen

    oparen          shift and go to state 34


state 13

    (65) num -> integer .

    plus            reduce using rule 65 (num -> integer .)
    minus           reduce using rule 65 (num -> integer .)
    times           reduce using rule 65 (num -> integer .)
    div             reduce using rule 65 (num -> integer .)
    power           reduce using rule 65 (num -> integer .)
    modulo          reduce using rule 65 (num -> integer .)
    lshift          reduce using rule 65 (num -> integer .)
    rshift          reduce using rule 65 (num -> integer .)
    floordiv        reduce using rule 65 (num -> integer .)
    and             reduce using rule 65 (num -> integer .)
    or              reduce using rule 65 (num -> integer .)
    xor             reduce using rule 65 (num -> integer .)
    strand          reduce using rule 65 (num -> integer .)
    stror           reduce using rule 65 (num -> integer .)
    lt              reduce using rule 65 (num -> integer .)
    gt              reduce using rule 65 (num -> integer .)
    lequal          reduce using rule 65 (num -> integer .)
    gequal          reduce using rule 65 (num -> integer .)
    isnotequal      reduce using rule 65 (num -> integer .)
    isequal         reduce using rule 65 (num -> integer .)
    newline         reduce using rule 65 (num -> integer .)
    print           reduce using rule 65 (num -> integer .)
    identifier      reduce using rule 65 (num -> integer .)
    input           reduce using rule 65 (num -> integer .)
    invert          reduce using rule 65 (num -> integer .)
    oparen          reduce using rule 65 (num -> integer .)
    not             reduce using rule 65 (num -> integer .)
    if              reduce using rule 65 (num -> integer .)
    while           reduce using rule 65 (num -> integer .)
    true            reduce using rule 65 (num -> integer .)
    false           reduce using rule 65 (num -> integer .)
    integer         reduce using rule 65 (num -> integer .)
    $end            reduce using rule 65 (num -> integer .)
    colon           reduce using rule 65 (num -> integer .)
    cparen          reduce using rule 65 (num -> integer .)
    dedent          reduce using rule 65 (num -> integer .)
    comma           reduce using rule 65 (num -> integer .)


state 14

    (5) statement -> newline . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 35
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 15

    (1) module -> stmt .

    $end            reduce using rule 1 (module -> stmt .)


state 16

    (12) statement -> assname . equals expression

    equals          shift and go to state 36


state 17

    (34) expression -> not . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 37

state 18

    (32) expression -> expression0 .

    plus            reduce using rule 32 (expression -> expression0 .)
    minus           reduce using rule 32 (expression -> expression0 .)
    times           reduce using rule 32 (expression -> expression0 .)
    div             reduce using rule 32 (expression -> expression0 .)
    power           reduce using rule 32 (expression -> expression0 .)
    modulo          reduce using rule 32 (expression -> expression0 .)
    lshift          reduce using rule 32 (expression -> expression0 .)
    rshift          reduce using rule 32 (expression -> expression0 .)
    floordiv        reduce using rule 32 (expression -> expression0 .)
    and             reduce using rule 32 (expression -> expression0 .)
    or              reduce using rule 32 (expression -> expression0 .)
    xor             reduce using rule 32 (expression -> expression0 .)
    strand          reduce using rule 32 (expression -> expression0 .)
    stror           reduce using rule 32 (expression -> expression0 .)
    lt              reduce using rule 32 (expression -> expression0 .)
    gt              reduce using rule 32 (expression -> expression0 .)
    lequal          reduce using rule 32 (expression -> expression0 .)
    gequal          reduce using rule 32 (expression -> expression0 .)
    isnotequal      reduce using rule 32 (expression -> expression0 .)
    isequal         reduce using rule 32 (expression -> expression0 .)
    newline         reduce using rule 32 (expression -> expression0 .)
    print           reduce using rule 32 (expression -> expression0 .)
    identifier      reduce using rule 32 (expression -> expression0 .)
    input           reduce using rule 32 (expression -> expression0 .)
    invert          reduce using rule 32 (expression -> expression0 .)
    oparen          reduce using rule 32 (expression -> expression0 .)
    not             reduce using rule 32 (expression -> expression0 .)
    if              reduce using rule 32 (expression -> expression0 .)
    while           reduce using rule 32 (expression -> expression0 .)
    true            reduce using rule 32 (expression -> expression0 .)
    false           reduce using rule 32 (expression -> expression0 .)
    integer         reduce using rule 32 (expression -> expression0 .)
    $end            reduce using rule 32 (expression -> expression0 .)
    colon           reduce using rule 32 (expression -> expression0 .)
    cparen          reduce using rule 32 (expression -> expression0 .)
    dedent          reduce using rule 32 (expression -> expression0 .)
    comma           reduce using rule 32 (expression -> expression0 .)


state 19

    (68) boolean -> true .

    plus            reduce using rule 68 (boolean -> true .)
    minus           reduce using rule 68 (boolean -> true .)
    times           reduce using rule 68 (boolean -> true .)
    div             reduce using rule 68 (boolean -> true .)
    power           reduce using rule 68 (boolean -> true .)
    modulo          reduce using rule 68 (boolean -> true .)
    lshift          reduce using rule 68 (boolean -> true .)
    rshift          reduce using rule 68 (boolean -> true .)
    floordiv        reduce using rule 68 (boolean -> true .)
    and             reduce using rule 68 (boolean -> true .)
    or              reduce using rule 68 (boolean -> true .)
    xor             reduce using rule 68 (boolean -> true .)
    strand          reduce using rule 68 (boolean -> true .)
    stror           reduce using rule 68 (boolean -> true .)
    lt              reduce using rule 68 (boolean -> true .)
    gt              reduce using rule 68 (boolean -> true .)
    lequal          reduce using rule 68 (boolean -> true .)
    gequal          reduce using rule 68 (boolean -> true .)
    isnotequal      reduce using rule 68 (boolean -> true .)
    isequal         reduce using rule 68 (boolean -> true .)
    newline         reduce using rule 68 (boolean -> true .)
    print           reduce using rule 68 (boolean -> true .)
    identifier      reduce using rule 68 (boolean -> true .)
    input           reduce using rule 68 (boolean -> true .)
    invert          reduce using rule 68 (boolean -> true .)
    oparen          reduce using rule 68 (boolean -> true .)
    not             reduce using rule 68 (boolean -> true .)
    if              reduce using rule 68 (boolean -> true .)
    while           reduce using rule 68 (boolean -> true .)
    true            reduce using rule 68 (boolean -> true .)
    false           reduce using rule 68 (boolean -> true .)
    integer         reduce using rule 68 (boolean -> true .)
    $end            reduce using rule 68 (boolean -> true .)
    dedent          reduce using rule 68 (boolean -> true .)
    colon           reduce using rule 68 (boolean -> true .)
    cparen          reduce using rule 68 (boolean -> true .)
    comma           reduce using rule 68 (boolean -> true .)


state 20

    (16) statement -> name . incassign expression
    (17) statement -> name . decassign expression
    (18) statement -> name . divassign expression
    (19) statement -> name . mulassign expression
    (20) statement -> name . modassign expression
    (21) statement -> name . lshiftassign expression
    (22) statement -> name . rshiftassign expression
    (23) statement -> name . andassign expression
    (24) statement -> name . orassign expression
    (25) statement -> name . xorassign expression
    (26) statement -> name . powerassign expression
    (27) statement -> name . floorassign expression
    (35) expression -> name .
    (63) expression0 -> name .

  ! reduce/reduce conflict for plus resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for minus resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for times resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for div resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for power resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for modulo resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for lshift resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for rshift resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for floordiv resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for and resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for or resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for xor resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for strand resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for stror resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for lt resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for gt resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for lequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for gequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for isnotequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for isequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for newline resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for print resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for identifier resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for input resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for invert resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for oparen resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for not resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for if resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for while resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for true resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for false resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for integer resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for $end resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for dedent resolved using rule 35 (expression -> name .)
    incassign       shift and go to state 43
    decassign       shift and go to state 48
    divassign       shift and go to state 44
    mulassign       shift and go to state 45
    modassign       shift and go to state 46
    lshiftassign    shift and go to state 40
    rshiftassign    shift and go to state 41
    andassign       shift and go to state 47
    orassign        shift and go to state 39
    xorassign       shift and go to state 49
    powerassign     shift and go to state 42
    floorassign     shift and go to state 38
    plus            reduce using rule 35 (expression -> name .)
    minus           reduce using rule 35 (expression -> name .)
    times           reduce using rule 35 (expression -> name .)
    div             reduce using rule 35 (expression -> name .)
    power           reduce using rule 35 (expression -> name .)
    modulo          reduce using rule 35 (expression -> name .)
    lshift          reduce using rule 35 (expression -> name .)
    rshift          reduce using rule 35 (expression -> name .)
    floordiv        reduce using rule 35 (expression -> name .)
    and             reduce using rule 35 (expression -> name .)
    or              reduce using rule 35 (expression -> name .)
    xor             reduce using rule 35 (expression -> name .)
    strand          reduce using rule 35 (expression -> name .)
    stror           reduce using rule 35 (expression -> name .)
    lt              reduce using rule 35 (expression -> name .)
    gt              reduce using rule 35 (expression -> name .)
    lequal          reduce using rule 35 (expression -> name .)
    gequal          reduce using rule 35 (expression -> name .)
    isnotequal      reduce using rule 35 (expression -> name .)
    isequal         reduce using rule 35 (expression -> name .)
    newline         reduce using rule 35 (expression -> name .)
    dedent          reduce using rule 35 (expression -> name .)
    print           reduce using rule 35 (expression -> name .)
    identifier      reduce using rule 35 (expression -> name .)
    input           reduce using rule 35 (expression -> name .)
    invert          reduce using rule 35 (expression -> name .)
    oparen          reduce using rule 35 (expression -> name .)
    not             reduce using rule 35 (expression -> name .)
    if              reduce using rule 35 (expression -> name .)
    while           reduce using rule 35 (expression -> name .)
    true            reduce using rule 35 (expression -> name .)
    false           reduce using rule 35 (expression -> name .)
    integer         reduce using rule 35 (expression -> name .)
    $end            reduce using rule 35 (expression -> name .)

  ! plus            [ reduce using rule 63 (expression0 -> name .) ]
  ! minus           [ reduce using rule 63 (expression0 -> name .) ]
  ! times           [ reduce using rule 63 (expression0 -> name .) ]
  ! div             [ reduce using rule 63 (expression0 -> name .) ]
  ! power           [ reduce using rule 63 (expression0 -> name .) ]
  ! modulo          [ reduce using rule 63 (expression0 -> name .) ]
  ! lshift          [ reduce using rule 63 (expression0 -> name .) ]
  ! rshift          [ reduce using rule 63 (expression0 -> name .) ]
  ! floordiv        [ reduce using rule 63 (expression0 -> name .) ]
  ! and             [ reduce using rule 63 (expression0 -> name .) ]
  ! or              [ reduce using rule 63 (expression0 -> name .) ]
  ! xor             [ reduce using rule 63 (expression0 -> name .) ]
  ! strand          [ reduce using rule 63 (expression0 -> name .) ]
  ! stror           [ reduce using rule 63 (expression0 -> name .) ]
  ! lt              [ reduce using rule 63 (expression0 -> name .) ]
  ! gt              [ reduce using rule 63 (expression0 -> name .) ]
  ! lequal          [ reduce using rule 63 (expression0 -> name .) ]
  ! gequal          [ reduce using rule 63 (expression0 -> name .) ]
  ! isnotequal      [ reduce using rule 63 (expression0 -> name .) ]
  ! isequal         [ reduce using rule 63 (expression0 -> name .) ]
  ! newline         [ reduce using rule 63 (expression0 -> name .) ]
  ! print           [ reduce using rule 63 (expression0 -> name .) ]
  ! identifier      [ reduce using rule 63 (expression0 -> name .) ]
  ! input           [ reduce using rule 63 (expression0 -> name .) ]
  ! invert          [ reduce using rule 63 (expression0 -> name .) ]
  ! oparen          [ reduce using rule 63 (expression0 -> name .) ]
  ! not             [ reduce using rule 63 (expression0 -> name .) ]
  ! if              [ reduce using rule 63 (expression0 -> name .) ]
  ! while           [ reduce using rule 63 (expression0 -> name .) ]
  ! true            [ reduce using rule 63 (expression0 -> name .) ]
  ! false           [ reduce using rule 63 (expression0 -> name .) ]
  ! integer         [ reduce using rule 63 (expression0 -> name .) ]
  ! $end            [ reduce using rule 63 (expression0 -> name .) ]
  ! dedent          [ reduce using rule 63 (expression0 -> name .) ]


state 21

    (61) whilestmt -> while . expression colon newline indent statement_list dedent
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 27
    boolean                        shift and go to state 3
    expression0                    shift and go to state 18
    expression                     shift and go to state 50

state 22

    (30) expression -> plus . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 51

state 23

    (2) stmt -> statement_list .
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    $end            reduce using rule 2 (stmt -> statement_list .)
    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 52
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 24

    (66) assname -> identifier .
    (67) name -> identifier .

    equals          reduce using rule 66 (assname -> identifier .)
    incassign       reduce using rule 67 (name -> identifier .)
    decassign       reduce using rule 67 (name -> identifier .)
    divassign       reduce using rule 67 (name -> identifier .)
    mulassign       reduce using rule 67 (name -> identifier .)
    modassign       reduce using rule 67 (name -> identifier .)
    lshiftassign    reduce using rule 67 (name -> identifier .)
    rshiftassign    reduce using rule 67 (name -> identifier .)
    andassign       reduce using rule 67 (name -> identifier .)
    orassign        reduce using rule 67 (name -> identifier .)
    xorassign       reduce using rule 67 (name -> identifier .)
    powerassign     reduce using rule 67 (name -> identifier .)
    floorassign     reduce using rule 67 (name -> identifier .)
    plus            reduce using rule 67 (name -> identifier .)
    minus           reduce using rule 67 (name -> identifier .)
    times           reduce using rule 67 (name -> identifier .)
    div             reduce using rule 67 (name -> identifier .)
    power           reduce using rule 67 (name -> identifier .)
    modulo          reduce using rule 67 (name -> identifier .)
    lshift          reduce using rule 67 (name -> identifier .)
    rshift          reduce using rule 67 (name -> identifier .)
    floordiv        reduce using rule 67 (name -> identifier .)
    and             reduce using rule 67 (name -> identifier .)
    or              reduce using rule 67 (name -> identifier .)
    xor             reduce using rule 67 (name -> identifier .)
    strand          reduce using rule 67 (name -> identifier .)
    stror           reduce using rule 67 (name -> identifier .)
    lt              reduce using rule 67 (name -> identifier .)
    gt              reduce using rule 67 (name -> identifier .)
    lequal          reduce using rule 67 (name -> identifier .)
    gequal          reduce using rule 67 (name -> identifier .)
    isnotequal      reduce using rule 67 (name -> identifier .)
    isequal         reduce using rule 67 (name -> identifier .)
    newline         reduce using rule 67 (name -> identifier .)
    dedent          reduce using rule 67 (name -> identifier .)
    print           reduce using rule 67 (name -> identifier .)
    identifier      reduce using rule 67 (name -> identifier .)
    input           reduce using rule 67 (name -> identifier .)
    invert          reduce using rule 67 (name -> identifier .)
    oparen          reduce using rule 67 (name -> identifier .)
    not             reduce using rule 67 (name -> identifier .)
    if              reduce using rule 67 (name -> identifier .)
    while           reduce using rule 67 (name -> identifier .)
    true            reduce using rule 67 (name -> identifier .)
    false           reduce using rule 67 (name -> identifier .)
    integer         reduce using rule 67 (name -> identifier .)
    $end            reduce using rule 67 (name -> identifier .)


state 25

    (13) statement -> expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 13 (statement -> expression .)
    dedent          reduce using rule 13 (statement -> expression .)
    print           reduce using rule 13 (statement -> expression .)
    identifier      reduce using rule 13 (statement -> expression .)
    input           reduce using rule 13 (statement -> expression .)
    invert          reduce using rule 13 (statement -> expression .)
    oparen          reduce using rule 13 (statement -> expression .)
    not             reduce using rule 13 (statement -> expression .)
    if              reduce using rule 13 (statement -> expression .)
    while           reduce using rule 13 (statement -> expression .)
    true            reduce using rule 13 (statement -> expression .)
    false           reduce using rule 13 (statement -> expression .)
    integer         reduce using rule 13 (statement -> expression .)
    $end            reduce using rule 13 (statement -> expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 13 (statement -> expression .) ]
  ! plus            [ reduce using rule 13 (statement -> expression .) ]


state 26

    (29) expression -> minus . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 73

state 27

    (35) expression -> name .
    (63) expression0 -> name .

  ! reduce/reduce conflict for plus resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for minus resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for times resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for div resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for power resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for modulo resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for lshift resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for rshift resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for floordiv resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for and resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for or resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for xor resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for strand resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for stror resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for lt resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for gt resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for lequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for gequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for isnotequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for isequal resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for newline resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for print resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for identifier resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for input resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for invert resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for oparen resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for not resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for if resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for while resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for true resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for false resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for integer resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for $end resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for colon resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for cparen resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for dedent resolved using rule 35 (expression -> name .)
  ! reduce/reduce conflict for comma resolved using rule 35 (expression -> name .)
    plus            reduce using rule 35 (expression -> name .)
    minus           reduce using rule 35 (expression -> name .)
    times           reduce using rule 35 (expression -> name .)
    div             reduce using rule 35 (expression -> name .)
    power           reduce using rule 35 (expression -> name .)
    modulo          reduce using rule 35 (expression -> name .)
    lshift          reduce using rule 35 (expression -> name .)
    rshift          reduce using rule 35 (expression -> name .)
    floordiv        reduce using rule 35 (expression -> name .)
    and             reduce using rule 35 (expression -> name .)
    or              reduce using rule 35 (expression -> name .)
    xor             reduce using rule 35 (expression -> name .)
    strand          reduce using rule 35 (expression -> name .)
    stror           reduce using rule 35 (expression -> name .)
    lt              reduce using rule 35 (expression -> name .)
    gt              reduce using rule 35 (expression -> name .)
    lequal          reduce using rule 35 (expression -> name .)
    gequal          reduce using rule 35 (expression -> name .)
    isnotequal      reduce using rule 35 (expression -> name .)
    isequal         reduce using rule 35 (expression -> name .)
    newline         reduce using rule 35 (expression -> name .)
    print           reduce using rule 35 (expression -> name .)
    identifier      reduce using rule 35 (expression -> name .)
    input           reduce using rule 35 (expression -> name .)
    invert          reduce using rule 35 (expression -> name .)
    oparen          reduce using rule 35 (expression -> name .)
    not             reduce using rule 35 (expression -> name .)
    if              reduce using rule 35 (expression -> name .)
    while           reduce using rule 35 (expression -> name .)
    true            reduce using rule 35 (expression -> name .)
    false           reduce using rule 35 (expression -> name .)
    integer         reduce using rule 35 (expression -> name .)
    $end            reduce using rule 35 (expression -> name .)
    colon           reduce using rule 35 (expression -> name .)
    cparen          reduce using rule 35 (expression -> name .)
    dedent          reduce using rule 35 (expression -> name .)
    comma           reduce using rule 35 (expression -> name .)

  ! plus            [ reduce using rule 63 (expression0 -> name .) ]
  ! minus           [ reduce using rule 63 (expression0 -> name .) ]
  ! times           [ reduce using rule 63 (expression0 -> name .) ]
  ! div             [ reduce using rule 63 (expression0 -> name .) ]
  ! power           [ reduce using rule 63 (expression0 -> name .) ]
  ! modulo          [ reduce using rule 63 (expression0 -> name .) ]
  ! lshift          [ reduce using rule 63 (expression0 -> name .) ]
  ! rshift          [ reduce using rule 63 (expression0 -> name .) ]
  ! floordiv        [ reduce using rule 63 (expression0 -> name .) ]
  ! and             [ reduce using rule 63 (expression0 -> name .) ]
  ! or              [ reduce using rule 63 (expression0 -> name .) ]
  ! xor             [ reduce using rule 63 (expression0 -> name .) ]
  ! strand          [ reduce using rule 63 (expression0 -> name .) ]
  ! stror           [ reduce using rule 63 (expression0 -> name .) ]
  ! lt              [ reduce using rule 63 (expression0 -> name .) ]
  ! gt              [ reduce using rule 63 (expression0 -> name .) ]
  ! lequal          [ reduce using rule 63 (expression0 -> name .) ]
  ! gequal          [ reduce using rule 63 (expression0 -> name .) ]
  ! isnotequal      [ reduce using rule 63 (expression0 -> name .) ]
  ! isequal         [ reduce using rule 63 (expression0 -> name .) ]
  ! newline         [ reduce using rule 63 (expression0 -> name .) ]
  ! print           [ reduce using rule 63 (expression0 -> name .) ]
  ! identifier      [ reduce using rule 63 (expression0 -> name .) ]
  ! input           [ reduce using rule 63 (expression0 -> name .) ]
  ! invert          [ reduce using rule 63 (expression0 -> name .) ]
  ! oparen          [ reduce using rule 63 (expression0 -> name .) ]
  ! not             [ reduce using rule 63 (expression0 -> name .) ]
  ! if              [ reduce using rule 63 (expression0 -> name .) ]
  ! while           [ reduce using rule 63 (expression0 -> name .) ]
  ! true            [ reduce using rule 63 (expression0 -> name .) ]
  ! false           [ reduce using rule 63 (expression0 -> name .) ]
  ! integer         [ reduce using rule 63 (expression0 -> name .) ]
  ! $end            [ reduce using rule 63 (expression0 -> name .) ]
  ! colon           [ reduce using rule 63 (expression0 -> name .) ]
  ! cparen          [ reduce using rule 63 (expression0 -> name .) ]
  ! dedent          [ reduce using rule 63 (expression0 -> name .) ]
  ! comma           [ reduce using rule 63 (expression0 -> name .) ]


state 28

    (67) name -> identifier .

    plus            reduce using rule 67 (name -> identifier .)
    minus           reduce using rule 67 (name -> identifier .)
    times           reduce using rule 67 (name -> identifier .)
    div             reduce using rule 67 (name -> identifier .)
    power           reduce using rule 67 (name -> identifier .)
    modulo          reduce using rule 67 (name -> identifier .)
    lshift          reduce using rule 67 (name -> identifier .)
    rshift          reduce using rule 67 (name -> identifier .)
    floordiv        reduce using rule 67 (name -> identifier .)
    and             reduce using rule 67 (name -> identifier .)
    or              reduce using rule 67 (name -> identifier .)
    xor             reduce using rule 67 (name -> identifier .)
    strand          reduce using rule 67 (name -> identifier .)
    stror           reduce using rule 67 (name -> identifier .)
    lt              reduce using rule 67 (name -> identifier .)
    gt              reduce using rule 67 (name -> identifier .)
    lequal          reduce using rule 67 (name -> identifier .)
    gequal          reduce using rule 67 (name -> identifier .)
    isnotequal      reduce using rule 67 (name -> identifier .)
    isequal         reduce using rule 67 (name -> identifier .)
    newline         reduce using rule 67 (name -> identifier .)
    print           reduce using rule 67 (name -> identifier .)
    identifier      reduce using rule 67 (name -> identifier .)
    input           reduce using rule 67 (name -> identifier .)
    invert          reduce using rule 67 (name -> identifier .)
    oparen          reduce using rule 67 (name -> identifier .)
    not             reduce using rule 67 (name -> identifier .)
    if              reduce using rule 67 (name -> identifier .)
    while           reduce using rule 67 (name -> identifier .)
    true            reduce using rule 67 (name -> identifier .)
    false           reduce using rule 67 (name -> identifier .)
    integer         reduce using rule 67 (name -> identifier .)
    $end            reduce using rule 67 (name -> identifier .)
    colon           reduce using rule 67 (name -> identifier .)
    cparen          reduce using rule 67 (name -> identifier .)
    dedent          reduce using rule 67 (name -> identifier .)
    comma           reduce using rule 67 (name -> identifier .)


state 29

    (56) ifstmt -> if expression . colon newline indent statement_list dedent
    (57) ifstmt -> if expression . colon newline indent statement_list dedent elsestmt
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    colon           shift and go to state 74
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68


state 30

    (31) expression -> invert expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 31 (expression -> invert expression .)
    minus           reduce using rule 31 (expression -> invert expression .)
    times           reduce using rule 31 (expression -> invert expression .)
    div             reduce using rule 31 (expression -> invert expression .)
    modulo          reduce using rule 31 (expression -> invert expression .)
    lshift          reduce using rule 31 (expression -> invert expression .)
    rshift          reduce using rule 31 (expression -> invert expression .)
    floordiv        reduce using rule 31 (expression -> invert expression .)
    and             reduce using rule 31 (expression -> invert expression .)
    or              reduce using rule 31 (expression -> invert expression .)
    xor             reduce using rule 31 (expression -> invert expression .)
    strand          reduce using rule 31 (expression -> invert expression .)
    stror           reduce using rule 31 (expression -> invert expression .)
    lt              reduce using rule 31 (expression -> invert expression .)
    gt              reduce using rule 31 (expression -> invert expression .)
    lequal          reduce using rule 31 (expression -> invert expression .)
    gequal          reduce using rule 31 (expression -> invert expression .)
    isnotequal      reduce using rule 31 (expression -> invert expression .)
    isequal         reduce using rule 31 (expression -> invert expression .)
    newline         reduce using rule 31 (expression -> invert expression .)
    print           reduce using rule 31 (expression -> invert expression .)
    identifier      reduce using rule 31 (expression -> invert expression .)
    input           reduce using rule 31 (expression -> invert expression .)
    invert          reduce using rule 31 (expression -> invert expression .)
    oparen          reduce using rule 31 (expression -> invert expression .)
    not             reduce using rule 31 (expression -> invert expression .)
    if              reduce using rule 31 (expression -> invert expression .)
    while           reduce using rule 31 (expression -> invert expression .)
    true            reduce using rule 31 (expression -> invert expression .)
    false           reduce using rule 31 (expression -> invert expression .)
    integer         reduce using rule 31 (expression -> invert expression .)
    $end            reduce using rule 31 (expression -> invert expression .)
    colon           reduce using rule 31 (expression -> invert expression .)
    cparen          reduce using rule 31 (expression -> invert expression .)
    dedent          reduce using rule 31 (expression -> invert expression .)
    comma           reduce using rule 31 (expression -> invert expression .)
    power           shift and go to state 56

  ! power           [ reduce using rule 31 (expression -> invert expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! times           [ shift and go to state 62 ]
  ! div             [ shift and go to state 70 ]
  ! modulo          [ shift and go to state 55 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! floordiv        [ shift and go to state 64 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 31

    (6) statement -> statement newline .

    newline         reduce using rule 6 (statement -> statement newline .)
    dedent          reduce using rule 6 (statement -> statement newline .)
    print           reduce using rule 6 (statement -> statement newline .)
    identifier      reduce using rule 6 (statement -> statement newline .)
    input           reduce using rule 6 (statement -> statement newline .)
    minus           reduce using rule 6 (statement -> statement newline .)
    plus            reduce using rule 6 (statement -> statement newline .)
    invert          reduce using rule 6 (statement -> statement newline .)
    oparen          reduce using rule 6 (statement -> statement newline .)
    not             reduce using rule 6 (statement -> statement newline .)
    if              reduce using rule 6 (statement -> statement newline .)
    while           reduce using rule 6 (statement -> statement newline .)
    true            reduce using rule 6 (statement -> statement newline .)
    false           reduce using rule 6 (statement -> statement newline .)
    integer         reduce using rule 6 (statement -> statement newline .)
    $end            reduce using rule 6 (statement -> statement newline .)


state 32

    (33) expression -> oparen expression . cparen
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    cparen          shift and go to state 75
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68


state 33

    (7) statement -> print expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    newline         reduce using rule 7 (statement -> print expression .)
    dedent          reduce using rule 7 (statement -> print expression .)
    print           reduce using rule 7 (statement -> print expression .)
    identifier      reduce using rule 7 (statement -> print expression .)
    input           reduce using rule 7 (statement -> print expression .)
    invert          reduce using rule 7 (statement -> print expression .)
    oparen          reduce using rule 7 (statement -> print expression .)
    not             reduce using rule 7 (statement -> print expression .)
    if              reduce using rule 7 (statement -> print expression .)
    while           reduce using rule 7 (statement -> print expression .)
    true            reduce using rule 7 (statement -> print expression .)
    false           reduce using rule 7 (statement -> print expression .)
    integer         reduce using rule 7 (statement -> print expression .)
    $end            reduce using rule 7 (statement -> print expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 7 (statement -> print expression .) ]
  ! plus            [ reduce using rule 7 (statement -> print expression .) ]


state 34

    (8) expression -> input oparen . parameters cparen
    (9) parameters -> . expression
    (10) parameters -> . parameters comma expression
    (11) parameters -> .
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    cparen          reduce using rule 11 (parameters -> .)
    comma           reduce using rule 11 (parameters -> .)
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    parameters                     shift and go to state 76
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 77

state 35

    (5) statement -> newline statement .
    (6) statement -> statement . newline

  ! shift/reduce conflict for newline resolved as shift
    dedent          reduce using rule 5 (statement -> newline statement .)
    print           reduce using rule 5 (statement -> newline statement .)
    identifier      reduce using rule 5 (statement -> newline statement .)
    input           reduce using rule 5 (statement -> newline statement .)
    minus           reduce using rule 5 (statement -> newline statement .)
    plus            reduce using rule 5 (statement -> newline statement .)
    invert          reduce using rule 5 (statement -> newline statement .)
    oparen          reduce using rule 5 (statement -> newline statement .)
    not             reduce using rule 5 (statement -> newline statement .)
    if              reduce using rule 5 (statement -> newline statement .)
    while           reduce using rule 5 (statement -> newline statement .)
    true            reduce using rule 5 (statement -> newline statement .)
    false           reduce using rule 5 (statement -> newline statement .)
    integer         reduce using rule 5 (statement -> newline statement .)
    $end            reduce using rule 5 (statement -> newline statement .)
    newline         shift and go to state 31

  ! newline         [ reduce using rule 5 (statement -> newline statement .) ]


state 36

    (12) statement -> assname equals . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 27
    boolean                        shift and go to state 3
    expression0                    shift and go to state 18
    expression                     shift and go to state 78

state 37

    (34) expression -> not expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    stror           reduce using rule 34 (expression -> not expression .)
    newline         reduce using rule 34 (expression -> not expression .)
    print           reduce using rule 34 (expression -> not expression .)
    identifier      reduce using rule 34 (expression -> not expression .)
    input           reduce using rule 34 (expression -> not expression .)
    invert          reduce using rule 34 (expression -> not expression .)
    oparen          reduce using rule 34 (expression -> not expression .)
    not             reduce using rule 34 (expression -> not expression .)
    if              reduce using rule 34 (expression -> not expression .)
    while           reduce using rule 34 (expression -> not expression .)
    true            reduce using rule 34 (expression -> not expression .)
    false           reduce using rule 34 (expression -> not expression .)
    integer         reduce using rule 34 (expression -> not expression .)
    $end            reduce using rule 34 (expression -> not expression .)
    colon           reduce using rule 34 (expression -> not expression .)
    cparen          reduce using rule 34 (expression -> not expression .)
    dedent          reduce using rule 34 (expression -> not expression .)
    comma           reduce using rule 34 (expression -> not expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! plus            [ reduce using rule 34 (expression -> not expression .) ]
  ! minus           [ reduce using rule 34 (expression -> not expression .) ]
  ! times           [ reduce using rule 34 (expression -> not expression .) ]
  ! div             [ reduce using rule 34 (expression -> not expression .) ]
  ! power           [ reduce using rule 34 (expression -> not expression .) ]
  ! modulo          [ reduce using rule 34 (expression -> not expression .) ]
  ! lshift          [ reduce using rule 34 (expression -> not expression .) ]
  ! rshift          [ reduce using rule 34 (expression -> not expression .) ]
  ! floordiv        [ reduce using rule 34 (expression -> not expression .) ]
  ! and             [ reduce using rule 34 (expression -> not expression .) ]
  ! or              [ reduce using rule 34 (expression -> not expression .) ]
  ! xor             [ reduce using rule 34 (expression -> not expression .) ]
  ! strand          [ reduce using rule 34 (expression -> not expression .) ]
  ! lt              [ reduce using rule 34 (expression -> not expression .) ]
  ! gt              [ reduce using rule 34 (expression -> not expression .) ]
  ! lequal          [ reduce using rule 34 (expression -> not expression .) ]
  ! gequal          [ reduce using rule 34 (expression -> not expression .) ]
  ! isnotequal      [ reduce using rule 34 (expression -> not expression .) ]
  ! isequal         [ reduce using rule 34 (expression -> not expression .) ]
  ! stror           [ shift and go to state 57 ]


state 38

    (27) statement -> name floorassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 79

state 39

    (24) statement -> name orassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 80

state 40

    (21) statement -> name lshiftassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 81

state 41

    (22) statement -> name rshiftassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 82

state 42

    (26) statement -> name powerassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 83

state 43

    (16) statement -> name incassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 84

state 44

    (18) statement -> name divassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 85

state 45

    (19) statement -> name mulassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 86

state 46

    (20) statement -> name modassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 87

state 47

    (23) statement -> name andassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 88

state 48

    (17) statement -> name decassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 89

state 49

    (25) statement -> name xorassign . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 90

state 50

    (61) whilestmt -> while expression . colon newline indent statement_list dedent
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    colon           shift and go to state 91
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68


state 51

    (30) expression -> plus expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 30 (expression -> plus expression .)
    minus           reduce using rule 30 (expression -> plus expression .)
    lshift          reduce using rule 30 (expression -> plus expression .)
    rshift          reduce using rule 30 (expression -> plus expression .)
    and             reduce using rule 30 (expression -> plus expression .)
    or              reduce using rule 30 (expression -> plus expression .)
    xor             reduce using rule 30 (expression -> plus expression .)
    strand          reduce using rule 30 (expression -> plus expression .)
    stror           reduce using rule 30 (expression -> plus expression .)
    lt              reduce using rule 30 (expression -> plus expression .)
    gt              reduce using rule 30 (expression -> plus expression .)
    lequal          reduce using rule 30 (expression -> plus expression .)
    gequal          reduce using rule 30 (expression -> plus expression .)
    isnotequal      reduce using rule 30 (expression -> plus expression .)
    isequal         reduce using rule 30 (expression -> plus expression .)
    newline         reduce using rule 30 (expression -> plus expression .)
    print           reduce using rule 30 (expression -> plus expression .)
    identifier      reduce using rule 30 (expression -> plus expression .)
    input           reduce using rule 30 (expression -> plus expression .)
    invert          reduce using rule 30 (expression -> plus expression .)
    oparen          reduce using rule 30 (expression -> plus expression .)
    not             reduce using rule 30 (expression -> plus expression .)
    if              reduce using rule 30 (expression -> plus expression .)
    while           reduce using rule 30 (expression -> plus expression .)
    true            reduce using rule 30 (expression -> plus expression .)
    false           reduce using rule 30 (expression -> plus expression .)
    integer         reduce using rule 30 (expression -> plus expression .)
    $end            reduce using rule 30 (expression -> plus expression .)
    colon           reduce using rule 30 (expression -> plus expression .)
    cparen          reduce using rule 30 (expression -> plus expression .)
    dedent          reduce using rule 30 (expression -> plus expression .)
    comma           reduce using rule 30 (expression -> plus expression .)
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    floordiv        shift and go to state 64

  ! times           [ reduce using rule 30 (expression -> plus expression .) ]
  ! div             [ reduce using rule 30 (expression -> plus expression .) ]
  ! power           [ reduce using rule 30 (expression -> plus expression .) ]
  ! modulo          [ reduce using rule 30 (expression -> plus expression .) ]
  ! floordiv        [ reduce using rule 30 (expression -> plus expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 52

    (4) statement_list -> statement_list statement .
    (6) statement -> statement . newline

  ! shift/reduce conflict for newline resolved as shift
    print           reduce using rule 4 (statement_list -> statement_list statement .)
    identifier      reduce using rule 4 (statement_list -> statement_list statement .)
    input           reduce using rule 4 (statement_list -> statement_list statement .)
    minus           reduce using rule 4 (statement_list -> statement_list statement .)
    plus            reduce using rule 4 (statement_list -> statement_list statement .)
    invert          reduce using rule 4 (statement_list -> statement_list statement .)
    oparen          reduce using rule 4 (statement_list -> statement_list statement .)
    not             reduce using rule 4 (statement_list -> statement_list statement .)
    if              reduce using rule 4 (statement_list -> statement_list statement .)
    while           reduce using rule 4 (statement_list -> statement_list statement .)
    true            reduce using rule 4 (statement_list -> statement_list statement .)
    false           reduce using rule 4 (statement_list -> statement_list statement .)
    integer         reduce using rule 4 (statement_list -> statement_list statement .)
    $end            reduce using rule 4 (statement_list -> statement_list statement .)
    dedent          reduce using rule 4 (statement_list -> statement_list statement .)
    newline         shift and go to state 31

  ! newline         [ reduce using rule 4 (statement_list -> statement_list statement .) ]


state 53

    (45) expression -> expression and . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 92

state 54

    (46) expression -> expression or . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 93

state 55

    (41) expression -> expression modulo . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 94

state 56

    (40) expression -> expression power . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 95

state 57

    (49) expression -> expression stror . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 96

state 58

    (53) expression -> expression gequal . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 97

state 59

    (54) expression -> expression isnotequal . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 98

state 60

    (52) expression -> expression lequal . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 99

state 61

    (47) expression -> expression xor . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 100

state 62

    (38) expression -> expression times . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 101

state 63

    (50) expression -> expression lt . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 102

state 64

    (44) expression -> expression floordiv . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 103

state 65

    (36) expression -> expression plus . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 104

state 66

    (51) expression -> expression gt . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 105

state 67

    (42) expression -> expression lshift . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 106

state 68

    (55) expression -> expression isequal . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 107

state 69

    (43) expression -> expression rshift . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 108

state 70

    (39) expression -> expression div . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 109

state 71

    (37) expression -> expression minus . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 110

state 72

    (48) expression -> expression strand . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 111

state 73

    (29) expression -> minus expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 29 (expression -> minus expression .)
    minus           reduce using rule 29 (expression -> minus expression .)
    lshift          reduce using rule 29 (expression -> minus expression .)
    rshift          reduce using rule 29 (expression -> minus expression .)
    and             reduce using rule 29 (expression -> minus expression .)
    or              reduce using rule 29 (expression -> minus expression .)
    xor             reduce using rule 29 (expression -> minus expression .)
    strand          reduce using rule 29 (expression -> minus expression .)
    stror           reduce using rule 29 (expression -> minus expression .)
    lt              reduce using rule 29 (expression -> minus expression .)
    gt              reduce using rule 29 (expression -> minus expression .)
    lequal          reduce using rule 29 (expression -> minus expression .)
    gequal          reduce using rule 29 (expression -> minus expression .)
    isnotequal      reduce using rule 29 (expression -> minus expression .)
    isequal         reduce using rule 29 (expression -> minus expression .)
    newline         reduce using rule 29 (expression -> minus expression .)
    print           reduce using rule 29 (expression -> minus expression .)
    identifier      reduce using rule 29 (expression -> minus expression .)
    input           reduce using rule 29 (expression -> minus expression .)
    invert          reduce using rule 29 (expression -> minus expression .)
    oparen          reduce using rule 29 (expression -> minus expression .)
    not             reduce using rule 29 (expression -> minus expression .)
    if              reduce using rule 29 (expression -> minus expression .)
    while           reduce using rule 29 (expression -> minus expression .)
    true            reduce using rule 29 (expression -> minus expression .)
    false           reduce using rule 29 (expression -> minus expression .)
    integer         reduce using rule 29 (expression -> minus expression .)
    $end            reduce using rule 29 (expression -> minus expression .)
    colon           reduce using rule 29 (expression -> minus expression .)
    cparen          reduce using rule 29 (expression -> minus expression .)
    dedent          reduce using rule 29 (expression -> minus expression .)
    comma           reduce using rule 29 (expression -> minus expression .)
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    floordiv        shift and go to state 64

  ! times           [ reduce using rule 29 (expression -> minus expression .) ]
  ! div             [ reduce using rule 29 (expression -> minus expression .) ]
  ! power           [ reduce using rule 29 (expression -> minus expression .) ]
  ! modulo          [ reduce using rule 29 (expression -> minus expression .) ]
  ! floordiv        [ reduce using rule 29 (expression -> minus expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 74

    (56) ifstmt -> if expression colon . newline indent statement_list dedent
    (57) ifstmt -> if expression colon . newline indent statement_list dedent elsestmt

    newline         shift and go to state 112


state 75

    (33) expression -> oparen expression cparen .

    plus            reduce using rule 33 (expression -> oparen expression cparen .)
    minus           reduce using rule 33 (expression -> oparen expression cparen .)
    times           reduce using rule 33 (expression -> oparen expression cparen .)
    div             reduce using rule 33 (expression -> oparen expression cparen .)
    power           reduce using rule 33 (expression -> oparen expression cparen .)
    modulo          reduce using rule 33 (expression -> oparen expression cparen .)
    lshift          reduce using rule 33 (expression -> oparen expression cparen .)
    rshift          reduce using rule 33 (expression -> oparen expression cparen .)
    floordiv        reduce using rule 33 (expression -> oparen expression cparen .)
    and             reduce using rule 33 (expression -> oparen expression cparen .)
    or              reduce using rule 33 (expression -> oparen expression cparen .)
    xor             reduce using rule 33 (expression -> oparen expression cparen .)
    strand          reduce using rule 33 (expression -> oparen expression cparen .)
    stror           reduce using rule 33 (expression -> oparen expression cparen .)
    lt              reduce using rule 33 (expression -> oparen expression cparen .)
    gt              reduce using rule 33 (expression -> oparen expression cparen .)
    lequal          reduce using rule 33 (expression -> oparen expression cparen .)
    gequal          reduce using rule 33 (expression -> oparen expression cparen .)
    isnotequal      reduce using rule 33 (expression -> oparen expression cparen .)
    isequal         reduce using rule 33 (expression -> oparen expression cparen .)
    newline         reduce using rule 33 (expression -> oparen expression cparen .)
    print           reduce using rule 33 (expression -> oparen expression cparen .)
    identifier      reduce using rule 33 (expression -> oparen expression cparen .)
    input           reduce using rule 33 (expression -> oparen expression cparen .)
    invert          reduce using rule 33 (expression -> oparen expression cparen .)
    oparen          reduce using rule 33 (expression -> oparen expression cparen .)
    not             reduce using rule 33 (expression -> oparen expression cparen .)
    if              reduce using rule 33 (expression -> oparen expression cparen .)
    while           reduce using rule 33 (expression -> oparen expression cparen .)
    true            reduce using rule 33 (expression -> oparen expression cparen .)
    false           reduce using rule 33 (expression -> oparen expression cparen .)
    integer         reduce using rule 33 (expression -> oparen expression cparen .)
    $end            reduce using rule 33 (expression -> oparen expression cparen .)
    colon           reduce using rule 33 (expression -> oparen expression cparen .)
    cparen          reduce using rule 33 (expression -> oparen expression cparen .)
    dedent          reduce using rule 33 (expression -> oparen expression cparen .)
    comma           reduce using rule 33 (expression -> oparen expression cparen .)


state 76

    (8) expression -> input oparen parameters . cparen
    (10) parameters -> parameters . comma expression

    cparen          shift and go to state 113
    comma           shift and go to state 114


state 77

    (9) parameters -> expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    cparen          reduce using rule 9 (parameters -> expression .)
    comma           reduce using rule 9 (parameters -> expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68


state 78

    (12) statement -> assname equals expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 12 (statement -> assname equals expression .)
    dedent          reduce using rule 12 (statement -> assname equals expression .)
    print           reduce using rule 12 (statement -> assname equals expression .)
    identifier      reduce using rule 12 (statement -> assname equals expression .)
    input           reduce using rule 12 (statement -> assname equals expression .)
    invert          reduce using rule 12 (statement -> assname equals expression .)
    oparen          reduce using rule 12 (statement -> assname equals expression .)
    not             reduce using rule 12 (statement -> assname equals expression .)
    if              reduce using rule 12 (statement -> assname equals expression .)
    while           reduce using rule 12 (statement -> assname equals expression .)
    true            reduce using rule 12 (statement -> assname equals expression .)
    false           reduce using rule 12 (statement -> assname equals expression .)
    integer         reduce using rule 12 (statement -> assname equals expression .)
    $end            reduce using rule 12 (statement -> assname equals expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 12 (statement -> assname equals expression .) ]
  ! plus            [ reduce using rule 12 (statement -> assname equals expression .) ]


state 79

    (27) statement -> name floorassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 27 (statement -> name floorassign expression .)
    dedent          reduce using rule 27 (statement -> name floorassign expression .)
    print           reduce using rule 27 (statement -> name floorassign expression .)
    identifier      reduce using rule 27 (statement -> name floorassign expression .)
    input           reduce using rule 27 (statement -> name floorassign expression .)
    invert          reduce using rule 27 (statement -> name floorassign expression .)
    oparen          reduce using rule 27 (statement -> name floorassign expression .)
    not             reduce using rule 27 (statement -> name floorassign expression .)
    if              reduce using rule 27 (statement -> name floorassign expression .)
    while           reduce using rule 27 (statement -> name floorassign expression .)
    true            reduce using rule 27 (statement -> name floorassign expression .)
    false           reduce using rule 27 (statement -> name floorassign expression .)
    integer         reduce using rule 27 (statement -> name floorassign expression .)
    $end            reduce using rule 27 (statement -> name floorassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 27 (statement -> name floorassign expression .) ]
  ! plus            [ reduce using rule 27 (statement -> name floorassign expression .) ]


state 80

    (24) statement -> name orassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 24 (statement -> name orassign expression .)
    dedent          reduce using rule 24 (statement -> name orassign expression .)
    print           reduce using rule 24 (statement -> name orassign expression .)
    identifier      reduce using rule 24 (statement -> name orassign expression .)
    input           reduce using rule 24 (statement -> name orassign expression .)
    invert          reduce using rule 24 (statement -> name orassign expression .)
    oparen          reduce using rule 24 (statement -> name orassign expression .)
    not             reduce using rule 24 (statement -> name orassign expression .)
    if              reduce using rule 24 (statement -> name orassign expression .)
    while           reduce using rule 24 (statement -> name orassign expression .)
    true            reduce using rule 24 (statement -> name orassign expression .)
    false           reduce using rule 24 (statement -> name orassign expression .)
    integer         reduce using rule 24 (statement -> name orassign expression .)
    $end            reduce using rule 24 (statement -> name orassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 24 (statement -> name orassign expression .) ]
  ! plus            [ reduce using rule 24 (statement -> name orassign expression .) ]


state 81

    (21) statement -> name lshiftassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 21 (statement -> name lshiftassign expression .)
    dedent          reduce using rule 21 (statement -> name lshiftassign expression .)
    print           reduce using rule 21 (statement -> name lshiftassign expression .)
    identifier      reduce using rule 21 (statement -> name lshiftassign expression .)
    input           reduce using rule 21 (statement -> name lshiftassign expression .)
    invert          reduce using rule 21 (statement -> name lshiftassign expression .)
    oparen          reduce using rule 21 (statement -> name lshiftassign expression .)
    not             reduce using rule 21 (statement -> name lshiftassign expression .)
    if              reduce using rule 21 (statement -> name lshiftassign expression .)
    while           reduce using rule 21 (statement -> name lshiftassign expression .)
    true            reduce using rule 21 (statement -> name lshiftassign expression .)
    false           reduce using rule 21 (statement -> name lshiftassign expression .)
    integer         reduce using rule 21 (statement -> name lshiftassign expression .)
    $end            reduce using rule 21 (statement -> name lshiftassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 21 (statement -> name lshiftassign expression .) ]
  ! plus            [ reduce using rule 21 (statement -> name lshiftassign expression .) ]


state 82

    (22) statement -> name rshiftassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 22 (statement -> name rshiftassign expression .)
    dedent          reduce using rule 22 (statement -> name rshiftassign expression .)
    print           reduce using rule 22 (statement -> name rshiftassign expression .)
    identifier      reduce using rule 22 (statement -> name rshiftassign expression .)
    input           reduce using rule 22 (statement -> name rshiftassign expression .)
    invert          reduce using rule 22 (statement -> name rshiftassign expression .)
    oparen          reduce using rule 22 (statement -> name rshiftassign expression .)
    not             reduce using rule 22 (statement -> name rshiftassign expression .)
    if              reduce using rule 22 (statement -> name rshiftassign expression .)
    while           reduce using rule 22 (statement -> name rshiftassign expression .)
    true            reduce using rule 22 (statement -> name rshiftassign expression .)
    false           reduce using rule 22 (statement -> name rshiftassign expression .)
    integer         reduce using rule 22 (statement -> name rshiftassign expression .)
    $end            reduce using rule 22 (statement -> name rshiftassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 22 (statement -> name rshiftassign expression .) ]
  ! plus            [ reduce using rule 22 (statement -> name rshiftassign expression .) ]


state 83

    (26) statement -> name powerassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 26 (statement -> name powerassign expression .)
    dedent          reduce using rule 26 (statement -> name powerassign expression .)
    print           reduce using rule 26 (statement -> name powerassign expression .)
    identifier      reduce using rule 26 (statement -> name powerassign expression .)
    input           reduce using rule 26 (statement -> name powerassign expression .)
    invert          reduce using rule 26 (statement -> name powerassign expression .)
    oparen          reduce using rule 26 (statement -> name powerassign expression .)
    not             reduce using rule 26 (statement -> name powerassign expression .)
    if              reduce using rule 26 (statement -> name powerassign expression .)
    while           reduce using rule 26 (statement -> name powerassign expression .)
    true            reduce using rule 26 (statement -> name powerassign expression .)
    false           reduce using rule 26 (statement -> name powerassign expression .)
    integer         reduce using rule 26 (statement -> name powerassign expression .)
    $end            reduce using rule 26 (statement -> name powerassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 26 (statement -> name powerassign expression .) ]
  ! plus            [ reduce using rule 26 (statement -> name powerassign expression .) ]


state 84

    (16) statement -> name incassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 16 (statement -> name incassign expression .)
    dedent          reduce using rule 16 (statement -> name incassign expression .)
    print           reduce using rule 16 (statement -> name incassign expression .)
    identifier      reduce using rule 16 (statement -> name incassign expression .)
    input           reduce using rule 16 (statement -> name incassign expression .)
    invert          reduce using rule 16 (statement -> name incassign expression .)
    oparen          reduce using rule 16 (statement -> name incassign expression .)
    not             reduce using rule 16 (statement -> name incassign expression .)
    if              reduce using rule 16 (statement -> name incassign expression .)
    while           reduce using rule 16 (statement -> name incassign expression .)
    true            reduce using rule 16 (statement -> name incassign expression .)
    false           reduce using rule 16 (statement -> name incassign expression .)
    integer         reduce using rule 16 (statement -> name incassign expression .)
    $end            reduce using rule 16 (statement -> name incassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 16 (statement -> name incassign expression .) ]
  ! plus            [ reduce using rule 16 (statement -> name incassign expression .) ]


state 85

    (18) statement -> name divassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 18 (statement -> name divassign expression .)
    dedent          reduce using rule 18 (statement -> name divassign expression .)
    print           reduce using rule 18 (statement -> name divassign expression .)
    identifier      reduce using rule 18 (statement -> name divassign expression .)
    input           reduce using rule 18 (statement -> name divassign expression .)
    invert          reduce using rule 18 (statement -> name divassign expression .)
    oparen          reduce using rule 18 (statement -> name divassign expression .)
    not             reduce using rule 18 (statement -> name divassign expression .)
    if              reduce using rule 18 (statement -> name divassign expression .)
    while           reduce using rule 18 (statement -> name divassign expression .)
    true            reduce using rule 18 (statement -> name divassign expression .)
    false           reduce using rule 18 (statement -> name divassign expression .)
    integer         reduce using rule 18 (statement -> name divassign expression .)
    $end            reduce using rule 18 (statement -> name divassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 18 (statement -> name divassign expression .) ]
  ! plus            [ reduce using rule 18 (statement -> name divassign expression .) ]


state 86

    (19) statement -> name mulassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 19 (statement -> name mulassign expression .)
    dedent          reduce using rule 19 (statement -> name mulassign expression .)
    print           reduce using rule 19 (statement -> name mulassign expression .)
    identifier      reduce using rule 19 (statement -> name mulassign expression .)
    input           reduce using rule 19 (statement -> name mulassign expression .)
    invert          reduce using rule 19 (statement -> name mulassign expression .)
    oparen          reduce using rule 19 (statement -> name mulassign expression .)
    not             reduce using rule 19 (statement -> name mulassign expression .)
    if              reduce using rule 19 (statement -> name mulassign expression .)
    while           reduce using rule 19 (statement -> name mulassign expression .)
    true            reduce using rule 19 (statement -> name mulassign expression .)
    false           reduce using rule 19 (statement -> name mulassign expression .)
    integer         reduce using rule 19 (statement -> name mulassign expression .)
    $end            reduce using rule 19 (statement -> name mulassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 19 (statement -> name mulassign expression .) ]
  ! plus            [ reduce using rule 19 (statement -> name mulassign expression .) ]


state 87

    (20) statement -> name modassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 20 (statement -> name modassign expression .)
    dedent          reduce using rule 20 (statement -> name modassign expression .)
    print           reduce using rule 20 (statement -> name modassign expression .)
    identifier      reduce using rule 20 (statement -> name modassign expression .)
    input           reduce using rule 20 (statement -> name modassign expression .)
    invert          reduce using rule 20 (statement -> name modassign expression .)
    oparen          reduce using rule 20 (statement -> name modassign expression .)
    not             reduce using rule 20 (statement -> name modassign expression .)
    if              reduce using rule 20 (statement -> name modassign expression .)
    while           reduce using rule 20 (statement -> name modassign expression .)
    true            reduce using rule 20 (statement -> name modassign expression .)
    false           reduce using rule 20 (statement -> name modassign expression .)
    integer         reduce using rule 20 (statement -> name modassign expression .)
    $end            reduce using rule 20 (statement -> name modassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 20 (statement -> name modassign expression .) ]
  ! plus            [ reduce using rule 20 (statement -> name modassign expression .) ]


state 88

    (23) statement -> name andassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 23 (statement -> name andassign expression .)
    dedent          reduce using rule 23 (statement -> name andassign expression .)
    print           reduce using rule 23 (statement -> name andassign expression .)
    identifier      reduce using rule 23 (statement -> name andassign expression .)
    input           reduce using rule 23 (statement -> name andassign expression .)
    invert          reduce using rule 23 (statement -> name andassign expression .)
    oparen          reduce using rule 23 (statement -> name andassign expression .)
    not             reduce using rule 23 (statement -> name andassign expression .)
    if              reduce using rule 23 (statement -> name andassign expression .)
    while           reduce using rule 23 (statement -> name andassign expression .)
    true            reduce using rule 23 (statement -> name andassign expression .)
    false           reduce using rule 23 (statement -> name andassign expression .)
    integer         reduce using rule 23 (statement -> name andassign expression .)
    $end            reduce using rule 23 (statement -> name andassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 23 (statement -> name andassign expression .) ]
  ! plus            [ reduce using rule 23 (statement -> name andassign expression .) ]


state 89

    (17) statement -> name decassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 17 (statement -> name decassign expression .)
    dedent          reduce using rule 17 (statement -> name decassign expression .)
    print           reduce using rule 17 (statement -> name decassign expression .)
    identifier      reduce using rule 17 (statement -> name decassign expression .)
    input           reduce using rule 17 (statement -> name decassign expression .)
    invert          reduce using rule 17 (statement -> name decassign expression .)
    oparen          reduce using rule 17 (statement -> name decassign expression .)
    not             reduce using rule 17 (statement -> name decassign expression .)
    if              reduce using rule 17 (statement -> name decassign expression .)
    while           reduce using rule 17 (statement -> name decassign expression .)
    true            reduce using rule 17 (statement -> name decassign expression .)
    false           reduce using rule 17 (statement -> name decassign expression .)
    integer         reduce using rule 17 (statement -> name decassign expression .)
    $end            reduce using rule 17 (statement -> name decassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 17 (statement -> name decassign expression .) ]
  ! plus            [ reduce using rule 17 (statement -> name decassign expression .) ]


state 90

    (25) statement -> name xorassign expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

  ! shift/reduce conflict for plus resolved as shift
  ! shift/reduce conflict for minus resolved as shift
    newline         reduce using rule 25 (statement -> name xorassign expression .)
    dedent          reduce using rule 25 (statement -> name xorassign expression .)
    print           reduce using rule 25 (statement -> name xorassign expression .)
    identifier      reduce using rule 25 (statement -> name xorassign expression .)
    input           reduce using rule 25 (statement -> name xorassign expression .)
    invert          reduce using rule 25 (statement -> name xorassign expression .)
    oparen          reduce using rule 25 (statement -> name xorassign expression .)
    not             reduce using rule 25 (statement -> name xorassign expression .)
    if              reduce using rule 25 (statement -> name xorassign expression .)
    while           reduce using rule 25 (statement -> name xorassign expression .)
    true            reduce using rule 25 (statement -> name xorassign expression .)
    false           reduce using rule 25 (statement -> name xorassign expression .)
    integer         reduce using rule 25 (statement -> name xorassign expression .)
    $end            reduce using rule 25 (statement -> name xorassign expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! minus           [ reduce using rule 25 (statement -> name xorassign expression .) ]
  ! plus            [ reduce using rule 25 (statement -> name xorassign expression .) ]


state 91

    (61) whilestmt -> while expression colon . newline indent statement_list dedent

    newline         shift and go to state 115


state 92

    (45) expression -> expression and expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    and             reduce using rule 45 (expression -> expression and expression .)
    or              reduce using rule 45 (expression -> expression and expression .)
    xor             reduce using rule 45 (expression -> expression and expression .)
    strand          reduce using rule 45 (expression -> expression and expression .)
    stror           reduce using rule 45 (expression -> expression and expression .)
    lt              reduce using rule 45 (expression -> expression and expression .)
    gt              reduce using rule 45 (expression -> expression and expression .)
    lequal          reduce using rule 45 (expression -> expression and expression .)
    gequal          reduce using rule 45 (expression -> expression and expression .)
    isnotequal      reduce using rule 45 (expression -> expression and expression .)
    isequal         reduce using rule 45 (expression -> expression and expression .)
    newline         reduce using rule 45 (expression -> expression and expression .)
    print           reduce using rule 45 (expression -> expression and expression .)
    identifier      reduce using rule 45 (expression -> expression and expression .)
    input           reduce using rule 45 (expression -> expression and expression .)
    invert          reduce using rule 45 (expression -> expression and expression .)
    oparen          reduce using rule 45 (expression -> expression and expression .)
    not             reduce using rule 45 (expression -> expression and expression .)
    if              reduce using rule 45 (expression -> expression and expression .)
    while           reduce using rule 45 (expression -> expression and expression .)
    true            reduce using rule 45 (expression -> expression and expression .)
    false           reduce using rule 45 (expression -> expression and expression .)
    integer         reduce using rule 45 (expression -> expression and expression .)
    $end            reduce using rule 45 (expression -> expression and expression .)
    colon           reduce using rule 45 (expression -> expression and expression .)
    cparen          reduce using rule 45 (expression -> expression and expression .)
    dedent          reduce using rule 45 (expression -> expression and expression .)
    comma           reduce using rule 45 (expression -> expression and expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64

  ! plus            [ reduce using rule 45 (expression -> expression and expression .) ]
  ! minus           [ reduce using rule 45 (expression -> expression and expression .) ]
  ! times           [ reduce using rule 45 (expression -> expression and expression .) ]
  ! div             [ reduce using rule 45 (expression -> expression and expression .) ]
  ! power           [ reduce using rule 45 (expression -> expression and expression .) ]
  ! modulo          [ reduce using rule 45 (expression -> expression and expression .) ]
  ! lshift          [ reduce using rule 45 (expression -> expression and expression .) ]
  ! rshift          [ reduce using rule 45 (expression -> expression and expression .) ]
  ! floordiv        [ reduce using rule 45 (expression -> expression and expression .) ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 93

    (46) expression -> expression or expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    or              reduce using rule 46 (expression -> expression or expression .)
    strand          reduce using rule 46 (expression -> expression or expression .)
    stror           reduce using rule 46 (expression -> expression or expression .)
    lt              reduce using rule 46 (expression -> expression or expression .)
    gt              reduce using rule 46 (expression -> expression or expression .)
    lequal          reduce using rule 46 (expression -> expression or expression .)
    gequal          reduce using rule 46 (expression -> expression or expression .)
    isnotequal      reduce using rule 46 (expression -> expression or expression .)
    isequal         reduce using rule 46 (expression -> expression or expression .)
    newline         reduce using rule 46 (expression -> expression or expression .)
    print           reduce using rule 46 (expression -> expression or expression .)
    identifier      reduce using rule 46 (expression -> expression or expression .)
    input           reduce using rule 46 (expression -> expression or expression .)
    invert          reduce using rule 46 (expression -> expression or expression .)
    oparen          reduce using rule 46 (expression -> expression or expression .)
    not             reduce using rule 46 (expression -> expression or expression .)
    if              reduce using rule 46 (expression -> expression or expression .)
    while           reduce using rule 46 (expression -> expression or expression .)
    true            reduce using rule 46 (expression -> expression or expression .)
    false           reduce using rule 46 (expression -> expression or expression .)
    integer         reduce using rule 46 (expression -> expression or expression .)
    $end            reduce using rule 46 (expression -> expression or expression .)
    colon           reduce using rule 46 (expression -> expression or expression .)
    cparen          reduce using rule 46 (expression -> expression or expression .)
    dedent          reduce using rule 46 (expression -> expression or expression .)
    comma           reduce using rule 46 (expression -> expression or expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    xor             shift and go to state 61

  ! plus            [ reduce using rule 46 (expression -> expression or expression .) ]
  ! minus           [ reduce using rule 46 (expression -> expression or expression .) ]
  ! times           [ reduce using rule 46 (expression -> expression or expression .) ]
  ! div             [ reduce using rule 46 (expression -> expression or expression .) ]
  ! power           [ reduce using rule 46 (expression -> expression or expression .) ]
  ! modulo          [ reduce using rule 46 (expression -> expression or expression .) ]
  ! lshift          [ reduce using rule 46 (expression -> expression or expression .) ]
  ! rshift          [ reduce using rule 46 (expression -> expression or expression .) ]
  ! floordiv        [ reduce using rule 46 (expression -> expression or expression .) ]
  ! and             [ reduce using rule 46 (expression -> expression or expression .) ]
  ! xor             [ reduce using rule 46 (expression -> expression or expression .) ]
  ! or              [ shift and go to state 54 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 94

    (41) expression -> expression modulo expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 41 (expression -> expression modulo expression .)
    minus           reduce using rule 41 (expression -> expression modulo expression .)
    times           reduce using rule 41 (expression -> expression modulo expression .)
    div             reduce using rule 41 (expression -> expression modulo expression .)
    modulo          reduce using rule 41 (expression -> expression modulo expression .)
    lshift          reduce using rule 41 (expression -> expression modulo expression .)
    rshift          reduce using rule 41 (expression -> expression modulo expression .)
    floordiv        reduce using rule 41 (expression -> expression modulo expression .)
    and             reduce using rule 41 (expression -> expression modulo expression .)
    or              reduce using rule 41 (expression -> expression modulo expression .)
    xor             reduce using rule 41 (expression -> expression modulo expression .)
    strand          reduce using rule 41 (expression -> expression modulo expression .)
    stror           reduce using rule 41 (expression -> expression modulo expression .)
    lt              reduce using rule 41 (expression -> expression modulo expression .)
    gt              reduce using rule 41 (expression -> expression modulo expression .)
    lequal          reduce using rule 41 (expression -> expression modulo expression .)
    gequal          reduce using rule 41 (expression -> expression modulo expression .)
    isnotequal      reduce using rule 41 (expression -> expression modulo expression .)
    isequal         reduce using rule 41 (expression -> expression modulo expression .)
    newline         reduce using rule 41 (expression -> expression modulo expression .)
    print           reduce using rule 41 (expression -> expression modulo expression .)
    identifier      reduce using rule 41 (expression -> expression modulo expression .)
    input           reduce using rule 41 (expression -> expression modulo expression .)
    invert          reduce using rule 41 (expression -> expression modulo expression .)
    oparen          reduce using rule 41 (expression -> expression modulo expression .)
    not             reduce using rule 41 (expression -> expression modulo expression .)
    if              reduce using rule 41 (expression -> expression modulo expression .)
    while           reduce using rule 41 (expression -> expression modulo expression .)
    true            reduce using rule 41 (expression -> expression modulo expression .)
    false           reduce using rule 41 (expression -> expression modulo expression .)
    integer         reduce using rule 41 (expression -> expression modulo expression .)
    $end            reduce using rule 41 (expression -> expression modulo expression .)
    colon           reduce using rule 41 (expression -> expression modulo expression .)
    cparen          reduce using rule 41 (expression -> expression modulo expression .)
    dedent          reduce using rule 41 (expression -> expression modulo expression .)
    comma           reduce using rule 41 (expression -> expression modulo expression .)
    power           shift and go to state 56

  ! power           [ reduce using rule 41 (expression -> expression modulo expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! times           [ shift and go to state 62 ]
  ! div             [ shift and go to state 70 ]
  ! modulo          [ shift and go to state 55 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! floordiv        [ shift and go to state 64 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 95

    (40) expression -> expression power expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 40 (expression -> expression power expression .)
    minus           reduce using rule 40 (expression -> expression power expression .)
    times           reduce using rule 40 (expression -> expression power expression .)
    div             reduce using rule 40 (expression -> expression power expression .)
    modulo          reduce using rule 40 (expression -> expression power expression .)
    lshift          reduce using rule 40 (expression -> expression power expression .)
    rshift          reduce using rule 40 (expression -> expression power expression .)
    floordiv        reduce using rule 40 (expression -> expression power expression .)
    and             reduce using rule 40 (expression -> expression power expression .)
    or              reduce using rule 40 (expression -> expression power expression .)
    xor             reduce using rule 40 (expression -> expression power expression .)
    strand          reduce using rule 40 (expression -> expression power expression .)
    stror           reduce using rule 40 (expression -> expression power expression .)
    lt              reduce using rule 40 (expression -> expression power expression .)
    gt              reduce using rule 40 (expression -> expression power expression .)
    lequal          reduce using rule 40 (expression -> expression power expression .)
    gequal          reduce using rule 40 (expression -> expression power expression .)
    isnotequal      reduce using rule 40 (expression -> expression power expression .)
    isequal         reduce using rule 40 (expression -> expression power expression .)
    newline         reduce using rule 40 (expression -> expression power expression .)
    print           reduce using rule 40 (expression -> expression power expression .)
    identifier      reduce using rule 40 (expression -> expression power expression .)
    input           reduce using rule 40 (expression -> expression power expression .)
    invert          reduce using rule 40 (expression -> expression power expression .)
    oparen          reduce using rule 40 (expression -> expression power expression .)
    not             reduce using rule 40 (expression -> expression power expression .)
    if              reduce using rule 40 (expression -> expression power expression .)
    while           reduce using rule 40 (expression -> expression power expression .)
    true            reduce using rule 40 (expression -> expression power expression .)
    false           reduce using rule 40 (expression -> expression power expression .)
    integer         reduce using rule 40 (expression -> expression power expression .)
    $end            reduce using rule 40 (expression -> expression power expression .)
    colon           reduce using rule 40 (expression -> expression power expression .)
    cparen          reduce using rule 40 (expression -> expression power expression .)
    dedent          reduce using rule 40 (expression -> expression power expression .)
    comma           reduce using rule 40 (expression -> expression power expression .)
    power           shift and go to state 56

  ! power           [ reduce using rule 40 (expression -> expression power expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! times           [ shift and go to state 62 ]
  ! div             [ shift and go to state 70 ]
  ! modulo          [ shift and go to state 55 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! floordiv        [ shift and go to state 64 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 96

    (49) expression -> expression stror expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    stror           reduce using rule 49 (expression -> expression stror expression .)
    newline         reduce using rule 49 (expression -> expression stror expression .)
    print           reduce using rule 49 (expression -> expression stror expression .)
    identifier      reduce using rule 49 (expression -> expression stror expression .)
    input           reduce using rule 49 (expression -> expression stror expression .)
    invert          reduce using rule 49 (expression -> expression stror expression .)
    oparen          reduce using rule 49 (expression -> expression stror expression .)
    not             reduce using rule 49 (expression -> expression stror expression .)
    if              reduce using rule 49 (expression -> expression stror expression .)
    while           reduce using rule 49 (expression -> expression stror expression .)
    true            reduce using rule 49 (expression -> expression stror expression .)
    false           reduce using rule 49 (expression -> expression stror expression .)
    integer         reduce using rule 49 (expression -> expression stror expression .)
    $end            reduce using rule 49 (expression -> expression stror expression .)
    colon           reduce using rule 49 (expression -> expression stror expression .)
    cparen          reduce using rule 49 (expression -> expression stror expression .)
    dedent          reduce using rule 49 (expression -> expression stror expression .)
    comma           reduce using rule 49 (expression -> expression stror expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! plus            [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! minus           [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! times           [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! div             [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! power           [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! modulo          [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! lshift          [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! rshift          [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! floordiv        [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! and             [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! or              [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! xor             [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! strand          [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! lt              [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! gt              [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! lequal          [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! gequal          [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! isnotequal      [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! isequal         [ reduce using rule 49 (expression -> expression stror expression .) ]
  ! stror           [ shift and go to state 57 ]


state 97

    (53) expression -> expression gequal expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 53 (expression -> expression gequal expression .)
    stror           reduce using rule 53 (expression -> expression gequal expression .)
    lt              reduce using rule 53 (expression -> expression gequal expression .)
    gt              reduce using rule 53 (expression -> expression gequal expression .)
    lequal          reduce using rule 53 (expression -> expression gequal expression .)
    gequal          reduce using rule 53 (expression -> expression gequal expression .)
    isnotequal      reduce using rule 53 (expression -> expression gequal expression .)
    isequal         reduce using rule 53 (expression -> expression gequal expression .)
    newline         reduce using rule 53 (expression -> expression gequal expression .)
    print           reduce using rule 53 (expression -> expression gequal expression .)
    identifier      reduce using rule 53 (expression -> expression gequal expression .)
    input           reduce using rule 53 (expression -> expression gequal expression .)
    invert          reduce using rule 53 (expression -> expression gequal expression .)
    oparen          reduce using rule 53 (expression -> expression gequal expression .)
    not             reduce using rule 53 (expression -> expression gequal expression .)
    if              reduce using rule 53 (expression -> expression gequal expression .)
    while           reduce using rule 53 (expression -> expression gequal expression .)
    true            reduce using rule 53 (expression -> expression gequal expression .)
    false           reduce using rule 53 (expression -> expression gequal expression .)
    integer         reduce using rule 53 (expression -> expression gequal expression .)
    $end            reduce using rule 53 (expression -> expression gequal expression .)
    colon           reduce using rule 53 (expression -> expression gequal expression .)
    cparen          reduce using rule 53 (expression -> expression gequal expression .)
    dedent          reduce using rule 53 (expression -> expression gequal expression .)
    comma           reduce using rule 53 (expression -> expression gequal expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61

  ! plus            [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! minus           [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! times           [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! div             [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! power           [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! modulo          [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! lshift          [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! rshift          [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! floordiv        [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! and             [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! or              [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! xor             [ reduce using rule 53 (expression -> expression gequal expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 98

    (54) expression -> expression isnotequal expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 54 (expression -> expression isnotequal expression .)
    stror           reduce using rule 54 (expression -> expression isnotequal expression .)
    lt              reduce using rule 54 (expression -> expression isnotequal expression .)
    gt              reduce using rule 54 (expression -> expression isnotequal expression .)
    lequal          reduce using rule 54 (expression -> expression isnotequal expression .)
    gequal          reduce using rule 54 (expression -> expression isnotequal expression .)
    isnotequal      reduce using rule 54 (expression -> expression isnotequal expression .)
    isequal         reduce using rule 54 (expression -> expression isnotequal expression .)
    newline         reduce using rule 54 (expression -> expression isnotequal expression .)
    print           reduce using rule 54 (expression -> expression isnotequal expression .)
    identifier      reduce using rule 54 (expression -> expression isnotequal expression .)
    input           reduce using rule 54 (expression -> expression isnotequal expression .)
    invert          reduce using rule 54 (expression -> expression isnotequal expression .)
    oparen          reduce using rule 54 (expression -> expression isnotequal expression .)
    not             reduce using rule 54 (expression -> expression isnotequal expression .)
    if              reduce using rule 54 (expression -> expression isnotequal expression .)
    while           reduce using rule 54 (expression -> expression isnotequal expression .)
    true            reduce using rule 54 (expression -> expression isnotequal expression .)
    false           reduce using rule 54 (expression -> expression isnotequal expression .)
    integer         reduce using rule 54 (expression -> expression isnotequal expression .)
    $end            reduce using rule 54 (expression -> expression isnotequal expression .)
    colon           reduce using rule 54 (expression -> expression isnotequal expression .)
    cparen          reduce using rule 54 (expression -> expression isnotequal expression .)
    dedent          reduce using rule 54 (expression -> expression isnotequal expression .)
    comma           reduce using rule 54 (expression -> expression isnotequal expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61

  ! plus            [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! minus           [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! times           [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! div             [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! power           [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! modulo          [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! lshift          [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! rshift          [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! floordiv        [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! and             [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! or              [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! xor             [ reduce using rule 54 (expression -> expression isnotequal expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 99

    (52) expression -> expression lequal expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 52 (expression -> expression lequal expression .)
    stror           reduce using rule 52 (expression -> expression lequal expression .)
    lt              reduce using rule 52 (expression -> expression lequal expression .)
    gt              reduce using rule 52 (expression -> expression lequal expression .)
    lequal          reduce using rule 52 (expression -> expression lequal expression .)
    gequal          reduce using rule 52 (expression -> expression lequal expression .)
    isnotequal      reduce using rule 52 (expression -> expression lequal expression .)
    isequal         reduce using rule 52 (expression -> expression lequal expression .)
    newline         reduce using rule 52 (expression -> expression lequal expression .)
    print           reduce using rule 52 (expression -> expression lequal expression .)
    identifier      reduce using rule 52 (expression -> expression lequal expression .)
    input           reduce using rule 52 (expression -> expression lequal expression .)
    invert          reduce using rule 52 (expression -> expression lequal expression .)
    oparen          reduce using rule 52 (expression -> expression lequal expression .)
    not             reduce using rule 52 (expression -> expression lequal expression .)
    if              reduce using rule 52 (expression -> expression lequal expression .)
    while           reduce using rule 52 (expression -> expression lequal expression .)
    true            reduce using rule 52 (expression -> expression lequal expression .)
    false           reduce using rule 52 (expression -> expression lequal expression .)
    integer         reduce using rule 52 (expression -> expression lequal expression .)
    $end            reduce using rule 52 (expression -> expression lequal expression .)
    colon           reduce using rule 52 (expression -> expression lequal expression .)
    cparen          reduce using rule 52 (expression -> expression lequal expression .)
    dedent          reduce using rule 52 (expression -> expression lequal expression .)
    comma           reduce using rule 52 (expression -> expression lequal expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61

  ! plus            [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! minus           [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! times           [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! div             [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! power           [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! modulo          [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! lshift          [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! rshift          [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! floordiv        [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! and             [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! or              [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! xor             [ reduce using rule 52 (expression -> expression lequal expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 100

    (47) expression -> expression xor expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    or              reduce using rule 47 (expression -> expression xor expression .)
    xor             reduce using rule 47 (expression -> expression xor expression .)
    strand          reduce using rule 47 (expression -> expression xor expression .)
    stror           reduce using rule 47 (expression -> expression xor expression .)
    lt              reduce using rule 47 (expression -> expression xor expression .)
    gt              reduce using rule 47 (expression -> expression xor expression .)
    lequal          reduce using rule 47 (expression -> expression xor expression .)
    gequal          reduce using rule 47 (expression -> expression xor expression .)
    isnotequal      reduce using rule 47 (expression -> expression xor expression .)
    isequal         reduce using rule 47 (expression -> expression xor expression .)
    newline         reduce using rule 47 (expression -> expression xor expression .)
    print           reduce using rule 47 (expression -> expression xor expression .)
    identifier      reduce using rule 47 (expression -> expression xor expression .)
    input           reduce using rule 47 (expression -> expression xor expression .)
    invert          reduce using rule 47 (expression -> expression xor expression .)
    oparen          reduce using rule 47 (expression -> expression xor expression .)
    not             reduce using rule 47 (expression -> expression xor expression .)
    if              reduce using rule 47 (expression -> expression xor expression .)
    while           reduce using rule 47 (expression -> expression xor expression .)
    true            reduce using rule 47 (expression -> expression xor expression .)
    false           reduce using rule 47 (expression -> expression xor expression .)
    integer         reduce using rule 47 (expression -> expression xor expression .)
    $end            reduce using rule 47 (expression -> expression xor expression .)
    colon           reduce using rule 47 (expression -> expression xor expression .)
    cparen          reduce using rule 47 (expression -> expression xor expression .)
    dedent          reduce using rule 47 (expression -> expression xor expression .)
    comma           reduce using rule 47 (expression -> expression xor expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53

  ! plus            [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! minus           [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! times           [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! div             [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! power           [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! modulo          [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! lshift          [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! rshift          [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! floordiv        [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! and             [ reduce using rule 47 (expression -> expression xor expression .) ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 101

    (38) expression -> expression times expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 38 (expression -> expression times expression .)
    minus           reduce using rule 38 (expression -> expression times expression .)
    times           reduce using rule 38 (expression -> expression times expression .)
    div             reduce using rule 38 (expression -> expression times expression .)
    modulo          reduce using rule 38 (expression -> expression times expression .)
    lshift          reduce using rule 38 (expression -> expression times expression .)
    rshift          reduce using rule 38 (expression -> expression times expression .)
    floordiv        reduce using rule 38 (expression -> expression times expression .)
    and             reduce using rule 38 (expression -> expression times expression .)
    or              reduce using rule 38 (expression -> expression times expression .)
    xor             reduce using rule 38 (expression -> expression times expression .)
    strand          reduce using rule 38 (expression -> expression times expression .)
    stror           reduce using rule 38 (expression -> expression times expression .)
    lt              reduce using rule 38 (expression -> expression times expression .)
    gt              reduce using rule 38 (expression -> expression times expression .)
    lequal          reduce using rule 38 (expression -> expression times expression .)
    gequal          reduce using rule 38 (expression -> expression times expression .)
    isnotequal      reduce using rule 38 (expression -> expression times expression .)
    isequal         reduce using rule 38 (expression -> expression times expression .)
    newline         reduce using rule 38 (expression -> expression times expression .)
    print           reduce using rule 38 (expression -> expression times expression .)
    identifier      reduce using rule 38 (expression -> expression times expression .)
    input           reduce using rule 38 (expression -> expression times expression .)
    invert          reduce using rule 38 (expression -> expression times expression .)
    oparen          reduce using rule 38 (expression -> expression times expression .)
    not             reduce using rule 38 (expression -> expression times expression .)
    if              reduce using rule 38 (expression -> expression times expression .)
    while           reduce using rule 38 (expression -> expression times expression .)
    true            reduce using rule 38 (expression -> expression times expression .)
    false           reduce using rule 38 (expression -> expression times expression .)
    integer         reduce using rule 38 (expression -> expression times expression .)
    $end            reduce using rule 38 (expression -> expression times expression .)
    colon           reduce using rule 38 (expression -> expression times expression .)
    cparen          reduce using rule 38 (expression -> expression times expression .)
    dedent          reduce using rule 38 (expression -> expression times expression .)
    comma           reduce using rule 38 (expression -> expression times expression .)
    power           shift and go to state 56

  ! power           [ reduce using rule 38 (expression -> expression times expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! times           [ shift and go to state 62 ]
  ! div             [ shift and go to state 70 ]
  ! modulo          [ shift and go to state 55 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! floordiv        [ shift and go to state 64 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 102

    (50) expression -> expression lt expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 50 (expression -> expression lt expression .)
    stror           reduce using rule 50 (expression -> expression lt expression .)
    lt              reduce using rule 50 (expression -> expression lt expression .)
    gt              reduce using rule 50 (expression -> expression lt expression .)
    lequal          reduce using rule 50 (expression -> expression lt expression .)
    gequal          reduce using rule 50 (expression -> expression lt expression .)
    isnotequal      reduce using rule 50 (expression -> expression lt expression .)
    isequal         reduce using rule 50 (expression -> expression lt expression .)
    newline         reduce using rule 50 (expression -> expression lt expression .)
    print           reduce using rule 50 (expression -> expression lt expression .)
    identifier      reduce using rule 50 (expression -> expression lt expression .)
    input           reduce using rule 50 (expression -> expression lt expression .)
    invert          reduce using rule 50 (expression -> expression lt expression .)
    oparen          reduce using rule 50 (expression -> expression lt expression .)
    not             reduce using rule 50 (expression -> expression lt expression .)
    if              reduce using rule 50 (expression -> expression lt expression .)
    while           reduce using rule 50 (expression -> expression lt expression .)
    true            reduce using rule 50 (expression -> expression lt expression .)
    false           reduce using rule 50 (expression -> expression lt expression .)
    integer         reduce using rule 50 (expression -> expression lt expression .)
    $end            reduce using rule 50 (expression -> expression lt expression .)
    colon           reduce using rule 50 (expression -> expression lt expression .)
    cparen          reduce using rule 50 (expression -> expression lt expression .)
    dedent          reduce using rule 50 (expression -> expression lt expression .)
    comma           reduce using rule 50 (expression -> expression lt expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61

  ! plus            [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! minus           [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! times           [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! div             [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! power           [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! modulo          [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! lshift          [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! rshift          [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! floordiv        [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! and             [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! or              [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! xor             [ reduce using rule 50 (expression -> expression lt expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 103

    (44) expression -> expression floordiv expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 44 (expression -> expression floordiv expression .)
    minus           reduce using rule 44 (expression -> expression floordiv expression .)
    times           reduce using rule 44 (expression -> expression floordiv expression .)
    div             reduce using rule 44 (expression -> expression floordiv expression .)
    modulo          reduce using rule 44 (expression -> expression floordiv expression .)
    lshift          reduce using rule 44 (expression -> expression floordiv expression .)
    rshift          reduce using rule 44 (expression -> expression floordiv expression .)
    floordiv        reduce using rule 44 (expression -> expression floordiv expression .)
    and             reduce using rule 44 (expression -> expression floordiv expression .)
    or              reduce using rule 44 (expression -> expression floordiv expression .)
    xor             reduce using rule 44 (expression -> expression floordiv expression .)
    strand          reduce using rule 44 (expression -> expression floordiv expression .)
    stror           reduce using rule 44 (expression -> expression floordiv expression .)
    lt              reduce using rule 44 (expression -> expression floordiv expression .)
    gt              reduce using rule 44 (expression -> expression floordiv expression .)
    lequal          reduce using rule 44 (expression -> expression floordiv expression .)
    gequal          reduce using rule 44 (expression -> expression floordiv expression .)
    isnotequal      reduce using rule 44 (expression -> expression floordiv expression .)
    isequal         reduce using rule 44 (expression -> expression floordiv expression .)
    newline         reduce using rule 44 (expression -> expression floordiv expression .)
    print           reduce using rule 44 (expression -> expression floordiv expression .)
    identifier      reduce using rule 44 (expression -> expression floordiv expression .)
    input           reduce using rule 44 (expression -> expression floordiv expression .)
    invert          reduce using rule 44 (expression -> expression floordiv expression .)
    oparen          reduce using rule 44 (expression -> expression floordiv expression .)
    not             reduce using rule 44 (expression -> expression floordiv expression .)
    if              reduce using rule 44 (expression -> expression floordiv expression .)
    while           reduce using rule 44 (expression -> expression floordiv expression .)
    true            reduce using rule 44 (expression -> expression floordiv expression .)
    false           reduce using rule 44 (expression -> expression floordiv expression .)
    integer         reduce using rule 44 (expression -> expression floordiv expression .)
    $end            reduce using rule 44 (expression -> expression floordiv expression .)
    colon           reduce using rule 44 (expression -> expression floordiv expression .)
    cparen          reduce using rule 44 (expression -> expression floordiv expression .)
    dedent          reduce using rule 44 (expression -> expression floordiv expression .)
    comma           reduce using rule 44 (expression -> expression floordiv expression .)
    power           shift and go to state 56

  ! power           [ reduce using rule 44 (expression -> expression floordiv expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! times           [ shift and go to state 62 ]
  ! div             [ shift and go to state 70 ]
  ! modulo          [ shift and go to state 55 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! floordiv        [ shift and go to state 64 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 104

    (36) expression -> expression plus expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 36 (expression -> expression plus expression .)
    minus           reduce using rule 36 (expression -> expression plus expression .)
    lshift          reduce using rule 36 (expression -> expression plus expression .)
    rshift          reduce using rule 36 (expression -> expression plus expression .)
    and             reduce using rule 36 (expression -> expression plus expression .)
    or              reduce using rule 36 (expression -> expression plus expression .)
    xor             reduce using rule 36 (expression -> expression plus expression .)
    strand          reduce using rule 36 (expression -> expression plus expression .)
    stror           reduce using rule 36 (expression -> expression plus expression .)
    lt              reduce using rule 36 (expression -> expression plus expression .)
    gt              reduce using rule 36 (expression -> expression plus expression .)
    lequal          reduce using rule 36 (expression -> expression plus expression .)
    gequal          reduce using rule 36 (expression -> expression plus expression .)
    isnotequal      reduce using rule 36 (expression -> expression plus expression .)
    isequal         reduce using rule 36 (expression -> expression plus expression .)
    newline         reduce using rule 36 (expression -> expression plus expression .)
    print           reduce using rule 36 (expression -> expression plus expression .)
    identifier      reduce using rule 36 (expression -> expression plus expression .)
    input           reduce using rule 36 (expression -> expression plus expression .)
    invert          reduce using rule 36 (expression -> expression plus expression .)
    oparen          reduce using rule 36 (expression -> expression plus expression .)
    not             reduce using rule 36 (expression -> expression plus expression .)
    if              reduce using rule 36 (expression -> expression plus expression .)
    while           reduce using rule 36 (expression -> expression plus expression .)
    true            reduce using rule 36 (expression -> expression plus expression .)
    false           reduce using rule 36 (expression -> expression plus expression .)
    integer         reduce using rule 36 (expression -> expression plus expression .)
    $end            reduce using rule 36 (expression -> expression plus expression .)
    colon           reduce using rule 36 (expression -> expression plus expression .)
    cparen          reduce using rule 36 (expression -> expression plus expression .)
    dedent          reduce using rule 36 (expression -> expression plus expression .)
    comma           reduce using rule 36 (expression -> expression plus expression .)
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    floordiv        shift and go to state 64

  ! times           [ reduce using rule 36 (expression -> expression plus expression .) ]
  ! div             [ reduce using rule 36 (expression -> expression plus expression .) ]
  ! power           [ reduce using rule 36 (expression -> expression plus expression .) ]
  ! modulo          [ reduce using rule 36 (expression -> expression plus expression .) ]
  ! floordiv        [ reduce using rule 36 (expression -> expression plus expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 105

    (51) expression -> expression gt expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 51 (expression -> expression gt expression .)
    stror           reduce using rule 51 (expression -> expression gt expression .)
    lt              reduce using rule 51 (expression -> expression gt expression .)
    gt              reduce using rule 51 (expression -> expression gt expression .)
    lequal          reduce using rule 51 (expression -> expression gt expression .)
    gequal          reduce using rule 51 (expression -> expression gt expression .)
    isnotequal      reduce using rule 51 (expression -> expression gt expression .)
    isequal         reduce using rule 51 (expression -> expression gt expression .)
    newline         reduce using rule 51 (expression -> expression gt expression .)
    print           reduce using rule 51 (expression -> expression gt expression .)
    identifier      reduce using rule 51 (expression -> expression gt expression .)
    input           reduce using rule 51 (expression -> expression gt expression .)
    invert          reduce using rule 51 (expression -> expression gt expression .)
    oparen          reduce using rule 51 (expression -> expression gt expression .)
    not             reduce using rule 51 (expression -> expression gt expression .)
    if              reduce using rule 51 (expression -> expression gt expression .)
    while           reduce using rule 51 (expression -> expression gt expression .)
    true            reduce using rule 51 (expression -> expression gt expression .)
    false           reduce using rule 51 (expression -> expression gt expression .)
    integer         reduce using rule 51 (expression -> expression gt expression .)
    $end            reduce using rule 51 (expression -> expression gt expression .)
    colon           reduce using rule 51 (expression -> expression gt expression .)
    cparen          reduce using rule 51 (expression -> expression gt expression .)
    dedent          reduce using rule 51 (expression -> expression gt expression .)
    comma           reduce using rule 51 (expression -> expression gt expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61

  ! plus            [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! minus           [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! times           [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! div             [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! power           [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! modulo          [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! lshift          [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! rshift          [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! floordiv        [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! and             [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! or              [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! xor             [ reduce using rule 51 (expression -> expression gt expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 106

    (42) expression -> expression lshift expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    lshift          reduce using rule 42 (expression -> expression lshift expression .)
    rshift          reduce using rule 42 (expression -> expression lshift expression .)
    and             reduce using rule 42 (expression -> expression lshift expression .)
    or              reduce using rule 42 (expression -> expression lshift expression .)
    xor             reduce using rule 42 (expression -> expression lshift expression .)
    strand          reduce using rule 42 (expression -> expression lshift expression .)
    stror           reduce using rule 42 (expression -> expression lshift expression .)
    lt              reduce using rule 42 (expression -> expression lshift expression .)
    gt              reduce using rule 42 (expression -> expression lshift expression .)
    lequal          reduce using rule 42 (expression -> expression lshift expression .)
    gequal          reduce using rule 42 (expression -> expression lshift expression .)
    isnotequal      reduce using rule 42 (expression -> expression lshift expression .)
    isequal         reduce using rule 42 (expression -> expression lshift expression .)
    newline         reduce using rule 42 (expression -> expression lshift expression .)
    print           reduce using rule 42 (expression -> expression lshift expression .)
    identifier      reduce using rule 42 (expression -> expression lshift expression .)
    input           reduce using rule 42 (expression -> expression lshift expression .)
    invert          reduce using rule 42 (expression -> expression lshift expression .)
    oparen          reduce using rule 42 (expression -> expression lshift expression .)
    not             reduce using rule 42 (expression -> expression lshift expression .)
    if              reduce using rule 42 (expression -> expression lshift expression .)
    while           reduce using rule 42 (expression -> expression lshift expression .)
    true            reduce using rule 42 (expression -> expression lshift expression .)
    false           reduce using rule 42 (expression -> expression lshift expression .)
    integer         reduce using rule 42 (expression -> expression lshift expression .)
    $end            reduce using rule 42 (expression -> expression lshift expression .)
    colon           reduce using rule 42 (expression -> expression lshift expression .)
    cparen          reduce using rule 42 (expression -> expression lshift expression .)
    dedent          reduce using rule 42 (expression -> expression lshift expression .)
    comma           reduce using rule 42 (expression -> expression lshift expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    floordiv        shift and go to state 64

  ! plus            [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! minus           [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! times           [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! div             [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! power           [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! modulo          [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! floordiv        [ reduce using rule 42 (expression -> expression lshift expression .) ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 107

    (55) expression -> expression isequal expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 55 (expression -> expression isequal expression .)
    stror           reduce using rule 55 (expression -> expression isequal expression .)
    lt              reduce using rule 55 (expression -> expression isequal expression .)
    gt              reduce using rule 55 (expression -> expression isequal expression .)
    lequal          reduce using rule 55 (expression -> expression isequal expression .)
    gequal          reduce using rule 55 (expression -> expression isequal expression .)
    isnotequal      reduce using rule 55 (expression -> expression isequal expression .)
    isequal         reduce using rule 55 (expression -> expression isequal expression .)
    newline         reduce using rule 55 (expression -> expression isequal expression .)
    print           reduce using rule 55 (expression -> expression isequal expression .)
    identifier      reduce using rule 55 (expression -> expression isequal expression .)
    input           reduce using rule 55 (expression -> expression isequal expression .)
    invert          reduce using rule 55 (expression -> expression isequal expression .)
    oparen          reduce using rule 55 (expression -> expression isequal expression .)
    not             reduce using rule 55 (expression -> expression isequal expression .)
    if              reduce using rule 55 (expression -> expression isequal expression .)
    while           reduce using rule 55 (expression -> expression isequal expression .)
    true            reduce using rule 55 (expression -> expression isequal expression .)
    false           reduce using rule 55 (expression -> expression isequal expression .)
    integer         reduce using rule 55 (expression -> expression isequal expression .)
    $end            reduce using rule 55 (expression -> expression isequal expression .)
    colon           reduce using rule 55 (expression -> expression isequal expression .)
    cparen          reduce using rule 55 (expression -> expression isequal expression .)
    dedent          reduce using rule 55 (expression -> expression isequal expression .)
    comma           reduce using rule 55 (expression -> expression isequal expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61

  ! plus            [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! minus           [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! times           [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! div             [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! power           [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! modulo          [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! lshift          [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! rshift          [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! floordiv        [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! and             [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! or              [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! xor             [ reduce using rule 55 (expression -> expression isequal expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 108

    (43) expression -> expression rshift expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    lshift          reduce using rule 43 (expression -> expression rshift expression .)
    rshift          reduce using rule 43 (expression -> expression rshift expression .)
    and             reduce using rule 43 (expression -> expression rshift expression .)
    or              reduce using rule 43 (expression -> expression rshift expression .)
    xor             reduce using rule 43 (expression -> expression rshift expression .)
    strand          reduce using rule 43 (expression -> expression rshift expression .)
    stror           reduce using rule 43 (expression -> expression rshift expression .)
    lt              reduce using rule 43 (expression -> expression rshift expression .)
    gt              reduce using rule 43 (expression -> expression rshift expression .)
    lequal          reduce using rule 43 (expression -> expression rshift expression .)
    gequal          reduce using rule 43 (expression -> expression rshift expression .)
    isnotequal      reduce using rule 43 (expression -> expression rshift expression .)
    isequal         reduce using rule 43 (expression -> expression rshift expression .)
    newline         reduce using rule 43 (expression -> expression rshift expression .)
    print           reduce using rule 43 (expression -> expression rshift expression .)
    identifier      reduce using rule 43 (expression -> expression rshift expression .)
    input           reduce using rule 43 (expression -> expression rshift expression .)
    invert          reduce using rule 43 (expression -> expression rshift expression .)
    oparen          reduce using rule 43 (expression -> expression rshift expression .)
    not             reduce using rule 43 (expression -> expression rshift expression .)
    if              reduce using rule 43 (expression -> expression rshift expression .)
    while           reduce using rule 43 (expression -> expression rshift expression .)
    true            reduce using rule 43 (expression -> expression rshift expression .)
    false           reduce using rule 43 (expression -> expression rshift expression .)
    integer         reduce using rule 43 (expression -> expression rshift expression .)
    $end            reduce using rule 43 (expression -> expression rshift expression .)
    colon           reduce using rule 43 (expression -> expression rshift expression .)
    cparen          reduce using rule 43 (expression -> expression rshift expression .)
    dedent          reduce using rule 43 (expression -> expression rshift expression .)
    comma           reduce using rule 43 (expression -> expression rshift expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    floordiv        shift and go to state 64

  ! plus            [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! minus           [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! times           [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! div             [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! power           [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! modulo          [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! floordiv        [ reduce using rule 43 (expression -> expression rshift expression .) ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 109

    (39) expression -> expression div expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 39 (expression -> expression div expression .)
    minus           reduce using rule 39 (expression -> expression div expression .)
    times           reduce using rule 39 (expression -> expression div expression .)
    div             reduce using rule 39 (expression -> expression div expression .)
    modulo          reduce using rule 39 (expression -> expression div expression .)
    lshift          reduce using rule 39 (expression -> expression div expression .)
    rshift          reduce using rule 39 (expression -> expression div expression .)
    floordiv        reduce using rule 39 (expression -> expression div expression .)
    and             reduce using rule 39 (expression -> expression div expression .)
    or              reduce using rule 39 (expression -> expression div expression .)
    xor             reduce using rule 39 (expression -> expression div expression .)
    strand          reduce using rule 39 (expression -> expression div expression .)
    stror           reduce using rule 39 (expression -> expression div expression .)
    lt              reduce using rule 39 (expression -> expression div expression .)
    gt              reduce using rule 39 (expression -> expression div expression .)
    lequal          reduce using rule 39 (expression -> expression div expression .)
    gequal          reduce using rule 39 (expression -> expression div expression .)
    isnotequal      reduce using rule 39 (expression -> expression div expression .)
    isequal         reduce using rule 39 (expression -> expression div expression .)
    newline         reduce using rule 39 (expression -> expression div expression .)
    print           reduce using rule 39 (expression -> expression div expression .)
    identifier      reduce using rule 39 (expression -> expression div expression .)
    input           reduce using rule 39 (expression -> expression div expression .)
    invert          reduce using rule 39 (expression -> expression div expression .)
    oparen          reduce using rule 39 (expression -> expression div expression .)
    not             reduce using rule 39 (expression -> expression div expression .)
    if              reduce using rule 39 (expression -> expression div expression .)
    while           reduce using rule 39 (expression -> expression div expression .)
    true            reduce using rule 39 (expression -> expression div expression .)
    false           reduce using rule 39 (expression -> expression div expression .)
    integer         reduce using rule 39 (expression -> expression div expression .)
    $end            reduce using rule 39 (expression -> expression div expression .)
    colon           reduce using rule 39 (expression -> expression div expression .)
    cparen          reduce using rule 39 (expression -> expression div expression .)
    dedent          reduce using rule 39 (expression -> expression div expression .)
    comma           reduce using rule 39 (expression -> expression div expression .)
    power           shift and go to state 56

  ! power           [ reduce using rule 39 (expression -> expression div expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! times           [ shift and go to state 62 ]
  ! div             [ shift and go to state 70 ]
  ! modulo          [ shift and go to state 55 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! floordiv        [ shift and go to state 64 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 110

    (37) expression -> expression minus expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    plus            reduce using rule 37 (expression -> expression minus expression .)
    minus           reduce using rule 37 (expression -> expression minus expression .)
    lshift          reduce using rule 37 (expression -> expression minus expression .)
    rshift          reduce using rule 37 (expression -> expression minus expression .)
    and             reduce using rule 37 (expression -> expression minus expression .)
    or              reduce using rule 37 (expression -> expression minus expression .)
    xor             reduce using rule 37 (expression -> expression minus expression .)
    strand          reduce using rule 37 (expression -> expression minus expression .)
    stror           reduce using rule 37 (expression -> expression minus expression .)
    lt              reduce using rule 37 (expression -> expression minus expression .)
    gt              reduce using rule 37 (expression -> expression minus expression .)
    lequal          reduce using rule 37 (expression -> expression minus expression .)
    gequal          reduce using rule 37 (expression -> expression minus expression .)
    isnotequal      reduce using rule 37 (expression -> expression minus expression .)
    isequal         reduce using rule 37 (expression -> expression minus expression .)
    newline         reduce using rule 37 (expression -> expression minus expression .)
    print           reduce using rule 37 (expression -> expression minus expression .)
    identifier      reduce using rule 37 (expression -> expression minus expression .)
    input           reduce using rule 37 (expression -> expression minus expression .)
    invert          reduce using rule 37 (expression -> expression minus expression .)
    oparen          reduce using rule 37 (expression -> expression minus expression .)
    not             reduce using rule 37 (expression -> expression minus expression .)
    if              reduce using rule 37 (expression -> expression minus expression .)
    while           reduce using rule 37 (expression -> expression minus expression .)
    true            reduce using rule 37 (expression -> expression minus expression .)
    false           reduce using rule 37 (expression -> expression minus expression .)
    integer         reduce using rule 37 (expression -> expression minus expression .)
    $end            reduce using rule 37 (expression -> expression minus expression .)
    colon           reduce using rule 37 (expression -> expression minus expression .)
    cparen          reduce using rule 37 (expression -> expression minus expression .)
    dedent          reduce using rule 37 (expression -> expression minus expression .)
    comma           reduce using rule 37 (expression -> expression minus expression .)
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    floordiv        shift and go to state 64

  ! times           [ reduce using rule 37 (expression -> expression minus expression .) ]
  ! div             [ reduce using rule 37 (expression -> expression minus expression .) ]
  ! power           [ reduce using rule 37 (expression -> expression minus expression .) ]
  ! modulo          [ reduce using rule 37 (expression -> expression minus expression .) ]
  ! floordiv        [ reduce using rule 37 (expression -> expression minus expression .) ]
  ! plus            [ shift and go to state 65 ]
  ! minus           [ shift and go to state 71 ]
  ! lshift          [ shift and go to state 67 ]
  ! rshift          [ shift and go to state 69 ]
  ! and             [ shift and go to state 53 ]
  ! or              [ shift and go to state 54 ]
  ! xor             [ shift and go to state 61 ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]
  ! lt              [ shift and go to state 63 ]
  ! gt              [ shift and go to state 66 ]
  ! lequal          [ shift and go to state 60 ]
  ! gequal          [ shift and go to state 58 ]
  ! isnotequal      [ shift and go to state 59 ]
  ! isequal         [ shift and go to state 68 ]


state 111

    (48) expression -> expression strand expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    strand          reduce using rule 48 (expression -> expression strand expression .)
    stror           reduce using rule 48 (expression -> expression strand expression .)
    newline         reduce using rule 48 (expression -> expression strand expression .)
    print           reduce using rule 48 (expression -> expression strand expression .)
    identifier      reduce using rule 48 (expression -> expression strand expression .)
    input           reduce using rule 48 (expression -> expression strand expression .)
    invert          reduce using rule 48 (expression -> expression strand expression .)
    oparen          reduce using rule 48 (expression -> expression strand expression .)
    not             reduce using rule 48 (expression -> expression strand expression .)
    if              reduce using rule 48 (expression -> expression strand expression .)
    while           reduce using rule 48 (expression -> expression strand expression .)
    true            reduce using rule 48 (expression -> expression strand expression .)
    false           reduce using rule 48 (expression -> expression strand expression .)
    integer         reduce using rule 48 (expression -> expression strand expression .)
    $end            reduce using rule 48 (expression -> expression strand expression .)
    colon           reduce using rule 48 (expression -> expression strand expression .)
    cparen          reduce using rule 48 (expression -> expression strand expression .)
    dedent          reduce using rule 48 (expression -> expression strand expression .)
    comma           reduce using rule 48 (expression -> expression strand expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68

  ! plus            [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! minus           [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! times           [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! div             [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! power           [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! modulo          [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! lshift          [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! rshift          [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! floordiv        [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! and             [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! or              [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! xor             [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! lt              [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! gt              [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! lequal          [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! gequal          [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! isnotequal      [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! isequal         [ reduce using rule 48 (expression -> expression strand expression .) ]
  ! strand          [ shift and go to state 72 ]
  ! stror           [ shift and go to state 57 ]


state 112

    (56) ifstmt -> if expression colon newline . indent statement_list dedent
    (57) ifstmt -> if expression colon newline . indent statement_list dedent elsestmt

    indent          shift and go to state 116


state 113

    (8) expression -> input oparen parameters cparen .

    plus            reduce using rule 8 (expression -> input oparen parameters cparen .)
    minus           reduce using rule 8 (expression -> input oparen parameters cparen .)
    times           reduce using rule 8 (expression -> input oparen parameters cparen .)
    div             reduce using rule 8 (expression -> input oparen parameters cparen .)
    power           reduce using rule 8 (expression -> input oparen parameters cparen .)
    modulo          reduce using rule 8 (expression -> input oparen parameters cparen .)
    lshift          reduce using rule 8 (expression -> input oparen parameters cparen .)
    rshift          reduce using rule 8 (expression -> input oparen parameters cparen .)
    floordiv        reduce using rule 8 (expression -> input oparen parameters cparen .)
    and             reduce using rule 8 (expression -> input oparen parameters cparen .)
    or              reduce using rule 8 (expression -> input oparen parameters cparen .)
    xor             reduce using rule 8 (expression -> input oparen parameters cparen .)
    strand          reduce using rule 8 (expression -> input oparen parameters cparen .)
    stror           reduce using rule 8 (expression -> input oparen parameters cparen .)
    lt              reduce using rule 8 (expression -> input oparen parameters cparen .)
    gt              reduce using rule 8 (expression -> input oparen parameters cparen .)
    lequal          reduce using rule 8 (expression -> input oparen parameters cparen .)
    gequal          reduce using rule 8 (expression -> input oparen parameters cparen .)
    isnotequal      reduce using rule 8 (expression -> input oparen parameters cparen .)
    isequal         reduce using rule 8 (expression -> input oparen parameters cparen .)
    newline         reduce using rule 8 (expression -> input oparen parameters cparen .)
    print           reduce using rule 8 (expression -> input oparen parameters cparen .)
    identifier      reduce using rule 8 (expression -> input oparen parameters cparen .)
    input           reduce using rule 8 (expression -> input oparen parameters cparen .)
    invert          reduce using rule 8 (expression -> input oparen parameters cparen .)
    oparen          reduce using rule 8 (expression -> input oparen parameters cparen .)
    not             reduce using rule 8 (expression -> input oparen parameters cparen .)
    if              reduce using rule 8 (expression -> input oparen parameters cparen .)
    while           reduce using rule 8 (expression -> input oparen parameters cparen .)
    true            reduce using rule 8 (expression -> input oparen parameters cparen .)
    false           reduce using rule 8 (expression -> input oparen parameters cparen .)
    integer         reduce using rule 8 (expression -> input oparen parameters cparen .)
    $end            reduce using rule 8 (expression -> input oparen parameters cparen .)
    colon           reduce using rule 8 (expression -> input oparen parameters cparen .)
    cparen          reduce using rule 8 (expression -> input oparen parameters cparen .)
    dedent          reduce using rule 8 (expression -> input oparen parameters cparen .)
    comma           reduce using rule 8 (expression -> input oparen parameters cparen .)


state 114

    (10) parameters -> parameters comma . expression
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    name                           shift and go to state 27
    boolean                        shift and go to state 3
    num                            shift and go to state 7
    expression0                    shift and go to state 18
    expression                     shift and go to state 117

state 115

    (61) whilestmt -> while expression colon newline . indent statement_list dedent

    indent          shift and go to state 118


state 116

    (56) ifstmt -> if expression colon newline indent . statement_list dedent
    (57) ifstmt -> if expression colon newline indent . statement_list dedent elsestmt
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    ifstmt                         shift and go to state 5
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 9
    statement_list                 shift and go to state 119
    expression0                    shift and go to state 18
    expression                     shift and go to state 25

state 117

    (10) parameters -> parameters comma expression .
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    cparen          reduce using rule 10 (parameters -> parameters comma expression .)
    comma           reduce using rule 10 (parameters -> parameters comma expression .)
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68


state 118

    (61) whilestmt -> while expression colon newline indent . statement_list dedent
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 9
    statement_list                 shift and go to state 120
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 119

    (56) ifstmt -> if expression colon newline indent statement_list . dedent
    (57) ifstmt -> if expression colon newline indent statement_list . dedent elsestmt
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    dedent          shift and go to state 121
    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    ifstmt                         shift and go to state 5
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 52
    expression0                    shift and go to state 18
    expression                     shift and go to state 25

state 120

    (61) whilestmt -> while expression colon newline indent statement_list . dedent
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    dedent          shift and go to state 122
    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 52
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 121

    (56) ifstmt -> if expression colon newline indent statement_list dedent .
    (57) ifstmt -> if expression colon newline indent statement_list dedent . elsestmt
    (58) elsestmt -> . else colon newline indent statement_list dedent
    (59) elsestmt -> . elif expression colon newline indent statement_list dedent
    (60) elsestmt -> . elif expression colon newline indent statement_list dedent elsestmt

    newline         reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    dedent          reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    print           reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    identifier      reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    input           reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    minus           reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    plus            reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    invert          reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    oparen          reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    not             reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    if              reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    while           reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    true            reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    false           reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    integer         reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    $end            reduce using rule 56 (ifstmt -> if expression colon newline indent statement_list dedent .)
    else            shift and go to state 124
    elif            shift and go to state 123

    elsestmt                       shift and go to state 125

state 122

    (61) whilestmt -> while expression colon newline indent statement_list dedent .

    newline         reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    dedent          reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    print           reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    identifier      reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    input           reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    minus           reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    plus            reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    invert          reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    oparen          reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    not             reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    if              reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    while           reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    true            reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    false           reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    integer         reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)
    $end            reduce using rule 61 (whilestmt -> while expression colon newline indent statement_list dedent .)


state 123

    (59) elsestmt -> elif . expression colon newline indent statement_list dedent
    (60) elsestmt -> elif . expression colon newline indent statement_list dedent elsestmt
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (67) name -> . identifier
    (65) num -> . integer

    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    true            shift and go to state 19
    false           shift and go to state 4
    identifier      shift and go to state 28
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 27
    boolean                        shift and go to state 3
    expression0                    shift and go to state 18
    expression                     shift and go to state 126

state 124

    (58) elsestmt -> else . colon newline indent statement_list dedent

    colon           shift and go to state 127


state 125

    (57) ifstmt -> if expression colon newline indent statement_list dedent elsestmt .

    newline         reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    dedent          reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    print           reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    identifier      reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    input           reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    minus           reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    plus            reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    invert          reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    oparen          reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    not             reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    if              reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    while           reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    true            reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    false           reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    integer         reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)
    $end            reduce using rule 57 (ifstmt -> if expression colon newline indent statement_list dedent elsestmt .)


state 126

    (59) elsestmt -> elif expression . colon newline indent statement_list dedent
    (60) elsestmt -> elif expression . colon newline indent statement_list dedent elsestmt
    (36) expression -> expression . plus expression
    (37) expression -> expression . minus expression
    (38) expression -> expression . times expression
    (39) expression -> expression . div expression
    (40) expression -> expression . power expression
    (41) expression -> expression . modulo expression
    (42) expression -> expression . lshift expression
    (43) expression -> expression . rshift expression
    (44) expression -> expression . floordiv expression
    (45) expression -> expression . and expression
    (46) expression -> expression . or expression
    (47) expression -> expression . xor expression
    (48) expression -> expression . strand expression
    (49) expression -> expression . stror expression
    (50) expression -> expression . lt expression
    (51) expression -> expression . gt expression
    (52) expression -> expression . lequal expression
    (53) expression -> expression . gequal expression
    (54) expression -> expression . isnotequal expression
    (55) expression -> expression . isequal expression

    colon           shift and go to state 128
    plus            shift and go to state 65
    minus           shift and go to state 71
    times           shift and go to state 62
    div             shift and go to state 70
    power           shift and go to state 56
    modulo          shift and go to state 55
    lshift          shift and go to state 67
    rshift          shift and go to state 69
    floordiv        shift and go to state 64
    and             shift and go to state 53
    or              shift and go to state 54
    xor             shift and go to state 61
    strand          shift and go to state 72
    stror           shift and go to state 57
    lt              shift and go to state 63
    gt              shift and go to state 66
    lequal          shift and go to state 60
    gequal          shift and go to state 58
    isnotequal      shift and go to state 59
    isequal         shift and go to state 68


state 127

    (58) elsestmt -> else colon . newline indent statement_list dedent

    newline         shift and go to state 129


state 128

    (59) elsestmt -> elif expression colon . newline indent statement_list dedent
    (60) elsestmt -> elif expression colon . newline indent statement_list dedent elsestmt

    newline         shift and go to state 130


state 129

    (58) elsestmt -> else colon newline . indent statement_list dedent

    indent          shift and go to state 131


state 130

    (59) elsestmt -> elif expression colon newline . indent statement_list dedent
    (60) elsestmt -> elif expression colon newline . indent statement_list dedent elsestmt

    indent          shift and go to state 132


state 131

    (58) elsestmt -> else colon newline indent . statement_list dedent
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 9
    statement_list                 shift and go to state 133
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 132

    (59) elsestmt -> elif expression colon newline indent . statement_list dedent
    (60) elsestmt -> elif expression colon newline indent . statement_list dedent elsestmt
    (3) statement_list -> . statement
    (4) statement_list -> . statement_list statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    ifstmt                         shift and go to state 5
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 9
    statement_list                 shift and go to state 134
    expression0                    shift and go to state 18
    expression                     shift and go to state 25

state 133

    (58) elsestmt -> else colon newline indent statement_list . dedent
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    dedent          shift and go to state 135
    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 52
    expression0                    shift and go to state 18
    expression                     shift and go to state 25
    ifstmt                         shift and go to state 5

state 134

    (59) elsestmt -> elif expression colon newline indent statement_list . dedent
    (60) elsestmt -> elif expression colon newline indent statement_list . dedent elsestmt
    (4) statement_list -> statement_list . statement
    (5) statement -> . newline statement
    (6) statement -> . statement newline
    (7) statement -> . print expression
    (12) statement -> . assname equals expression
    (13) statement -> . expression
    (14) statement -> . ifstmt
    (15) statement -> . whilestmt
    (16) statement -> . name incassign expression
    (17) statement -> . name decassign expression
    (18) statement -> . name divassign expression
    (19) statement -> . name mulassign expression
    (20) statement -> . name modassign expression
    (21) statement -> . name lshiftassign expression
    (22) statement -> . name rshiftassign expression
    (23) statement -> . name andassign expression
    (24) statement -> . name orassign expression
    (25) statement -> . name xorassign expression
    (26) statement -> . name powerassign expression
    (27) statement -> . name floorassign expression
    (66) assname -> . identifier
    (8) expression -> . input oparen parameters cparen
    (28) expression -> . boolean
    (29) expression -> . minus expression
    (30) expression -> . plus expression
    (31) expression -> . invert expression
    (32) expression -> . expression0
    (33) expression -> . oparen expression cparen
    (34) expression -> . not expression
    (35) expression -> . name
    (36) expression -> . expression plus expression
    (37) expression -> . expression minus expression
    (38) expression -> . expression times expression
    (39) expression -> . expression div expression
    (40) expression -> . expression power expression
    (41) expression -> . expression modulo expression
    (42) expression -> . expression lshift expression
    (43) expression -> . expression rshift expression
    (44) expression -> . expression floordiv expression
    (45) expression -> . expression and expression
    (46) expression -> . expression or expression
    (47) expression -> . expression xor expression
    (48) expression -> . expression strand expression
    (49) expression -> . expression stror expression
    (50) expression -> . expression lt expression
    (51) expression -> . expression gt expression
    (52) expression -> . expression lequal expression
    (53) expression -> . expression gequal expression
    (54) expression -> . expression isnotequal expression
    (55) expression -> . expression isequal expression
    (56) ifstmt -> . if expression colon newline indent statement_list dedent
    (57) ifstmt -> . if expression colon newline indent statement_list dedent elsestmt
    (61) whilestmt -> . while expression colon newline indent statement_list dedent
    (67) name -> . identifier
    (68) boolean -> . true
    (69) boolean -> . false
    (62) expression0 -> . num
    (63) expression0 -> . name
    (64) expression0 -> . boolean
    (65) num -> . integer

    dedent          shift and go to state 136
    newline         shift and go to state 14
    print           shift and go to state 11
    identifier      shift and go to state 24
    input           shift and go to state 12
    minus           shift and go to state 26
    plus            shift and go to state 22
    invert          shift and go to state 8
    oparen          shift and go to state 10
    not             shift and go to state 17
    if              shift and go to state 6
    while           shift and go to state 21
    true            shift and go to state 19
    false           shift and go to state 4
    integer         shift and go to state 13

    num                            shift and go to state 7
    name                           shift and go to state 20
    ifstmt                         shift and go to state 5
    whilestmt                      shift and go to state 2
    assname                        shift and go to state 16
    boolean                        shift and go to state 3
    statement                      shift and go to state 52
    expression0                    shift and go to state 18
    expression                     shift and go to state 25

state 135

    (58) elsestmt -> else colon newline indent statement_list dedent .

    newline         reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    print           reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    identifier      reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    input           reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    minus           reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    plus            reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    invert          reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    oparen          reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    not             reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    if              reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    while           reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    true            reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    false           reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    integer         reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    $end            reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)
    dedent          reduce using rule 58 (elsestmt -> else colon newline indent statement_list dedent .)


state 136

    (59) elsestmt -> elif expression colon newline indent statement_list dedent .
    (60) elsestmt -> elif expression colon newline indent statement_list dedent . elsestmt
    (58) elsestmt -> . else colon newline indent statement_list dedent
    (59) elsestmt -> . elif expression colon newline indent statement_list dedent
    (60) elsestmt -> . elif expression colon newline indent statement_list dedent elsestmt

    newline         reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    print           reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    identifier      reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    input           reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    minus           reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    plus            reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    invert          reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    oparen          reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    not             reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    if              reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    while           reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    true            reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    false           reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    integer         reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    $end            reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    dedent          reduce using rule 59 (elsestmt -> elif expression colon newline indent statement_list dedent .)
    else            shift and go to state 124
    elif            shift and go to state 123

    elsestmt                       shift and go to state 137

state 137

    (60) elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .

    newline         reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    print           reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    identifier      reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    input           reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    minus           reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    plus            reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    invert          reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    oparen          reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    not             reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    if              reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    while           reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    true            reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    false           reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    integer         reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    $end            reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)
    dedent          reduce using rule 60 (elsestmt -> elif expression colon newline indent statement_list dedent elsestmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for newline in state 9 resolved as shift
WARNING: shift/reduce conflict for plus in state 25 resolved as shift
WARNING: shift/reduce conflict for minus in state 25 resolved as shift
WARNING: shift/reduce conflict for newline in state 35 resolved as shift
WARNING: shift/reduce conflict for newline in state 52 resolved as shift
WARNING: shift/reduce conflict for plus in state 78 resolved as shift
WARNING: shift/reduce conflict for minus in state 78 resolved as shift
WARNING: shift/reduce conflict for plus in state 79 resolved as shift
WARNING: shift/reduce conflict for minus in state 79 resolved as shift
WARNING: shift/reduce conflict for plus in state 80 resolved as shift
WARNING: shift/reduce conflict for minus in state 80 resolved as shift
WARNING: shift/reduce conflict for plus in state 81 resolved as shift
WARNING: shift/reduce conflict for minus in state 81 resolved as shift
WARNING: shift/reduce conflict for plus in state 82 resolved as shift
WARNING: shift/reduce conflict for minus in state 82 resolved as shift
WARNING: shift/reduce conflict for plus in state 83 resolved as shift
WARNING: shift/reduce conflict for minus in state 83 resolved as shift
WARNING: shift/reduce conflict for plus in state 84 resolved as shift
WARNING: shift/reduce conflict for minus in state 84 resolved as shift
WARNING: shift/reduce conflict for plus in state 85 resolved as shift
WARNING: shift/reduce conflict for minus in state 85 resolved as shift
WARNING: shift/reduce conflict for plus in state 86 resolved as shift
WARNING: shift/reduce conflict for minus in state 86 resolved as shift
WARNING: shift/reduce conflict for plus in state 87 resolved as shift
WARNING: shift/reduce conflict for minus in state 87 resolved as shift
WARNING: shift/reduce conflict for plus in state 88 resolved as shift
WARNING: shift/reduce conflict for minus in state 88 resolved as shift
WARNING: shift/reduce conflict for plus in state 89 resolved as shift
WARNING: shift/reduce conflict for minus in state 89 resolved as shift
WARNING: shift/reduce conflict for plus in state 90 resolved as shift
WARNING: shift/reduce conflict for minus in state 90 resolved as shift
WARNING: reduce/reduce conflict in state 3 resolved using rule (expression -> boolean)
WARNING: rejected rule (expression0 -> boolean) in state 3
WARNING: reduce/reduce conflict in state 20 resolved using rule (expression -> name)
WARNING: rejected rule (expression0 -> name) in state 20
WARNING: reduce/reduce conflict in state 27 resolved using rule (expression -> name)
WARNING: rejected rule (expression0 -> name) in state 27
WARNING: Rule (expression0 -> boolean) is never reduced
WARNING: Rule (expression0 -> name) is never reduced
